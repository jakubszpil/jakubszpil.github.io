[{"_1":2},"course-details",{"_3":4},"data",{"_5":6,"_7":8,"_9":10,"_18":19,"_20":21,"_22":23,"_74":75,"_76":77,"_78":79,"_80":81,"_82":83},"title","Renesans w JS, czyli nowoczesny JavaScript","description","JavaScript jest językiem programowania, który jest powszechnie stosowany do tworzenia dynamicznych i interaktywnych stron internetowych. W ciągu ostatnich lat JavaScript znacznie ewoluował, wprowadzając nowe funkcje i poprawiając istniejące mechanizmy. W tym kursie omówimy najważniejsze elementy nowoczesnego JavaScript, w tym ES6 i nowsze.","keywords",[11,12,13,14,15,16,17],"javascript","kurs","wprowadzenie","przewodnik","web","frontend","learning","categories",[11],"createdAt","2024-06-30T00:00:00.000Z","quiz",{"_5":24,"_25":26},"Quiz: Podstawy nowoczesnego JavaScript","questions",[27,40,49,57,65],{"_28":29,"_30":31,"_36":37,"_38":39},"question","<p>Jaką główną różnicę między <code>let</code> a <code>var</code> podkreśla się w nowoczesnym JavaScript?</p>","options",[32,33,34,35],"`let` nie pozwala na przyjmowanie wartości domyślnej","Obie są identyczne","Zakres blokowy (`block scope`) w `let`","`var` nie istnieje w nowoczesnym JS","answer",2,"explanation","`let` posiada zakres blokowy, podczas gdy `var` ma zakres funkcyjny.",{"_28":41,"_30":42,"_36":47,"_38":48},"<p>Co zwróci poniższy kod?</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> arr = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];\n<span class=\"hljs-keyword\">const</span> [a, , b] = arr;\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a, b);\n</code></pre>",[43,44,45,46],"2 3","1 3","undefined 3","1 2",1,"Drugi element jest pomijany. Wynik to 1 i 3.",{"_28":50,"_30":51,"_36":47,"_38":56},"<p>Co robi operator spread (<code>...</code>)?</p>",[52,53,54,55],"Łączy Promise'y","Rozwija elementy tablicy lub właściwości obiektu","Deklaruje zmienną stałą","Tworzy nowy Promise","Spread operator służy do rozwijania/skopiowania elementów tablicy lub obiektu.",{"_28":58,"_30":59,"_36":37,"_38":64},"<p>Czym różni się funkcja strzałkowa od zwykłej funkcji pod względem <code>this</code>?</p>",[60,61,62,63],"Nie ma różnicy","Funkcje strzałkowe nie działają w JS","Funkcja strzałkowa nie ma własnego `this`","Funkcja strzałkowa tworzy nowy kontekst `this`","Funkcje strzałkowe nie posiadają własnego `this` — dziedziczą go z otoczenia.",{"_28":66,"_30":67,"_36":72,"_38":73},"<p>Jaką wartość zwróci poniższy kod?</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">test</span>(<span class=\"hljs-params\"></span>) { <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">5</span>; }\n<span class=\"hljs-title function_\">test</span>().<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-property\">log</span>);\n</code></pre>",[68,69,70,71],"Promise {<fulfilled>: 5}","undefined","Błąd","5",3,"Funkcja async zawsze zwraca Promise, ale `then` wypisze wartość 5.","id","5170d513-8292-4721-8410-c4303b4c0d8e","slug","nowoczesny-javascript","content","<p>Witaj w świecie <strong>nowoczesnego JavaScriptu</strong>! 🚀 Jeśli HTML to szkielet strony, a CSS to jej wygląd, to JavaScript jest sercem i mózgiem – sprawia, że strona ożywa, staje się interaktywna i dynamiczna. W ciągu ostatnich lat JavaScript przeszedł prawdziwy \"renesans\". Dzięki wprowadzeniu standardu <strong>ES6</strong> (ECMAScript 2015) i kolejnych aktualizacji, pisanie kodu w JS stało się znacznie przyjemniejsze, bezpieczniejsze i bardziej efektywne.</p>\n<p>Ten przewodnik zabierze Cię w podróż po najważniejszych nowościach, które musisz znać, aby pisać <strong>nowoczesny JavaScript</strong>. Nie martw się, jeśli jesteś początkujący/a – wszystko wyjaśnimy krok po kroku, z przykładami i analogiami, byś mógł/mogła od razu zastosować nową wiedzę w praktyce. Czas unowocześnić swoje umiejętności! ✨</p>\n<h2 id=\"spis-treści\" class=\"scroll-mt-20 lg:scroll-mt-10\"><a class=\"mr-2 no-underline hover:underline focus-visible:underline select-none\" href=\"#spis-treści\">>></a>Spis treści</h2>\n<ol>\n<li><a href=\"#zmienne-let-const-i-zakresy-blokowe--po%C5%BCegnanie-z-var\">Zmienne: <code>let</code>, <code>const</code> i zakresy blokowe – pożegnanie z <code>var</code>?</a></li>\n<li><a href=\"#funkcje-strza%C5%82kowe-arrow-functions-i-ich-zastosowania--kr%C3%B3cej-i-czytelniej\">Funkcje strzałkowe (Arrow Functions) i ich zastosowania – krócej i czytelniej</a></li>\n<li><a href=\"#szablony-string%C3%B3w-template-literals--%C5%82atwiejsza-praca-z-tekstem\">Szablony stringów (Template Literals) – łatwiejsza praca z tekstem</a></li>\n<li><a href=\"#destrukturyzacja-tablic-i-obiekt%C3%B3w--wyci%C4%85gnij-to-czego-potrzebujesz\">Destrukturyzacja tablic i obiektów – wyciągnij to, czego potrzebujesz</a></li>\n<li><a href=\"#spread-i-rest-operator---elastyczno%C5%9B%C4%87-w-manipulacji-danymi\">Spread i Rest Operator (<code>...</code>) – elastyczność w manipulacji danymi</a></li>\n<li><a href=\"#promise-api-i-obs%C5%82uga-asynchroniczno%C5%9Bci--opowiadaj-historie-o-przysz%C5%82o%C5%9Bci\">Promise API i obsługa asynchroniczności – opowiadaj historie o przyszłości</a></li>\n<li><a href=\"#asyncawait--nowoczesna-obs%C5%82uga-kodu-asynchronicznego--pisz-asynchronicznie-my%C5%9Bl-synchronicznie\">Async/await – nowoczesna obsługa kodu asynchronicznego – pisz asynchronicznie, myśl synchronicznie</a></li>\n<li><a href=\"#zadania-do-wykonania-sprawd%C5%BA-swoj%C4%85-wiedz%C4%99\">Zadania do wykonania: Sprawdź swoją wiedzę!</a></li>\n</ol>\n<hr>\n<h2 id=\"zmienne-let-const-i-zakresy-blokowe--pożegnanie-z-var\" class=\"scroll-mt-20 lg:scroll-mt-10\"><a class=\"mr-2 no-underline hover:underline focus-visible:underline select-none\" href=\"#zmienne-let-const-i-zakresy-blokowe--pożegnanie-z-var\">>></a>Zmienne: <code>let</code>, <code>const</code> i zakresy blokowe – pożegnanie z <code>var</code>?</h2>\n<p>W starszych wersjach JavaScriptu zmienne deklarowaliśmy wyłącznie za pomocą słowa kluczowego <code>var</code>. Często prowadziło to do pomyłek i trudnych do wykrycia błędów. Nowoczesny JavaScript wprowadza dwa nowe sposoby deklarowania zmiennych: <strong><code>let</code></strong> i <strong><code>const</code></strong>, które znacznie poprawiają bezpieczeństwo i przewidywalność kodu.</p>\n<h3 id=\"zakres-blokowy-block-scope\" class=\"scroll-mt-20 lg:scroll-mt-10\"><a class=\"mr-2 no-underline hover:underline focus-visible:underline select-none\" href=\"#zakres-blokowy-block-scope\">>>></a>Zakres blokowy (<code>block scope</code>)</h3>\n<p>To kluczowa różnica! Zmienne zadeklarowane za pomocą <code>let</code> i <code>const</code> mają <strong>zakres blokowy</strong>. Co to znaczy? Oznaczają, że zmienna istnieje tylko w obrębie najbliższego <strong>bloku kodu</strong>, czyli wszystko, co znajduje się między klamrowymi nawiasami <code>{ ... }</code>.</p>\n<p>Pomyśl o tym jak o specjalnej, prywatnej przestrzeni. Jeśli zmienna <code>x</code> jest zadeklarowana wewnątrz bloku <code>if</code>, będzie dostępna tylko w tym bloku. Próba użycia jej poza nim spowoduje błąd. To chroni Cię przed przypadkowym nadpisaniem zmiennych o tej samej nazwie w innej części kodu.</p>\n<p><strong>Przykład:</strong></p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">if</span> (<span class=\"hljs-literal\">true</span>) {\n  <span class=\"hljs-keyword\">let</span> x = <span class=\"hljs-number\">5</span>; <span class=\"hljs-comment\">// x istnieje tylko wewnątrz tego bloku if</span>\n  <span class=\"hljs-keyword\">const</span> y = <span class=\"hljs-number\">10</span>; <span class=\"hljs-comment\">// y również istnieje tylko wewnątrz tego bloku</span>\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(x); <span class=\"hljs-comment\">// Wyświetli: 5 (dostępne, bo jesteśmy w bloku)</span>\n}\n<span class=\"hljs-comment\">// console.log(x); // WYWOŁA BŁĄD! ReferenceError: x is not defined</span>\n<span class=\"hljs-comment\">// console.log(y); // WYWOŁA BŁĄD! ReferenceError: y is not defined</span>\n</code></pre>\n<p>Dla porównania, <code>var</code> ma <strong>zakres funkcyjny</strong> (function scope), co oznacza, że zmienna zadeklarowana w funkcji jest dostępna w całej funkcji, ale poza funkcją jest dostępna globalnie, co jest źródłem wielu problemów. Dlatego w nowoczesnym kodzie <strong>zdecydowanie unikamy <code>var</code></strong>.</p>\n<h3 id=\"różnice-między-let-const-i-var\" class=\"scroll-mt-20 lg:scroll-mt-10\"><a class=\"mr-2 no-underline hover:underline focus-visible:underline select-none\" href=\"#różnice-między-let-const-i-var\">>>></a>Różnice między <code>let</code>, <code>const</code> i <code>var</code></h3>\n<ul>\n<li>\n<p><strong><code>let</code></strong>:</p>\n<ul>\n<li><strong>Deklaruje zmienną</strong>, której wartość może być <strong>zmieniana</strong> w dowolnym momencie.</li>\n<li>Ma <strong>zakres blokowy</strong>.</li>\n<li>Nie można jej ponownie zadeklarować w tym samym bloku (np. <code>let x = 5; let x = 10;</code> to błąd), ale można zmienić jej wartość (<code>x = 10;</code>).</li>\n<li>Używaj <code>let</code>, gdy wiesz, że wartość zmiennej będzie się zmieniać (np. licznik w pętli).</li>\n</ul>\n</li>\n<li>\n<p><strong><code>const</code></strong>:</p>\n<ul>\n<li>Deklaruje <strong>stałą</strong>, której wartość musi być <strong>przypisana od razu</strong> i <strong>nie może być zmieniana</strong> później.</li>\n<li>Ma <strong>zakres blokowy</strong>.</li>\n<li>Jeśli przypiszesz do <code>const</code> obiekt lub tablicę, nie możesz przypisać do niej <em>nowego</em> obiektu/tablicy, ale możesz <strong>modyfikować zawartość</strong> tego obiektu/tablicy (np. dodawać lub usuwać elementy). <code>const</code> gwarantuje, że referencja (wskaźnik) do obiektu pozostaje taka sama, ale nie \"zamraża\" samego obiektu.</li>\n<li>Używaj <code>const</code>, gdy wartość zmiennej nie powinna się zmieniać. To jest domyślny wybór w nowoczesnym JS, chyba że potrzebujesz <code>let</code>.</li>\n</ul>\n</li>\n<li>\n<p><strong><code>var</code></strong>:</p>\n<ul>\n<li><strong>Ma zakres funkcyjny</strong> (lub globalny, jeśli jest poza funkcją).</li>\n<li>Jest podatny na <strong>hoisting</strong> (podnoszenie deklaracji), co oznacza, że deklaracja zmiennej jest \"przenoszona\" na początek zakresu, co może prowadzić do nieintuicyjnych zachowań.</li>\n<li>Można go <strong>wielokrotnie deklarować</strong> w tym samym zakresie, co łatwo prowadzi do przypadkowych nadpisań.</li>\n<li><strong>Unikaj używania <code>var</code> w nowym kodzie!</strong></li>\n</ul>\n</li>\n</ul>\n<p><strong>Przykład <code>const</code> z obiektem/tablicą:</strong></p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> tablica = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];\ntablica.<span class=\"hljs-title function_\">push</span>(<span class=\"hljs-number\">4</span>); <span class=\"hljs-comment\">// DOZWOLONE! Zmieniamy zawartość tablicy, nie przypisujemy nowej tablicy.</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(tablica); <span class=\"hljs-comment\">// Wyświetli: [1, 2, 3, 4]</span>\n\n<span class=\"hljs-comment\">// tablica = [5, 6]; // WYWOŁA BŁĄD! TypeError: Assignment to constant variable.</span>\n<span class=\"hljs-comment\">// Próbujesz przypisać zupełnie nową tablicę do stałej referencji.</span>\n\n<span class=\"hljs-keyword\">const</span> osoba = { <span class=\"hljs-attr\">imie</span>: <span class=\"hljs-string\">\"Anna\"</span>, <span class=\"hljs-attr\">wiek</span>: <span class=\"hljs-number\">28</span> };\nosoba.<span class=\"hljs-property\">wiek</span> = <span class=\"hljs-number\">29</span>; <span class=\"hljs-comment\">// DOZWOLONE! Zmieniamy właściwość obiektu, nie przypisujemy nowego obiektu.</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(osoba); <span class=\"hljs-comment\">// Wyświetli: { imie: \"Anna\", wiek: 29 }</span>\n\n<span class=\"hljs-comment\">// osoba = { nazwisko: \"Nowak\" }; // WYWOŁA BŁĄD!</span>\n</code></pre>\n<hr>\n<h2 id=\"funkcje-strzałkowe-arrow-functions-i-ich-zastosowania--krócej-i-czytelniej\" class=\"scroll-mt-20 lg:scroll-mt-10\"><a class=\"mr-2 no-underline hover:underline focus-visible:underline select-none\" href=\"#funkcje-strzałkowe-arrow-functions-i-ich-zastosowania--krócej-i-czytelniej\">>></a>Funkcje strzałkowe (Arrow Functions) i ich zastosowania – krócej i czytelniej</h2>\n<p>Funkcje strzałkowe to zwięzła alternatywa dla tradycyjnych funkcji JavaScript, która została wprowadzona w ES6. Są nie tylko krótsze, ale także rozwiązują pewien problem z kontekstem <code>this</code>, który często mylił początkujących programistów.</p>\n<h3 id=\"składnia-funkcji-strzałkowej\" class=\"scroll-mt-20 lg:scroll-mt-10\"><a class=\"mr-2 no-underline hover:underline focus-visible:underline select-none\" href=\"#składnia-funkcji-strzałkowej\">>>></a>Składnia funkcji strzałkowej</h3>\n<p>Największą zaletą funkcji strzałkowych jest ich zwięzła składnia, zwłaszcza dla prostych funkcji.</p>\n<ul>\n<li>\n<p><strong>Szybszy zapis (szczególnie dla funkcji jedno-liniowych):</strong>\nJeśli funkcja składa się tylko z jednej instrukcji, która zwraca wartość, możesz pominąć nawiasy klamrowe <code>{}</code> i słowo kluczowe <code>return</code>.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-comment\">// Tradycyjna funkcja</span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">dodajStara</span>(<span class=\"hljs-params\">a, b</span>) {\n  <span class=\"hljs-keyword\">return</span> a + b;\n}\n\n<span class=\"hljs-comment\">// Funkcja strzałkowa (krótszy zapis)</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">dodaj</span> = (<span class=\"hljs-params\">a, b</span>) => a + b;\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">dodaj</span>(<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">3</span>)); <span class=\"hljs-comment\">// Wyświetli: 8</span>\n\n<span class=\"hljs-comment\">// Funkcja z jednym argumentem (można pominąć nawiasy wokół argumentu)</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">powitanie</span> = (<span class=\"hljs-params\">imie</span>) => <span class=\"hljs-string\">`Cześć, <span class=\"hljs-subst\">${imie}</span>!`</span>;\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">powitanie</span>(<span class=\"hljs-string\">\"Ola\"</span>)); <span class=\"hljs-comment\">// Wyświetli: Cześć, Ola!</span>\n\n<span class=\"hljs-comment\">// Funkcja bez argumentów (konieczne puste nawiasy)</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">powiedzHello</span> = (<span class=\"hljs-params\"></span>) => <span class=\"hljs-string\">\"Hello!\"</span>;\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">powiedzHello</span>()); <span class=\"hljs-comment\">// Wyświetli: Hello!</span>\n</code></pre>\n</li>\n<li>\n<p><strong>Brak własnego obiektu <code>arguments</code>:</strong> Funkcje strzałkowe nie mają własnego obiektu <code>arguments</code> (który zawiera wszystkie argumenty przekazane do funkcji). Jeśli go potrzebujesz, użyj <strong>rest operatora</strong> (<code>...</code>), o którym powiemy później.</p>\n</li>\n<li>\n<p><strong>Brak możliwości użycia jako konstruktor:</strong> Nie możesz użyć funkcji strzałkowej do tworzenia nowych obiektów za pomocą słowa kluczowego <code>new</code>.</p>\n</li>\n</ul>\n<h3 id=\"funkcje-strzałkowe-a-kontekst-this\" class=\"scroll-mt-20 lg:scroll-mt-10\"><a class=\"mr-2 no-underline hover:underline focus-visible:underline select-none\" href=\"#funkcje-strzałkowe-a-kontekst-this\">>>></a>Funkcje strzałkowe a kontekst <code>this</code></h3>\n<p>To jest jeden z najważniejszych powodów, dla których wprowadzono funkcje strzałkowe. W tradycyjnych funkcjach, wartość <code>this</code> zależy od tego, jak funkcja jest wywoływana. To prowadziło do częstych błędów, zwłaszcza w callbackach (funkcjach wywoływanych przez inne funkcje, np. w <code>setTimeout</code> czy w obsłudze zdarzeń).</p>\n<p>Funkcje strzałkowe rozwiązują ten problem: <strong>nie mają własnego <code>this</code></strong>. Zamiast tego, <strong>dziedziczą <code>this</code> z otoczenia, w którym zostały zadeklarowane</strong> (tzw. leksykalny <code>this</code>).</p>\n<p><strong>Przykład problemu ze <code>this</code> w tradycyjnych funkcjach:</strong></p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-comment\">// Tradycyjna funkcja, która \"gubi\" kontekst this</span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">TimerProblem</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">sekundy</span> = <span class=\"hljs-number\">0</span>;\n  <span class=\"hljs-built_in\">setInterval</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-comment\">// Tutaj 'this' nie odnosi się do obiektu TimerProblem,</span>\n    <span class=\"hljs-comment\">// ale do obiektu globalnego (np. window w przeglądarce) lub jest undefined w trybie 'strict mode'</span>\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">sekundy</span>++; <span class=\"hljs-comment\">// To nie zadziała tak, jak byśmy chcieli!</span>\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">sekundy</span>);\n  }, <span class=\"hljs-number\">1000</span>);\n}\n<span class=\"hljs-comment\">// new TimerProblem(); // W konsoli prawdopodobnie zobaczysz NaN lub błąd</span>\n</code></pre>\n<p><strong>Rozwiązanie z funkcją strzałkową:</strong></p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">TimerPoprawny</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">sekundy</span> = <span class=\"hljs-number\">0</span>;\n  <span class=\"hljs-comment\">// Funkcja strzałkowa dziedziczy 'this' z TimerPoprawny (czyli z obiektu TimerPoprawny)</span>\n  <span class=\"hljs-built_in\">setInterval</span>(<span class=\"hljs-function\">() =></span> {\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">sekundy</span>++;\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`Sekundy: <span class=\"hljs-subst\">${<span class=\"hljs-variable language_\">this</span>.sekundy}</span>`</span>);\n  }, <span class=\"hljs-number\">1000</span>);\n}\n<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">TimerPoprawny</span>(); <span class=\"hljs-comment\">// Będzie poprawnie liczyć sekundy: Sekundy: 1, Sekundy: 2, itd.</span>\n</code></pre>\n<p>Dzięki temu funkcje strzałkowe są idealne do użycia w callbackach, metodach obiektów (choć nie jako metody obiektów najwyższego poziomu, bo wtedy <code>this</code> wskazałoby na <code>window</code>), czy w sytuacjach, gdzie chcesz, aby <code>this</code> zachowało kontekst nadrzędny.</p>\n<hr>\n<h2 id=\"szablony-stringów-template-literals--łatwiejsza-praca-z-tekstem\" class=\"scroll-mt-20 lg:scroll-mt-10\"><a class=\"mr-2 no-underline hover:underline focus-visible:underline select-none\" href=\"#szablony-stringów-template-literals--łatwiejsza-praca-z-tekstem\">>></a>Szablony stringów (Template Literals) – łatwiejsza praca z tekstem</h2>\n<p>Szablony stringów, wprowadzone w ES6, to potężne narzędzie do tworzenia ciągów znaków (stringów). Zastępują tradycyjne łączenie stringów za pomocą operatora <code>+</code> i oferują znacznie większą elastyczność i czytelność. Używamy ich, otaczając tekst <strong>backtickami</strong> (apostrofami wstecznymi) <code> </code> zamiast pojedynczych lub podwójnych cudzysłowów.</p>\n<h3 id=\"interpolacja-i-wielolinijkowość\" class=\"scroll-mt-20 lg:scroll-mt-10\"><a class=\"mr-2 no-underline hover:underline focus-visible:underline select-none\" href=\"#interpolacja-i-wielolinijkowość\">>>></a>Interpolacja i wielolinijkowość</h3>\n<ul>\n<li>\n<p><strong>Interpolacja zmiennych i wyrażeń:</strong>\nMożesz łatwo osadzać zmienne lub dowolne wyrażenia JavaScript bezpośrednio w stringu, używając składni <code>${...}</code>. To znacznie ułatwia budowanie dynamicznych komunikatów.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> imie = <span class=\"hljs-string\">\"Alicja\"</span>;\n<span class=\"hljs-keyword\">const</span> wiek = <span class=\"hljs-number\">30</span>;\n\n<span class=\"hljs-comment\">// Stary sposób: męczące łączenie stringów</span>\n<span class=\"hljs-keyword\">const</span> infoStare = <span class=\"hljs-string\">\"Mam na imię \"</span> + imie + <span class=\"hljs-string\">\" i mam \"</span> + wiek + <span class=\"hljs-string\">\" lat.\"</span>;\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(infoStare); <span class=\"hljs-comment\">// Wyświetli: Mam na imię Alicja i mam 30 lat.</span>\n\n<span class=\"hljs-comment\">// Nowy sposób z szablonami stringów: czytelniej i prościej!</span>\n<span class=\"hljs-keyword\">const</span> infoNowe = <span class=\"hljs-string\">`Mam na imię <span class=\"hljs-subst\">${imie}</span> i mam <span class=\"hljs-subst\">${wiek}</span> lat.`</span>;\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(infoNowe); <span class=\"hljs-comment\">// Wyświetli: Mam na imię Alicja i mam 30 lat.</span>\n\n<span class=\"hljs-comment\">// Możesz umieszczać dowolne wyrażenia JavaScript:</span>\n<span class=\"hljs-keyword\">const</span> cena = <span class=\"hljs-number\">10.5</span>;\n<span class=\"hljs-keyword\">const</span> ilosc = <span class=\"hljs-number\">2</span>;\n<span class=\"hljs-keyword\">const</span> rachunek = <span class=\"hljs-string\">`Koszt zakupu: <span class=\"hljs-subst\">${cena * ilosc}</span> zł.`</span>;\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(rachunek); <span class=\"hljs-comment\">// Wyświetli: Koszt zakupu: 21 zł.</span>\n</code></pre>\n</li>\n<li>\n<p><strong>Łatwe tworzenie tekstów wielolinijkowych:</strong>\nKoniec z dodawaniem <code>n</code> do każdej linii! W szablonach stringów możesz po prostu nacisnąć Enter, a tekst zachowa formatowanie z nowymi liniami. Jest to szczególnie przydatne przy generowaniu fragmentów HTML bezpośrednio w JavaScript.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-comment\">// Stary sposób: brzydkie i niewygodne</span>\n<span class=\"hljs-keyword\">const</span> htmlStare =\n  <span class=\"hljs-string\">\"&#x3C;div>\\n  &#x3C;h1>Witaj!&#x3C;/h1>\\n  &#x3C;p>To jest wielolinijkowy tekst.&#x3C;/p>\\n&#x3C;/div>\"</span>;\n\n<span class=\"hljs-comment\">// Nowy sposób: super czytelne!</span>\n<span class=\"hljs-keyword\">const</span> htmlNowe = <span class=\"hljs-string\">`\n  &#x3C;div>\n    &#x3C;h1>Witaj!&#x3C;/h1>\n    &#x3C;p>To jest wielolinijkowy tekst. I kolejna linia w tym samym akapicie.&#x3C;/p>\n  &#x3C;/div>\n`</span>;\n\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(htmlNowe);\n</code></pre>\n</li>\n</ul>\n<h3 id=\"dodatkowe-możliwości\" class=\"scroll-mt-20 lg:scroll-mt-10\"><a class=\"mr-2 no-underline hover:underline focus-visible:underline select-none\" href=\"#dodatkowe-możliwości\">>>></a>Dodatkowe możliwości</h3>\n<p>Szablony stringów wspierają także tzw. <strong>tagowane szablony</strong> (<code>tagged templates</code>), które pozwalają na zaawansowaną manipulację tekstem przed jego finalnym utworzeniem. Możesz zdefiniować funkcję (\"tag\"), która będzie przetwarzać części stringu i wartości zmiennych. Jest to bardziej zaawansowana funkcja, używana np. do tłumaczeń, walidacji, bezpiecznego generowania HTML (zapobieganie XSS) czy formatowania danych.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-comment\">// Przykład funkcji \"tagującej\"</span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">upper</span>(<span class=\"hljs-params\">strings, ...values</span>) {\n  <span class=\"hljs-comment\">// 'strings' to tablica tekstów, 'values' to tablica zmiennych</span>\n  <span class=\"hljs-keyword\">let</span> wynik = strings[<span class=\"hljs-number\">0</span>];\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &#x3C; values.<span class=\"hljs-property\">length</span>; i++) {\n    wynik += values[i].<span class=\"hljs-title function_\">toUpperCase</span>() + strings[i + <span class=\"hljs-number\">1</span>]; <span class=\"hljs-comment\">// Zamienia zmienne na duże litery</span>\n  }\n  <span class=\"hljs-keyword\">return</span> wynik;\n}\n\n<span class=\"hljs-keyword\">const</span> imie = <span class=\"hljs-string\">\"Kasia\"</span>;\n<span class=\"hljs-keyword\">const</span> wiek = <span class=\"hljs-number\">20</span>;\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(upper<span class=\"hljs-string\">`Cześć, <span class=\"hljs-subst\">${imie}</span>! Masz <span class=\"hljs-subst\">${wiek}</span> lat?`</span>); <span class=\"hljs-comment\">// Wyświetli: Cześć, KASIA! Masz 20 lat?</span>\n</code></pre>\n<p>W tym przykładzie funkcja <code>upper</code> została \"przypięta\" do szablonu stringu i zmodyfikowała zmienną <code>imie</code> na wielkie litery.</p>\n<hr>\n<h2 id=\"destrukturyzacja-tablic-i-obiektów--wyciągnij-to-czego-potrzebujesz\" class=\"scroll-mt-20 lg:scroll-mt-10\"><a class=\"mr-2 no-underline hover:underline focus-visible:underline select-none\" href=\"#destrukturyzacja-tablic-i-obiektów--wyciągnij-to-czego-potrzebujesz\">>></a>Destrukturyzacja tablic i obiektów – wyciągnij to, czego potrzebujesz</h2>\n<p>Destrukturyzacja to potężna i bardzo często używana funkcja w nowoczesnym JavaScript. Pozwala na \"rozpakowanie\" wartości z tablic lub właściwości z obiektów do oddzielnych zmiennych w bardzo zwięzły i czytelny sposób. Upraszcza kod i czyni go bardziej deklaratywnym.</p>\n<h3 id=\"destrukturyzacja-tablic\" class=\"scroll-mt-20 lg:scroll-mt-10\"><a class=\"mr-2 no-underline hover:underline focus-visible:underline select-none\" href=\"#destrukturyzacja-tablic\">>>></a>Destrukturyzacja tablic</h3>\n<p>Pozwala na szybkie przypisanie wartości z tablicy do zmiennych, bazując na ich pozycji.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> kolory = [<span class=\"hljs-string\">\"czerwony\"</span>, <span class=\"hljs-string\">\"zielony\"</span>, <span class=\"hljs-string\">\"niebieski\"</span>];\n\n<span class=\"hljs-comment\">// Stary sposób:</span>\n<span class=\"hljs-comment\">// const kolor1 = kolory[0];</span>\n<span class=\"hljs-comment\">// const kolor2 = kolory[1];</span>\n\n<span class=\"hljs-comment\">// Nowy sposób z destrukturyzacją tablic:</span>\n<span class=\"hljs-keyword\">const</span> [pierwszyKolor, drugiKolor, trzeciKolor] = kolory;\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(pierwszyKolor); <span class=\"hljs-comment\">// Wyświetli: czerwony</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(drugiKolor); <span class=\"hljs-comment\">// Wyświetli: zielony</span>\n\n<span class=\"hljs-comment\">// Można pomijać niektóre elementy (używając przecinków):</span>\n<span class=\"hljs-keyword\">const</span> [a, , b] = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]; <span class=\"hljs-comment\">// Pomijamy drugi element (2)</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a, b); <span class=\"hljs-comment\">// Wyświetli: 1 3</span>\n\n<span class=\"hljs-comment\">// Można przypisać wartości domyślne, jeśli element nie istnieje:</span>\n<span class=\"hljs-keyword\">const</span> [x, y, z = <span class=\"hljs-string\">\"domyślny\"</span>] = [<span class=\"hljs-string\">\"A\"</span>, <span class=\"hljs-string\">\"B\"</span>];\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(x, y, z); <span class=\"hljs-comment\">// Wyświetli: A B domyślny</span>\n\n<span class=\"hljs-comment\">// Można zbierać pozostałe elementy do nowej tablicy (rest operator - patrz dalej):</span>\n<span class=\"hljs-keyword\">const</span> [pierwszy, ...resztaKolorow] = kolory;\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(pierwszy); <span class=\"hljs-comment\">// Wyświetli: czerwony</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(resztaKolorow); <span class=\"hljs-comment\">// Wyświetli: [\"zielony\", \"niebieski\"]</span>\n</code></pre>\n<h3 id=\"destrukturyzacja-obiektów\" class=\"scroll-mt-20 lg:scroll-mt-10\"><a class=\"mr-2 no-underline hover:underline focus-visible:underline select-none\" href=\"#destrukturyzacja-obiektów\">>>></a>Destrukturyzacja obiektów</h3>\n<p>Pozwala na przypisanie wartości z obiektu do zmiennych na podstawie nazw ich <strong>kluczy (właściwości)</strong>. Kolejność nie ma znaczenia, liczy się nazwa klucza.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> samochod = { <span class=\"hljs-attr\">marka</span>: <span class=\"hljs-string\">\"Ford\"</span>, <span class=\"hljs-attr\">model</span>: <span class=\"hljs-string\">\"Focus\"</span>, <span class=\"hljs-attr\">rok</span>: <span class=\"hljs-number\">2018</span> };\n\n<span class=\"hljs-comment\">// Stary sposób:</span>\n<span class=\"hljs-comment\">// const markaSamochodu = samochod.marka;</span>\n<span class=\"hljs-comment\">// const modelSamochodu = samochod.model;</span>\n\n<span class=\"hljs-comment\">// Nowy sposób z destrukturyzacją obiektów:</span>\n<span class=\"hljs-keyword\">const</span> { marka, model } = samochod;\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(marka); <span class=\"hljs-comment\">// Wyświetli: Ford</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(model); <span class=\"hljs-comment\">// Wyświetli: Focus</span>\n\n<span class=\"hljs-comment\">// Można przypisać wartości domyślne, jeśli właściwość nie istnieje:</span>\n<span class=\"hljs-keyword\">const</span> { <span class=\"hljs-attr\">marka</span>: m, kolor = <span class=\"hljs-string\">\"czarny\"</span> } = samochod; <span class=\"hljs-comment\">// 'kolor' nie istnieje w obiekcie 'samochod'</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(m, kolor); <span class=\"hljs-comment\">// Wyświetli: Ford czarny</span>\n\n<span class=\"hljs-comment\">// Można zmienić nazwę zmiennej, do której przypisujemy wartość:</span>\n<span class=\"hljs-keyword\">const</span> { <span class=\"hljs-attr\">marka</span>: nazwaMarki, <span class=\"hljs-attr\">model</span>: typModelu } = samochod;\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(nazwaMarki, typModelu); <span class=\"hljs-comment\">// Wyświetli: Ford Focus</span>\n\n<span class=\"hljs-comment\">// Można też zbierać pozostałe właściwości do nowego obiektu (rest operator - patrz dalej):</span>\n<span class=\"hljs-keyword\">const</span> { rok, ...resztaSamochodu } = samochod;\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(rok); <span class=\"hljs-comment\">// Wyświetli: 2018</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(resztaSamochodu); <span class=\"hljs-comment\">// Wyświetli: { marka: \"Ford\", model: \"Focus\" }</span>\n</code></pre>\n<p>Destrukturyzacja jest szczególnie przydatna w funkcjach, gdy chcesz łatwo wyciągnąć konkretne dane z obiektów konfiguracyjnych lub z wyników API.</p>\n<hr>\n<h2 id=\"spread-i-rest-operator---elastyczność-w-manipulacji-danymi\" class=\"scroll-mt-20 lg:scroll-mt-10\"><a class=\"mr-2 no-underline hover:underline focus-visible:underline select-none\" href=\"#spread-i-rest-operator---elastyczność-w-manipulacji-danymi\">>></a>Spread i Rest Operator (<code>...</code>) – elastyczność w manipulacji danymi</h2>\n<p>Operator <code>...</code> (trzy kropki) jest jednym z najbardziej uniwersalnych i potężnych narzędzi w nowoczesnym JavaScript. Nazywany jest <strong>operatorem spread</strong> lub <strong>operatorem rest</strong>, w zależności od kontekstu, w jakim jest używany.</p>\n<h3 id=\"spread-operator-operator-rozproszenia\" class=\"scroll-mt-20 lg:scroll-mt-10\"><a class=\"mr-2 no-underline hover:underline focus-visible:underline select-none\" href=\"#spread-operator-operator-rozproszenia\">>>></a>Spread Operator (operator rozproszenia)</h3>\n<p>Gdy używasz <code>...</code> do <strong>rozbicia</strong> elementów tablicy lub właściwości obiektu na pojedyncze elementy, mówimy o <strong>operatorze spread</strong>. Jest to jak \"rozłożenie\" zawartości kolekcji. 🌐</p>\n<p><strong>Zastosowania Spread Operatora:</strong></p>\n<ul>\n<li>\n<p><strong>Kopiowanie i łączenie tablic:</strong> Tworzenie płytkich kopii tablic lub łączenie ich bez modyfikowania oryginalnych.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> cyfry = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];\n<span class=\"hljs-keyword\">const</span> noweCyfry = [...cyfry, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>]; <span class=\"hljs-comment\">// Rozwija [1, 2, 3] do 1, 2, 3, a potem dodaje 4, 5</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(noweCyfry); <span class=\"hljs-comment\">// Wyświetli: [1, 2, 3, 4, 5]</span>\n\n<span class=\"hljs-keyword\">const</span> tablica1 = [<span class=\"hljs-string\">\"a\"</span>, <span class=\"hljs-string\">\"b\"</span>];\n<span class=\"hljs-keyword\">const</span> tablica2 = [<span class=\"hljs-string\">\"c\"</span>, <span class=\"hljs-string\">\"d\"</span>];\n<span class=\"hljs-keyword\">const</span> polaczoneTablice = [...tablica1, ...tablica2];\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(polaczoneTablice); <span class=\"hljs-comment\">// Wyświetli: [\"a\", \"b\", \"c\", \"d\"]</span>\n</code></pre>\n</li>\n<li>\n<p><strong>Kopiowanie i łączenie obiektów:</strong> Podobnie jak z tablicami, możesz tworzyć kopie obiektów i łączyć ich właściwości.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> osoba = { <span class=\"hljs-attr\">imie</span>: <span class=\"hljs-string\">\"Anna\"</span>, <span class=\"hljs-attr\">wiek</span>: <span class=\"hljs-number\">28</span> };\n<span class=\"hljs-keyword\">const</span> osobaZZawodem = { ...osoba, <span class=\"hljs-attr\">zawod</span>: <span class=\"hljs-string\">\"Programista\"</span> };\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(osobaZZawodem); <span class=\"hljs-comment\">// Wyświetli: { imie: \"Anna\", wiek: 28, zawod: \"Programista\" }</span>\n\n<span class=\"hljs-keyword\">const</span> daneKontaktowe = { <span class=\"hljs-attr\">email</span>: <span class=\"hljs-string\">\"a@example.com\"</span>, <span class=\"hljs-attr\">telefon</span>: <span class=\"hljs-string\">\"123-456-789\"</span> };\n<span class=\"hljs-keyword\">const</span> pelneDane = { ...osoba, ...daneKontaktowe };\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(pelneDane); <span class=\"hljs-comment\">// Wyświetli: { imie: \"Anna\", wiek: 28, email: \"a@example.com\", telefon: \"123-456-789\" }</span>\n</code></pre>\n<p>Jeśli klucze się powtarzają, ostatnia wartość nadpisuje poprzednią.</p>\n</li>\n<li>\n<p><strong>Przekazywanie argumentów funkcji:</strong> Możesz rozwijać tablicę jako argumenty funkcji.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">sumuj</span>(<span class=\"hljs-params\">a, b, c</span>) {\n  <span class=\"hljs-keyword\">return</span> a + b + c;\n}\n<span class=\"hljs-keyword\">const</span> liczby = [<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">20</span>, <span class=\"hljs-number\">30</span>];\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">sumuj</span>(...liczby)); <span class=\"hljs-comment\">// Rozwija [10, 20, 30] do sumuj(10, 20, 30), wyświetli: 60</span>\n</code></pre>\n</li>\n</ul>\n<h3 id=\"rest-operator-operator-reszty\" class=\"scroll-mt-20 lg:scroll-mt-10\"><a class=\"mr-2 no-underline hover:underline focus-visible:underline select-none\" href=\"#rest-operator-operator-reszty\">>>></a>Rest Operator (operator reszty)</h3>\n<p>Gdy używasz <code>...</code> do <strong>zbierania</strong> wielu elementów w jedną tablicę (lub właściwości w obiekt), mówimy o <strong>operatorze rest</strong>. Jest to jak \"zbieranie\" luźnych elementów w jedną kolekcję. 🧺</p>\n<p><strong>Zastosowania Rest Operatora:</strong></p>\n<ul>\n<li>\n<p><strong>Zbieranie argumentów funkcji:</strong> Pozwala funkcji przyjmować nieokreśloną liczbę argumentów i traktować je jako tablicę.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">suma</span>(<span class=\"hljs-params\">...liczby</span>) {\n  <span class=\"hljs-comment\">// 'liczby' zbiera wszystkie przekazane argumenty w tablicę</span>\n  <span class=\"hljs-keyword\">return</span> liczby.<span class=\"hljs-title function_\">reduce</span>(\n    <span class=\"hljs-function\">(<span class=\"hljs-params\">akumulator, aktualnaLiczba</span>) =></span> akumulator + aktualnaLiczba,\n    <span class=\"hljs-number\">0</span>\n  );\n}\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">suma</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>)); <span class=\"hljs-comment\">// Wyświetli: 6</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">suma</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">20</span>, <span class=\"hljs-number\">30</span>, <span class=\"hljs-number\">40</span>)); <span class=\"hljs-comment\">// Wyświetli: 100</span>\n</code></pre>\n</li>\n<li>\n<p><strong>W destrukturyzacji (jak widzieliśmy wcześniej):</strong> Zbieranie pozostałych elementów do nowej tablicy lub obiektu.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> [pierwszy, drugi, ...resztaTablicy] = [<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">20</span>, <span class=\"hljs-number\">30</span>, <span class=\"hljs-number\">40</span>, <span class=\"hljs-number\">50</span>];\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(pierwszy); <span class=\"hljs-comment\">// Wyświetli: 10</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(drugi); <span class=\"hljs-comment\">// Wyświetli: 20</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(resztaTablicy); <span class=\"hljs-comment\">// Wyświetli: [30, 40, 50]</span>\n\n<span class=\"hljs-keyword\">const</span> { imie, ...resztaOsoby } = {\n  <span class=\"hljs-attr\">imie</span>: <span class=\"hljs-string\">\"Ola\"</span>,\n  <span class=\"hljs-attr\">wiek</span>: <span class=\"hljs-number\">25</span>,\n  <span class=\"hljs-attr\">miasto</span>: <span class=\"hljs-string\">\"Warszawa\"</span>,\n};\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(imie); <span class=\"hljs-comment\">// Wyświetli: Ola</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(resztaOsoby); <span class=\"hljs-comment\">// Wyświetli: { wiek: 25, miasto: \"Warszawa\" }</span>\n</code></pre>\n</li>\n</ul>\n<p>Zarówno spread, jak i rest operator są niezwykle przydatne i sprawiają, że kod jest znacznie bardziej zwięzły i czytelny, szczególnie podczas pracy z tablicami i obiektami.</p>\n<hr>\n<h2 id=\"promise-api-i-obsługa-asynchroniczności--opowiadaj-historie-o-przyszłości\" class=\"scroll-mt-20 lg:scroll-mt-10\"><a class=\"mr-2 no-underline hover:underline focus-visible:underline select-none\" href=\"#promise-api-i-obsługa-asynchroniczności--opowiadaj-historie-o-przyszłości\">>></a>Promise API i obsługa asynchroniczności – opowiadaj historie o przyszłości</h2>\n<p>JavaScript jest językiem <strong>jednowątkowym</strong>, co oznacza, że może wykonywać tylko jedną operację w danym momencie. Jednak wiele operacji, takich jak pobieranie danych z internetu, odczyt plików, czy operacje na bazie danych, trwa pewien czas. Gdyby JavaScript musiał czekać na ich zakończenie, strona internetowa by się \"zawiesiła\" (nie reagowałaby na kliknięcia, przewijanie itp.).</p>\n<p>Tutaj wkracza <strong>asynchroniczność</strong>. Pozwala ona na rozpoczęcie operacji, a następnie przejście do kolejnych zadań, nie czekając na zakończenie tej pierwszej. Kiedy asynchroniczna operacja się zakończy, JavaScript wróci do niej i wykona dalsze kroki.</p>\n<p>Starszym sposobem obsługi asynchroniczności były <strong>callbacki</strong> (funkcje zwrotne), które jednak często prowadziły do tzw. \"callback hell\" (piekła callbacków) – zagnieżdżonego, trudnego do czytania i utrzymania kodu.</p>\n<h3 id=\"czym-jest-promise\" class=\"scroll-mt-20 lg:scroll-mt-10\"><a class=\"mr-2 no-underline hover:underline focus-visible:underline select-none\" href=\"#czym-jest-promise\">>>></a>Czym jest Promise?</h3>\n<p><strong>Promise (Obietnica)</strong> to obiekt w JavaScript, który reprezentuje ostateczne zakończenie (lub niepowodzenie) operacji asynchronicznej. Możesz myśleć o Promise jako o \"przyszłej wartości\". Składasz obietnicę, że w przyszłości otrzymasz wynik – albo sukces, albo błąd. 📦</p>\n<p>Promise może znajdować się w jednym z trzech stanów:</p>\n<ol>\n<li><strong><code>pending</code> (oczekujący)</strong>: Początkowy stan; ani spełniony, ani odrzucony. Operacja asynchroniczna nadal trwa.</li>\n<li><strong><code>fulfilled</code> (spełniony)</strong>: Operacja asynchroniczna zakończyła się sukcesem i zwróciła wartość.</li>\n<li><strong><code>rejected</code> (odrzucony)</strong>: Operacja asynchroniczna zakończyła się błędem.</li>\n</ol>\n<p>Możesz \"podpiąć\" funkcje, które zostaną wywołane, gdy Promise zmieni swój stan:</p>\n<ul>\n<li><strong><code>.then()</code></strong>: Wywoływany, gdy Promise zostanie <code>fulfilled</code> (operacja zakończy się sukcesem). Otrzymuje wartość zwróconą przez Promise.</li>\n<li><strong><code>.catch()</code></strong>: Wywoływany, gdy Promise zostanie <code>rejected</code> (wystąpi błąd). Otrzymuje obiekt błędu.</li>\n<li><strong><code>.finally()</code></strong>: Wywoływany zawsze, niezależnie od tego, czy Promise zakończył się sukcesem, czy błędem. Idealny do czyszczenia zasobów.</li>\n</ul>\n<p><strong>Przykład tworzenia i używania Promise:</strong></p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> obietnica = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =></span> {\n  <span class=\"hljs-comment\">// Symulujemy operację asynchroniczną (np. pobieranie danych)</span>\n  <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =></span> {\n    <span class=\"hljs-keyword\">const</span> sukces = <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">random</span>() > <span class=\"hljs-number\">0.5</span>; <span class=\"hljs-comment\">// Losowo decydujemy o sukcesie lub błędzie</span>\n\n    <span class=\"hljs-keyword\">if</span> (sukces) {\n      <span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-string\">\"Dane pobrane pomyślnie!\"</span>); <span class=\"hljs-comment\">// Jeśli sukces, wywołujemy resolve z wynikiem</span>\n    } <span class=\"hljs-keyword\">else</span> {\n      <span class=\"hljs-title function_\">reject</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">\"Nie udało się pobrać danych.\"</span>)); <span class=\"hljs-comment\">// Jeśli błąd, wywołujemy reject z błędem</span>\n    }\n  }, <span class=\"hljs-number\">2000</span>); <span class=\"hljs-comment\">// Operacja trwa 2 sekundy</span>\n});\n\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"Rozpoczęto operację...\"</span>);\n\nobietnica\n  .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">wiadomosc</span>) =></span> {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"SUKCES:\"</span>, wiadomosc); <span class=\"hljs-comment\">// Wykona się, jeśli obietnica się spełni</span>\n  })\n  .<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">blad</span>) =></span> {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">\"BŁĄD:\"</span>, blad.<span class=\"hljs-property\">message</span>); <span class=\"hljs-comment\">// Wykona się, jeśli obietnica zostanie odrzucona</span>\n  })\n  .<span class=\"hljs-title function_\">finally</span>(<span class=\"hljs-function\">() =></span> {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"Operacja zakończona (niezależnie od wyniku).\"</span>); <span class=\"hljs-comment\">// Wykona się zawsze</span>\n  });\n\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"Kod po obietnicy nadal się wykonuje...\"</span>); <span class=\"hljs-comment\">// Pokazuje asynchroniczność</span>\n</code></pre>\n<h3 id=\"łańcuchy-promise-promise-chaining\" class=\"scroll-mt-20 lg:scroll-mt-10\"><a class=\"mr-2 no-underline hover:underline focus-visible:underline select-none\" href=\"#łańcuchy-promise-promise-chaining\">>>></a>Łańcuchy Promise (<code>Promise Chaining</code>)</h3>\n<p>Jedną z największych zalet Promise jest możliwość łączenia wielu operacji asynchronicznych w jeden czytelny \"łańcuch\". Każdy <code>.then()</code> zwraca nowy Promise, co pozwala na kolejne <code>.then()</code> wywołane po sobie. Jest to idealne, gdy jedna operacja asynchroniczna zależy od wyniku poprzedniej.</p>\n<p><strong>Przykład łańcucha Promise (pobieranie danych z API):</strong></p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-comment\">// fetch() to wbudowana funkcja JS, która zwraca Promise</span>\n<span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">\"https://jsonplaceholder.typicode.com/users/1\"</span>) <span class=\"hljs-comment\">// Pobierz dane użytkownika o ID 1</span>\n  .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">response</span>) =></span> {\n    <span class=\"hljs-comment\">// Pierwsze .then: sprawdź, czy odpowiedź jest OK i sparsuj ją jako JSON</span>\n    <span class=\"hljs-keyword\">if</span> (!response.<span class=\"hljs-property\">ok</span>) {\n      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">`Błąd HTTP! Status: <span class=\"hljs-subst\">${response.status}</span>`</span>);\n    }\n    <span class=\"hljs-keyword\">return</span> response.<span class=\"hljs-title function_\">json</span>(); <span class=\"hljs-comment\">// Zwróć kolejny Promise z danymi JSON</span>\n  })\n  .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">user</span>) =></span> {\n    <span class=\"hljs-comment\">// Drugie .then: otrzymaj sparsowane dane użytkownika</span>\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"Pobrany użytkownik:\"</span>, user.<span class=\"hljs-property\">name</span>, user.<span class=\"hljs-property\">email</span>);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">fetch</span>(\n      <span class=\"hljs-string\">`https://jsonplaceholder.typicode.com/posts?userId=<span class=\"hljs-subst\">${user.id}</span>`</span>\n    ); <span class=\"hljs-comment\">// Pobierz posty tego użytkownika</span>\n  })\n  .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">response</span>) =></span> {\n    <span class=\"hljs-comment\">// Trzecie .then: sprawdź odpowiedź i sparsuj posty</span>\n    <span class=\"hljs-keyword\">if</span> (!response.<span class=\"hljs-property\">ok</span>) {\n      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">`Błąd HTTP! Status: <span class=\"hljs-subst\">${response.status}</span>`</span>);\n    }\n    <span class=\"hljs-keyword\">return</span> response.<span class=\"hljs-title function_\">json</span>();\n  })\n  .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">posts</span>) =></span> {\n    <span class=\"hljs-comment\">// Czwarte .then: otrzymaj posty</span>\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"Liczba postów użytkownika:\"</span>, posts.<span class=\"hljs-property\">length</span>);\n  })\n  .<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">error</span>) =></span> {\n    <span class=\"hljs-comment\">// .catch: Obsłuż każdy błąd, który wystąpił na dowolnym etapie łańcucha</span>\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">\"Wystąpił błąd w łańcuchu Promise:\"</span>, error);\n  })\n  .<span class=\"hljs-title function_\">finally</span>(<span class=\"hljs-function\">() =></span> {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"Pobieranie danych zakończone.\"</span>);\n  });\n</code></pre>\n<p>Promise to podstawa nowoczesnego JS w obsłudze asynchroniczności, a kolejny rozdział pokaże Ci, jak jeszcze bardziej uprościć ich użycie.</p>\n<hr>\n<h2 id=\"asyncawait--nowoczesna-obsługa-kodu-asynchronicznego--pisz-asynchronicznie-myśl-synchronicznie\" class=\"scroll-mt-20 lg:scroll-mt-10\"><a class=\"mr-2 no-underline hover:underline focus-visible:underline select-none\" href=\"#asyncawait--nowoczesna-obsługa-kodu-asynchronicznego--pisz-asynchronicznie-myśl-synchronicznie\">>></a>Async/await – nowoczesna obsługa kodu asynchronicznego – pisz asynchronicznie, myśl synchronicznie</h2>\n<p>Mimo że Promise są ogromnym krokiem naprzód w porównaniu do callbacków, kod z długimi łańcuchami <code>.then().then().catch()</code> może wciąż być trudny do czytania. Standard ES2017 wprowadził słowa kluczowe <strong><code>async</code></strong> i <strong><code>await</code></strong>, które pozwalają pisać kod asynchroniczny w sposób, który wygląda i zachowuje się niemal identycznie jak kod synchroniczny, jednocześnie zachowując asynchroniczną naturę. To game changer! 🎮</p>\n<h3 id=\"uproszczenie-pracy-z-promise\" class=\"scroll-mt-20 lg:scroll-mt-10\"><a class=\"mr-2 no-underline hover:underline focus-visible:underline select-none\" href=\"#uproszczenie-pracy-z-promise\">>>></a>Uproszczenie pracy z Promise</h3>\n<ul>\n<li><strong><code>async</code></strong>: Musisz oznaczyć funkcję słowem kluczowym <code>async</code>, aby móc używać w niej <code>await</code>. Funkcja <code>async</code> <strong>zawsze zwraca Promise</strong>, nawet jeśli zwrócisz w niej zwykłą wartość – JavaScript automatycznie opakuje ją w Promise.</li>\n<li><strong><code>await</code></strong>: Słowo kluczowe <code>await</code> może być użyte <strong>tylko wewnątrz funkcji <code>async</code></strong>. Powoduje ono, że wykonanie funkcji <code>async</code> zostaje <strong>wstrzymane</strong>, dopóki Promise, na który czeka <code>await</code>, nie zostanie <strong>spełniony (fulfilled)</strong>. Kiedy Promise się spełni, <code>await</code> \"rozpakowuje\" jego wartość i przypisuje ją do zmiennej. Jeśli Promise zostanie odrzucony (rejected), <code>await</code> \"wyrzuci\" błąd, który możesz obsłużyć za pomocą <code>try...catch</code>.</li>\n</ul>\n<p><strong>Przykład użycia <code>async/await</code> (porównaj z przykładem z Promise Chaining):</strong></p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">pobierzDaneUzytkownikaIPosty</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">try</span> {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"Rozpoczynam pobieranie danych...\"</span>);\n\n    <span class=\"hljs-comment\">// Krok 1: Pobierz dane użytkownika</span>\n    <span class=\"hljs-keyword\">const</span> userResponse = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetch</span>(\n      <span class=\"hljs-string\">\"https://jsonplaceholder.typicode.com/users/1\"</span>\n    );\n    <span class=\"hljs-keyword\">if</span> (!userResponse.<span class=\"hljs-property\">ok</span>) {\n      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(\n        <span class=\"hljs-string\">`Błąd HTTP przy pobieraniu użytkownika! Status: <span class=\"hljs-subst\">${userResponse.status}</span>`</span>\n      );\n    }\n    <span class=\"hljs-keyword\">const</span> user = <span class=\"hljs-keyword\">await</span> userResponse.<span class=\"hljs-title function_\">json</span>(); <span class=\"hljs-comment\">// Poczekaj na parsowanie JSON</span>\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"Pobrany użytkownik:\"</span>, user.<span class=\"hljs-property\">name</span>, user.<span class=\"hljs-property\">email</span>);\n\n    <span class=\"hljs-comment\">// Krok 2: Pobierz posty tego użytkownika</span>\n    <span class=\"hljs-keyword\">const</span> postsResponse = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetch</span>(\n      <span class=\"hljs-string\">`https://jsonplaceholder.typicode.com/posts?userId=<span class=\"hljs-subst\">${user.id}</span>`</span>\n    );\n    <span class=\"hljs-keyword\">if</span> (!postsResponse.<span class=\"hljs-property\">ok</span>) {\n      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(\n        <span class=\"hljs-string\">`Błąd HTTP przy pobieraniu postów! Status: <span class=\"hljs-subst\">${postsResponse.status}</span>`</span>\n      );\n    }\n    <span class=\"hljs-keyword\">const</span> posts = <span class=\"hljs-keyword\">await</span> postsResponse.<span class=\"hljs-title function_\">json</span>(); <span class=\"hljs-comment\">// Poczekaj na parsowanie JSON</span>\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"Liczba postów użytkownika:\"</span>, posts.<span class=\"hljs-property\">length</span>);\n\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"Wszystkie dane zostały pobrane pomyślnie.\"</span>);\n  } <span class=\"hljs-keyword\">catch</span> (error) {\n    <span class=\"hljs-comment\">// Obsługa każdego błędu, który wystąpił na dowolnym etapie</span>\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">\"Wystąpił błąd w funkcji async:\"</span>, error.<span class=\"hljs-property\">message</span>);\n  } <span class=\"hljs-keyword\">finally</span> {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"Operacja pobierania danych zakończona.\"</span>);\n  }\n}\n\n<span class=\"hljs-comment\">// Wywołanie funkcji async</span>\n<span class=\"hljs-title function_\">pobierzDaneUzytkownikaIPosty</span>();\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"Kod poza funkcją async nadal się wykonuje...\"</span>); <span class=\"hljs-comment\">// Pokazuje asynchroniczność</span>\n</code></pre>\n<p>Widzisz, jak kod stał się znacznie bardziej liniowy i czytelny? Wygląda to prawie jak tradycyjny kod synchroniczny, mimo że w tle nadal działają Promise i cała magia asynchroniczności.</p>\n<h3 id=\"zwracanie-wartości-i-obsługa-błędów\" class=\"scroll-mt-20 lg:scroll-mt-10\"><a class=\"mr-2 no-underline hover:underline focus-visible:underline select-none\" href=\"#zwracanie-wartości-i-obsługa-błędów\">>>></a>Zwracanie wartości i obsługa błędów</h3>\n<ul>\n<li>\n<p><strong>Zwracanie wartości z funkcji <code>async</code></strong>:\nJeśli funkcja <code>async</code> zwraca jakąś wartość, ta wartość jest automatycznie opakowywana w Promise, który zostanie spełniony z tą wartością.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">zwrocLiczbe</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-comment\">// Możesz też użyć await, np. await Promise.resolve(42);</span>\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">42</span>;\n}\n<span class=\"hljs-title function_\">zwrocLiczbe</span>().<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">val</span>) =></span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(val)); <span class=\"hljs-comment\">// Wyświetli: 42</span>\n</code></pre>\n</li>\n<li>\n<p><strong>Obsługa błędów z <code>try...catch</code></strong>:\nNajwiększą zaletą <code>async/await</code> jest to, że pozwala na używanie standardowych bloków <code>try...catch</code> do obsługi błędów w kodzie asynchronicznym. Jeśli Promise, na który czeka <code>await</code>, zostanie odrzucony (rejected), <code>await</code> \"rzuci\" błąd, który zostanie przechwycony przez blok <code>catch</code>.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">symulujBlad</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">try</span> {\n    <span class=\"hljs-keyword\">const</span> result = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =></span> {\n      <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =></span> <span class=\"hljs-title function_\">reject</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">\"Coś poszło nie tak!\"</span>)), <span class=\"hljs-number\">1000</span>);\n    });\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(result); <span class=\"hljs-comment\">// To się nie wykona</span>\n  } <span class=\"hljs-keyword\">catch</span> (error) {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">\"Złapano błąd:\"</span>, error.<span class=\"hljs-property\">message</span>); <span class=\"hljs-comment\">// Wyświetli: Złapano błąd: Coś poszło nie tak!</span>\n  }\n}\n<span class=\"hljs-title function_\">symulujBlad</span>();\n</code></pre>\n</li>\n</ul>\n<p><code>async/await</code> to obecnie <strong>najczęściej rekomendowany</strong> sposób pracy z asynchronicznością w JavaScript, ponieważ znacząco poprawia czytelność i łatwość utrzymania kodu, sprawiając, że złożone operacje asynchroniczne stają się bardziej przejrzyste.</p>\n<hr>\n<h2 id=\"zadania-do-wykonania-sprawdź-swoją-wiedzę\" class=\"scroll-mt-20 lg:scroll-mt-10\"><a class=\"mr-2 no-underline hover:underline focus-visible:underline select-none\" href=\"#zadania-do-wykonania-sprawdź-swoją-wiedzę\">>></a>Zadania do wykonania: Sprawdź swoją wiedzę!</h2>\n<p>Czas na praktykę! Rozwiąż te zadania, aby utrwalić to, czego się nauczyłeś/aś. Po każdym zadaniu możesz rozwinąć sekcję <code>Pokaż rozwiązanie</code>, aby sprawdzić swój kod. Powodzenia! 💪</p>\n<h3 id=\"zadanie-1\" class=\"scroll-mt-20 lg:scroll-mt-10\"><a class=\"mr-2 no-underline hover:underline focus-visible:underline select-none\" href=\"#zadanie-1\">>>></a>Zadanie 1</h3>\n<p>Napisz <strong>funkcję strzałkową</strong>, która przyjmuje dowolną liczbę argumentów numerycznych i zwraca ich sumę. Użyj <strong>rest operatora</strong> do zebrania argumentów.</p>\n<details>\n<summary>\n<span>Pokaż rozwiązanie</span>\n</summary>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">sumaWszystkichLiczb</span> = (<span class=\"hljs-params\">...liczby</span>) => {\n  <span class=\"hljs-keyword\">return</span> liczby.<span class=\"hljs-title function_\">reduce</span>(\n    <span class=\"hljs-function\">(<span class=\"hljs-params\">akumulator, aktualnaLiczba</span>) =></span> akumulator + aktualnaLiczba,\n    <span class=\"hljs-number\">0</span>\n  );\n};\n\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">sumaWszystkichLiczb</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>)); <span class=\"hljs-comment\">// Oczekiwany wynik: 6</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">sumaWszystkichLiczb</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">20</span>, <span class=\"hljs-number\">30</span>, <span class=\"hljs-number\">40</span>)); <span class=\"hljs-comment\">// Oczekiwany wynik: 100</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">sumaWszystkichLiczb</span>()); <span class=\"hljs-comment\">// Oczekiwany wynik: 0</span>\n</code></pre>\n</details>\n<hr>\n<h3 id=\"zadanie-2\" class=\"scroll-mt-20 lg:scroll-mt-10\"><a class=\"mr-2 no-underline hover:underline focus-visible:underline select-none\" href=\"#zadanie-2\">>>></a>Zadanie 2</h3>\n<p>Utwórz obiekt reprezentujący produkt z kluczami: <code>nazwa</code>, <code>cena</code>, <code>dostepny</code>. Następnie użyj <strong>destrukturyzacji obiektu</strong>, aby wyodrębnić te wartości do osobnych zmiennych i wyświetlić je w konsoli. Dodaj również zmienną <code>producent</code> z wartością domyślną \"Nieznany\", na wypadek gdyby nie było jej w obiekcie.</p>\n<details>\n<summary>\n<span>Pokaż rozwiązanie</span>\n</summary>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> produkt = { <span class=\"hljs-attr\">nazwa</span>: <span class=\"hljs-string\">\"Książka JS\"</span>, <span class=\"hljs-attr\">cena</span>: <span class=\"hljs-number\">49.99</span>, <span class=\"hljs-attr\">dostepny</span>: <span class=\"hljs-literal\">true</span> };\n\n<span class=\"hljs-keyword\">const</span> { nazwa, cena, dostepny, producent = <span class=\"hljs-string\">\"Nieznany\"</span> } = produkt;\n\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`Nazwa: <span class=\"hljs-subst\">${nazwa}</span>`</span>); <span class=\"hljs-comment\">// Oczekiwany wynik: Nazwa: Książka JS</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`Cena: <span class=\"hljs-subst\">${cena}</span> zł`</span>); <span class=\"hljs-comment\">// Oczekiwany wynik: Cena: 49.99 zł</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`Dostępny: <span class=\"hljs-subst\">${dostepny}</span>`</span>); <span class=\"hljs-comment\">// Oczekiwany wynik: Dostępny: true</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`Producent: <span class=\"hljs-subst\">${producent}</span>`</span>); <span class=\"hljs-comment\">// Oczekiwany wynik: Producent: Nieznany</span>\n</code></pre>\n</details>\n<hr>\n<h3 id=\"zadanie-3\" class=\"scroll-mt-20 lg:scroll-mt-10\"><a class=\"mr-2 no-underline hover:underline focus-visible:underline select-none\" href=\"#zadanie-3\">>>></a>Zadanie 3</h3>\n<p>Stwórz tablicę ulubionych filmów. Następnie użyj <strong>operatora spread</strong> do utworzenia nowej tablicy, która będzie zawierać wszystkie te filmy plus dwa dodatkowe filmy na końcu. Wyświetl nową tablicę w konsoli.</p>\n<details>\n<summary>\n<span>Pokaż rozwiązanie</span>\n</summary>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> ulubioneFilmy = [<span class=\"hljs-string\">\"Incepcja\"</span>, <span class=\"hljs-string\">\"Matrix\"</span>, <span class=\"hljs-string\">\"Interstellar\"</span>];\n\n<span class=\"hljs-keyword\">const</span> nowaListaFilmow = [...ulubioneFilmy, <span class=\"hljs-string\">\"Pulp Fiction\"</span>, <span class=\"hljs-string\">\"Forrest Gump\"</span>];\n\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(nowaListaFilmow);\n<span class=\"hljs-comment\">// Oczekiwany wynik: [\"Incepcja\", \"Matrix\", \"Interstellar\", \"Pulp Fiction\", \"Forrest Gump\"]</span>\n</code></pre>\n</details>\n<hr>\n<h3 id=\"zadanie-4\" class=\"scroll-mt-20 lg:scroll-mt-10\"><a class=\"mr-2 no-underline hover:underline focus-visible:underline select-none\" href=\"#zadanie-4\">>>></a>Zadanie 4</h3>\n<p>Napisz <strong>funkcję asynchroniczną</strong> o nazwie <code>pobierzWiadomosc</code>, która symuluje pobieranie wiadomości z serwera. Funkcja powinna używać <code>setTimeout</code>, aby po 3 sekundach zwrócić tekst \"Wiadomość pobrana!\". Użyj <code>async/await</code> do wywołania tej funkcji i wyświetlenia jej wyniku w konsoli. Dodaj również blok <code>try...catch</code> do obsługi potencjalnych błędów.</p>\n<details>\n<summary>\n<span>Pokaż rozwiązanie</span>\n</summary>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-comment\">// Funkcja symulująca pobieranie danych (zwraca Promise)</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">pobierzWiadomoscAPI</span> = (<span class=\"hljs-params\"></span>) => {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =></span> {\n    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =></span> {\n      <span class=\"hljs-comment\">// Możesz zmienić to na reject, aby przetestować obsługę błędów</span>\n      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">random</span>() > <span class=\"hljs-number\">0.1</span>) {\n        <span class=\"hljs-comment\">// 90% szans na sukces, 10% na błąd</span>\n        <span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-string\">\"Wiadomość pobrana pomyślnie!\"</span>);\n      } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-title function_\">reject</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">\"Błąd podczas pobierania wiadomości!\"</span>));\n      }\n    }, <span class=\"hljs-number\">3000</span>); <span class=\"hljs-comment\">// Symulujemy 3 sekundy oczekiwania</span>\n  });\n};\n\n<span class=\"hljs-comment\">// Funkcja asynchroniczna używająca async/await</span>\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">pobierzWiadomosc</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"Rozpoczynam pobieranie wiadomości...\"</span>);\n  <span class=\"hljs-keyword\">try</span> {\n    <span class=\"hljs-keyword\">const</span> wiadomosc = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">pobierzWiadomoscAPI</span>(); <span class=\"hljs-comment\">// Czekaj, aż Promise się spełni</span>\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"Sukces:\"</span>, wiadomosc);\n  } <span class=\"hljs-keyword\">catch</span> (error) {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">\"Wystąpił błąd:\"</span>, error.<span class=\"hljs-property\">message</span>); <span class=\"hljs-comment\">// Złap i wyświetl błąd</span>\n  } <span class=\"hljs-keyword\">finally</span> {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"Zakończono próbę pobierania wiadomości.\"</span>);\n  }\n}\n\n<span class=\"hljs-comment\">// Wywołaj funkcję asynchroniczną</span>\n<span class=\"hljs-title function_\">pobierzWiadomosc</span>();\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(\n  <span class=\"hljs-string\">\"Ten tekst wyświetli się natychmiast po uruchomieniu programu, zanim wiadomość zostanie pobrana.\"</span>\n);\n</code></pre>\n</details>\n<hr>\n<p>Gratulacje! 🎉 Dotarłeś/aś do końca kursu wprowadzającego w nowoczesny JavaScript. Masz teraz solidne podstawy do dalszego rozwoju. Pamiętaj, że kluczem jest praktyka – im więcej będziesz kodować, tym lepiej zrozumiesz te koncepcje.</p>\n<p>Co chciałbyś/chciałabyś zgłębić dalej? Może:</p>\n<ul>\n<li><strong>Moduły ES6</strong> (import/export)?</li>\n<li><strong>Klasy</strong> w JavaScript (obiektowość)?</li>\n<li><strong>Metody tablicowe</strong> (map, filter, reduce)?</li>\n<li>Głębsze nurkowanie w <strong>asynchroniczność</strong> i Web API?</li>\n</ul>\n<p>Daj znać! 😊</p>","resourceUrl","/app/content/courses/nowoczesny-javascript.md","readingTime","18 minut"]
