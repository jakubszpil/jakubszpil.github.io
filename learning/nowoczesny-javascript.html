<!DOCTYPE html><html lang="pl"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="modulepreload" href="/fetch.js"/><link rel="icon" href="/favicon.svg" sizes="any" type="image/svg+xml"/><link rel="preload" as="style" href="/assets/styles-CsCoTtlD.css"/><link rel="preload prefetch" href="/fonts/geist.ttf" as="font" type="font/ttf" crossorigin="anonymous"/><title>Renesans w JS, czyli nowoczesny JavaScript - Jakub Szpil</title><meta name="description" content="JavaScript jest językiem programowania, który jest powszechnie stosowany do tworzenia dynamicznych i interaktywnych stron internetowych. W ciągu ostatnich lat JavaScript znacznie ewoluował, wprowadzając nowe funkcje i poprawiając istniejące mechanizmy. W tym kursie omówimy najważniejsze elementy nowoczesnego JavaScript, w tym ES6 i nowsze."/><meta name="keywords" content="javascript,kurs,wprowadzenie,przewodnik,web,frontend,learning"/><meta property="article:published_time" content="2024-06-30T00:00:00.000Z"/><meta property="og:type" content="article"/><meta property="og:url" content="https://jakubszpil.github.io/learning/nowoczesny-javascript/"/><meta property="og:title" content="Renesans w JS, czyli nowoczesny JavaScript - Jakub Szpil"/><meta property="og:description" content="JavaScript jest językiem programowania, który jest powszechnie stosowany do tworzenia dynamicznych i interaktywnych stron internetowych. W ciągu ostatnich lat JavaScript znacznie ewoluował, wprowadzając nowe funkcje i poprawiając istniejące mechanizmy. W tym kursie omówimy najważniejsze elementy nowoczesnego JavaScript, w tym ES6 i nowsze."/><meta property="twitter:card" content="summary_large_image"/><meta property="twitter:url" content="https://jakubszpil.github.io/learning/nowoczesny-javascript/"/><meta property="twitter:title" content="Renesans w JS, czyli nowoczesny JavaScript - Jakub Szpil"/><meta property="twitter:description" content="JavaScript jest językiem programowania, który jest powszechnie stosowany do tworzenia dynamicznych i interaktywnych stron internetowych. W ciągu ostatnich lat JavaScript znacznie ewoluował, wprowadzając nowe funkcje i poprawiając istniejące mechanizmy. W tym kursie omówimy najważniejsze elementy nowoczesnego JavaScript, w tym ES6 i nowsze."/><link rel="modulepreload" href="/assets/manifest-e0891c5e.js"/><link rel="modulepreload" href="/assets/entry.client-D07Jc1yP.js"/><link rel="modulepreload" href="/assets/jsx-runtime-D_zvdyIk.js"/><link rel="modulepreload" href="/assets/chunk-OIYGIGL5-Rdhby1S0.js"/><link rel="modulepreload" href="/assets/index-DJQXGD61.js"/><link rel="modulepreload" href="/assets/root-4AKZROQ4.js"/><link rel="modulepreload" href="/assets/layout-dMgoSrpG.js"/><link rel="modulepreload" href="/assets/button-BMGgmMxT.js"/><link rel="modulepreload" href="/assets/link-with-prefetch-BIs6hVLd.js"/><link rel="modulepreload" href="/assets/icons-BBGQWBin.js"/><link rel="modulepreload" href="/assets/socials-DGthjeXP.js"/><link rel="modulepreload" href="/assets/date-NK96Yl5Q.js"/><link rel="modulepreload" href="/assets/not-found-CGoFJWhv.js"/><link rel="modulepreload" href="/assets/seo-Do91G143.js"/><link rel="modulepreload" href="/assets/course-details-DLJ6fZBl.js"/><link rel="modulepreload" href="/assets/categories-BBucIGjV.js"/><link rel="modulepreload" href="/assets/edit-resource-Bp0MeTOm.js"/><link rel="modulepreload" href="/assets/banner-DCe0eTPI.js"/><link rel="modulepreload" href="/assets/compress-C_V_4BTm.js"/><link rel="modulepreload" href="/assets/creation-date-x1jkwlYO.js"/><link rel="stylesheet" href="/assets/styles-CsCoTtlD.css"/><script>globalThis.timestamp=1761162824356</script><script>let k="theme";let t="dark";let s=localStorage;let c=document.documentElement.classList;let v=s.getItem(k);if(v===null||v==="SYSTEM")matchMedia("(prefers-color-scheme:dark)").matches?c.add(t):c.remove(t);else if(v==="DARK")c.add(t);else if(v==="LIGHT")c.remove(t);else s.removeItem(k);</script><script type="module" src="/fetch.js"></script></head><body style="-webkit-tap-highlight-color:transparent"><header class="sticky w-full bg-background top-0 left-0 z-50 border-b"><div class="container pb-3! pt-4! px-3! flex justify-between items-center"><a data-slot="button" class="button button--variant-ghost button--size-sm font-bold" href="/" data-discover="true">jakubszpil</a><div class="flex flex-1 justify-end items-center sm:gap-1"><nav class="hidden items-center lg:flex"><a data-slot="button" class="button button--variant-ghost button--size-sm" href="/" data-discover="true">🏠 Strona główna</a><a data-slot="button" class="button button--variant-ghost button--size-sm" href="/blog" data-discover="true">📝 Blog</a><a data-slot="button" class="button button--variant-ghost button--size-sm" href="/learning" data-discover="true">🏫 Learning</a><a data-slot="button" class="button button--variant-ghost button--size-sm" href="/portfolio" data-discover="true">🛠️ Portfolio</a><a data-slot="button" class="button button--variant-ghost button--size-sm" href="/me" data-discover="true">🙋‍♂️ O mnie</a></nav><a data-slot="button" class="button button--variant-ghost button--size-icon inline-flex items-center justify-center" aria-label="Szukaj" title="Szukaj (CTRL+K)" href="/search" data-discover="true"><span class="sr-only">Szukaj</span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="size-6"><path d="M10 10m-7 0a7 7 0 1 0 14 0a7 7 0 1 0 -14 0"></path><path d="M21 21l-6 -6"></path></svg></a><div class="hidden xs:flex items-center sm:gap-1"><a href="https://www.linkedin.com/in/jakubszpil/" target="_blank" rel="noreferrer" data-slot="button" class="button button--variant-ghost button--size-icon inline-flex items-center gap-1 no-underline" title="LinkedIn" aria-label="LinkedIn"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="size-6"><path d="M8 11v5"></path><path d="M8 8v.01"></path><path d="M12 16v-5"></path><path d="M16 16v-3a2 2 0 1 0 -4 0"></path><path d="M3 7a4 4 0 0 1 4 -4h10a4 4 0 0 1 4 4v10a4 4 0 0 1 -4 4h-10a4 4 0 0 1 -4 -4z"></path></svg><span class="sr-only">LinkedIn</span></a><a href="https://github.com/jakubszpil/" target="_blank" rel="noreferrer" data-slot="button" class="button button--variant-ghost button--size-icon inline-flex items-center gap-1 no-underline" title="GitHub" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="size-6"><path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5"></path></svg><span class="sr-only">GitHub</span></a></div><button data-slot="dropdown-menu-trigger" class="button button--variant-ghost button--size-icon cursor-pointer" title="Zmień motyw" type="button" id="radix-_R_4ej5_" aria-haspopup="menu" aria-expanded="false" data-state="closed"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="size-6"><path d="M9.173 14.83a4 4 0 1 1 5.657 -5.657"></path><path d="M11.294 12.707l.174 .247a7.5 7.5 0 0 0 8.845 2.492a9 9 0 0 1 -14.671 2.914"></path><path d="M3 12h1"></path><path d="M12 3v1"></path><path d="M5.6 5.6l.7 .7"></path><path d="M3 21l18 -18"></path></svg></button><button data-slot="button" class="button button--variant-link button--size-icon inline-flex items-center justify-center relative z-50 lg:hidden" aria-label="Otwórz menu"><span class="sr-only">Otwórz menu</span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="size-6 text-black! dark:text-white!"><path d="M4 6l16 0"></path><path d="M4 12l16 0"></path><path d="M4 18l16 0"></path></svg></button></div></div></header><main><header class="prose container"><h1 class="mb-5">Renesans w JS, czyli nowoczesny JavaScript</h1><div class="text-xs sm:text-sm my-6"><div class="inline-block" title="Data opublikowania"><span class="mr-0.5">📆</span><span class="hidden">Data opublikowania:</span><time>30 czerwca 2024</time></div><span class="ml-2 mr-1">/</span><div class="inline-block sm:inline" title="Czas potrzebny na przeczytanie"><span class="mr-0.5">⌛</span><span class="hidden">Czas potrzebny na przeczytanie:</span>18 minut<!-- --> czytania</div></div><div class="flex items-center gap-3 flex-wrap"><a data-slot="button" class="button button--variant-secondary button--size-sm no-underline!" href="/learning/kategorie/javascript" data-discover="true">JavaScript</a></div></header><article class="prose container pt-0 prose-emerald"><p>Witaj w świecie <strong>nowoczesnego JavaScriptu</strong>! 🚀 Jeśli HTML to szkielet strony, a CSS to jej wygląd, to JavaScript jest sercem i mózgiem - sprawia, że strona ożywa, staje się interaktywna i dynamiczna. W ciągu ostatnich lat JavaScript przeszedł prawdziwy "renesans". Dzięki wprowadzeniu standardu <strong>ES6</strong> (ECMAScript 2015) i kolejnych aktualizacji, pisanie kodu w JS stało się znacznie przyjemniejsze, bezpieczniejsze i bardziej efektywne.</p>
<p>Ten przewodnik zabierze Cię w podróż po najważniejszych nowościach, które musisz znać, aby pisać <strong>nowoczesny JavaScript</strong>. Nie martw się, jeśli jesteś początkujący/a - wszystko wyjaśnimy krok po kroku, z przykładami i analogiami, byś mógł/mogła od razu zastosować nową wiedzę w praktyce. Czas unowocześnić swoje umiejętności! ✨</p>
<h2 id="spis-treści" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#spis-treści">>></a>Spis treści</h2>
<ol>
<li><a href="#zmienne-let-const-i-zakresy-blokowe--po%C5%BCegnanie-z-var">Zmienne: <code>let</code>, <code>const</code> i zakresy blokowe - pożegnanie z <code>var</code>?</a></li>
<li><a href="#funkcje-strza%C5%82kowe-arrow-functions-i-ich-zastosowania--kr%C3%B3cej-i-czytelniej">Funkcje strzałkowe (Arrow Functions) i ich zastosowania - krócej i czytelniej</a></li>
<li><a href="#szablony-string%C3%B3w-template-literals--%C5%82atwiejsza-praca-z-tekstem">Szablony stringów (Template Literals) - łatwiejsza praca z tekstem</a></li>
<li><a href="#destrukturyzacja-tablic-i-obiekt%C3%B3w--wyci%C4%85gnij-to-czego-potrzebujesz">Destrukturyzacja tablic i obiektów - wyciągnij to, czego potrzebujesz</a></li>
<li><a href="#spread-i-rest-operator---elastyczno%C5%9B%C4%87-w-manipulacji-danymi">Spread i Rest Operator (<code>...</code>) - elastyczność w manipulacji danymi</a></li>
<li><a href="#promise-api-i-obs%C5%82uga-asynchroniczno%C5%9Bci--opowiadaj-historie-o-przysz%C5%82o%C5%9Bci">Promise API i obsługa asynchroniczności - opowiadaj historie o przyszłości</a></li>
<li><a href="#asyncawait--nowoczesna-obs%C5%82uga-kodu-asynchronicznego--pisz-asynchronicznie-my%C5%9Bl-synchronicznie">Async/await - nowoczesna obsługa kodu asynchronicznego - pisz asynchronicznie, myśl synchronicznie</a></li>
<li><a href="#zadania-do-wykonania-sprawd%C5%BA-swoj%C4%85-wiedz%C4%99">Zadania do wykonania: Sprawdź swoją wiedzę!</a></li>
</ol>
<hr>
<h2 id="zmienne-let-const-i-zakresy-blokowe---pożegnanie-z-var" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#zmienne-let-const-i-zakresy-blokowe---pożegnanie-z-var">>></a>Zmienne: <code>let</code>, <code>const</code> i zakresy blokowe - pożegnanie z <code>var</code>?</h2>
<p>W starszych wersjach JavaScriptu zmienne deklarowaliśmy wyłącznie za pomocą słowa kluczowego <code>var</code>. Często prowadziło to do pomyłek i trudnych do wykrycia błędów. Nowoczesny JavaScript wprowadza dwa nowe sposoby deklarowania zmiennych: <strong><code>let</code></strong> i <strong><code>const</code></strong>, które znacznie poprawiają bezpieczeństwo i przewidywalność kodu.</p>
<h3 id="zakres-blokowy-block-scope" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#zakres-blokowy-block-scope">>>></a>Zakres blokowy (<code>block scope</code>)</h3>
<p>To kluczowa różnica! Zmienne zadeklarowane za pomocą <code>let</code> i <code>const</code> mają <strong>zakres blokowy</strong>. Co to znaczy? Oznaczają, że zmienna istnieje tylko w obrębie najbliższego <strong>bloku kodu</strong>, czyli wszystko, co znajduje się między klamrowymi nawiasami <code>{ ... }</code>.</p>
<p>Pomyśl o tym jak o specjalnej, prywatnej przestrzeni. Jeśli zmienna <code>x</code> jest zadeklarowana wewnątrz bloku <code>if</code>, będzie dostępna tylko w tym bloku. Próba użycia jej poza nim spowoduje błąd. To chroni Cię przed przypadkowym nadpisaniem zmiennych o tej samej nazwie w innej części kodu.</p>
<p><strong>Przykład:</strong></p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) {
  <span class="hljs-keyword">let</span> x = <span class="hljs-number">5</span>; <span class="hljs-comment">// x istnieje tylko wewnątrz tego bloku if</span>
  <span class="hljs-keyword">const</span> y = <span class="hljs-number">10</span>; <span class="hljs-comment">// y również istnieje tylko wewnątrz tego bloku</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x); <span class="hljs-comment">// Wyświetli: 5 (dostępne, bo jesteśmy w bloku)</span>
}
<span class="hljs-comment">// console.log(x); // WYWOŁA BŁĄD! ReferenceError: x is not defined</span>
<span class="hljs-comment">// console.log(y); // WYWOŁA BŁĄD! ReferenceError: y is not defined</span>
</code></pre>
<p>Dla porównania, <code>var</code> ma <strong>zakres funkcyjny</strong> (function scope), co oznacza, że zmienna zadeklarowana w funkcji jest dostępna w całej funkcji, ale poza funkcją jest dostępna globalnie, co jest źródłem wielu problemów. Dlatego w nowoczesnym kodzie <strong>zdecydowanie unikamy <code>var</code></strong>.</p>
<h3 id="różnice-między-let-const-i-var" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#różnice-między-let-const-i-var">>>></a>Różnice między <code>let</code>, <code>const</code> i <code>var</code></h3>
<ul>
<li>
<p><strong><code>let</code></strong>:</p>
<ul>
<li><strong>Deklaruje zmienną</strong>, której wartość może być <strong>zmieniana</strong> w dowolnym momencie.</li>
<li>Ma <strong>zakres blokowy</strong>.</li>
<li>Nie można jej ponownie zadeklarować w tym samym bloku (np. <code>let x = 5; let x = 10;</code> to błąd), ale można zmienić jej wartość (<code>x = 10;</code>).</li>
<li>Używaj <code>let</code>, gdy wiesz, że wartość zmiennej będzie się zmieniać (np. licznik w pętli).</li>
</ul>
</li>
<li>
<p><strong><code>const</code></strong>:</p>
<ul>
<li>Deklaruje <strong>stałą</strong>, której wartość musi być <strong>przypisana od razu</strong> i <strong>nie może być zmieniana</strong> później.</li>
<li>Ma <strong>zakres blokowy</strong>.</li>
<li>Jeśli przypiszesz do <code>const</code> obiekt lub tablicę, nie możesz przypisać do niej <em>nowego</em> obiektu/tablicy, ale możesz <strong>modyfikować zawartość</strong> tego obiektu/tablicy (np. dodawać lub usuwać elementy). <code>const</code> gwarantuje, że referencja (wskaźnik) do obiektu pozostaje taka sama, ale nie "zamraża" samego obiektu.</li>
<li>Używaj <code>const</code>, gdy wartość zmiennej nie powinna się zmieniać. To jest domyślny wybór w nowoczesnym JS, chyba że potrzebujesz <code>let</code>.</li>
</ul>
</li>
<li>
<p><strong><code>var</code></strong>:</p>
<ul>
<li><strong>Ma zakres funkcyjny</strong> (lub globalny, jeśli jest poza funkcją).</li>
<li>Jest podatny na <strong>hoisting</strong> (podnoszenie deklaracji), co oznacza, że deklaracja zmiennej jest "przenoszona" na początek zakresu, co może prowadzić do nieintuicyjnych zachowań.</li>
<li>Można go <strong>wielokrotnie deklarować</strong> w tym samym zakresie, co łatwo prowadzi do przypadkowych nadpisań.</li>
<li><strong>Unikaj używania <code>var</code> w nowym kodzie!</strong></li>
</ul>
</li>
</ul>
<p><strong>Przykład <code>const</code> z obiektem/tablicą:</strong></p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> tablica = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
tablica.<span class="hljs-title function_">push</span>(<span class="hljs-number">4</span>); <span class="hljs-comment">// DOZWOLONE! Zmieniamy zawartość tablicy, nie przypisujemy nowej tablicy.</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(tablica); <span class="hljs-comment">// Wyświetli: [1, 2, 3, 4]</span>

<span class="hljs-comment">// tablica = [5, 6]; // WYWOŁA BŁĄD! TypeError: Assignment to constant variable.</span>
<span class="hljs-comment">// Próbujesz przypisać zupełnie nową tablicę do stałej referencji.</span>

<span class="hljs-keyword">const</span> osoba = { <span class="hljs-attr">imie</span>: <span class="hljs-string">"Anna"</span>, <span class="hljs-attr">wiek</span>: <span class="hljs-number">28</span> };
osoba.<span class="hljs-property">wiek</span> = <span class="hljs-number">29</span>; <span class="hljs-comment">// DOZWOLONE! Zmieniamy właściwość obiektu, nie przypisujemy nowego obiektu.</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(osoba); <span class="hljs-comment">// Wyświetli: { imie: "Anna", wiek: 29 }</span>

<span class="hljs-comment">// osoba = { nazwisko: "Nowak" }; // WYWOŁA BŁĄD!</span>
</code></pre>
<hr>
<h2 id="funkcje-strzałkowe-arrow-functions-i-ich-zastosowania---krócej-i-czytelniej" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#funkcje-strzałkowe-arrow-functions-i-ich-zastosowania---krócej-i-czytelniej">>></a>Funkcje strzałkowe (Arrow Functions) i ich zastosowania - krócej i czytelniej</h2>
<p>Funkcje strzałkowe to zwięzła alternatywa dla tradycyjnych funkcji JavaScript, która została wprowadzona w ES6. Są nie tylko krótsze, ale także rozwiązują pewien problem z kontekstem <code>this</code>, który często mylił początkujących programistów.</p>
<h3 id="składnia-funkcji-strzałkowej" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#składnia-funkcji-strzałkowej">>>></a>Składnia funkcji strzałkowej</h3>
<p>Największą zaletą funkcji strzałkowych jest ich zwięzła składnia, zwłaszcza dla prostych funkcji.</p>
<ul>
<li>
<p><strong>Szybszy zapis (szczególnie dla funkcji jedno-liniowych):</strong>
Jeśli funkcja składa się tylko z jednej instrukcji, która zwraca wartość, możesz pominąć nawiasy klamrowe <code>{}</code> i słowo kluczowe <code>return</code>.</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// Tradycyjna funkcja</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">dodajStara</span>(<span class="hljs-params">a, b</span>) {
  <span class="hljs-keyword">return</span> a + b;
}

<span class="hljs-comment">// Funkcja strzałkowa (krótszy zapis)</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">dodaj</span> = (<span class="hljs-params">a, b</span>) => a + b;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">dodaj</span>(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">// Wyświetli: 8</span>

<span class="hljs-comment">// Funkcja z jednym argumentem (można pominąć nawiasy wokół argumentu)</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">powitanie</span> = (<span class="hljs-params">imie</span>) => <span class="hljs-string">`Cześć, <span class="hljs-subst">${imie}</span>!`</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">powitanie</span>(<span class="hljs-string">"Ola"</span>)); <span class="hljs-comment">// Wyświetli: Cześć, Ola!</span>

<span class="hljs-comment">// Funkcja bez argumentów (konieczne puste nawiasy)</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">powiedzHello</span> = (<span class="hljs-params"></span>) => <span class="hljs-string">"Hello!"</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">powiedzHello</span>()); <span class="hljs-comment">// Wyświetli: Hello!</span>
</code></pre>
</li>
<li>
<p><strong>Brak własnego obiektu <code>arguments</code>:</strong> Funkcje strzałkowe nie mają własnego obiektu <code>arguments</code> (który zawiera wszystkie argumenty przekazane do funkcji). Jeśli go potrzebujesz, użyj <strong>rest operatora</strong> (<code>...</code>), o którym powiemy później.</p>
</li>
<li>
<p><strong>Brak możliwości użycia jako konstruktor:</strong> Nie możesz użyć funkcji strzałkowej do tworzenia nowych obiektów za pomocą słowa kluczowego <code>new</code>.</p>
</li>
</ul>
<h3 id="funkcje-strzałkowe-a-kontekst-this" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#funkcje-strzałkowe-a-kontekst-this">>>></a>Funkcje strzałkowe a kontekst <code>this</code></h3>
<p>To jest jeden z najważniejszych powodów, dla których wprowadzono funkcje strzałkowe. W tradycyjnych funkcjach, wartość <code>this</code> zależy od tego, jak funkcja jest wywoływana. To prowadziło do częstych błędów, zwłaszcza w callbackach (funkcjach wywoływanych przez inne funkcje, np. w <code>setTimeout</code> czy w obsłudze zdarzeń).</p>
<p>Funkcje strzałkowe rozwiązują ten problem: <strong>nie mają własnego <code>this</code></strong>. Zamiast tego, <strong>dziedziczą <code>this</code> z otoczenia, w którym zostały zadeklarowane</strong> (tzw. leksykalny <code>this</code>).</p>
<p><strong>Przykład problemu ze <code>this</code> w tradycyjnych funkcjach:</strong></p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// Tradycyjna funkcja, która "gubi" kontekst this</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">TimerProblem</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">sekundy</span> = <span class="hljs-number">0</span>;
  <span class="hljs-built_in">setInterval</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-comment">// Tutaj 'this' nie odnosi się do obiektu TimerProblem,</span>
    <span class="hljs-comment">// ale do obiektu globalnego (np. window w przeglądarce) lub jest undefined w trybie 'strict mode'</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">sekundy</span>++; <span class="hljs-comment">// To nie zadziała tak, jak byśmy chcieli!</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">sekundy</span>);
  }, <span class="hljs-number">1000</span>);
}
<span class="hljs-comment">// new TimerProblem(); // W konsoli prawdopodobnie zobaczysz NaN lub błąd</span>
</code></pre>
<p><strong>Rozwiązanie z funkcją strzałkową:</strong></p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">TimerPoprawny</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">sekundy</span> = <span class="hljs-number">0</span>;
  <span class="hljs-comment">// Funkcja strzałkowa dziedziczy 'this' z TimerPoprawny (czyli z obiektu TimerPoprawny)</span>
  <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">sekundy</span>++;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Sekundy: <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.sekundy}</span>`</span>);
  }, <span class="hljs-number">1000</span>);
}
<span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerPoprawny</span>(); <span class="hljs-comment">// Będzie poprawnie liczyć sekundy: Sekundy: 1, Sekundy: 2, itd.</span>
</code></pre>
<p>Dzięki temu funkcje strzałkowe są idealne do użycia w callbackach, metodach obiektów (choć nie jako metody obiektów najwyższego poziomu, bo wtedy <code>this</code> wskazałoby na <code>window</code>), czy w sytuacjach, gdzie chcesz, aby <code>this</code> zachowało kontekst nadrzędny.</p>
<hr>
<h2 id="szablony-stringów-template-literals---łatwiejsza-praca-z-tekstem" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#szablony-stringów-template-literals---łatwiejsza-praca-z-tekstem">>></a>Szablony stringów (Template Literals) - łatwiejsza praca z tekstem</h2>
<p>Szablony stringów, wprowadzone w ES6, to potężne narzędzie do tworzenia ciągów znaków (stringów). Zastępują tradycyjne łączenie stringów za pomocą operatora <code>+</code> i oferują znacznie większą elastyczność i czytelność. Używamy ich, otaczając tekst <strong>backtickami</strong> (apostrofami wstecznymi) <code> </code> zamiast pojedynczych lub podwójnych cudzysłowów.</p>
<h3 id="interpolacja-i-wielolinijkowość" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#interpolacja-i-wielolinijkowość">>>></a>Interpolacja i wielolinijkowość</h3>
<ul>
<li>
<p><strong>Interpolacja zmiennych i wyrażeń:</strong>
Możesz łatwo osadzać zmienne lub dowolne wyrażenia JavaScript bezpośrednio w stringu, używając składni <code>${...}</code>. To znacznie ułatwia budowanie dynamicznych komunikatów.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> imie = <span class="hljs-string">"Alicja"</span>;
<span class="hljs-keyword">const</span> wiek = <span class="hljs-number">30</span>;

<span class="hljs-comment">// Stary sposób: męczące łączenie stringów</span>
<span class="hljs-keyword">const</span> infoStare = <span class="hljs-string">"Mam na imię "</span> + imie + <span class="hljs-string">" i mam "</span> + wiek + <span class="hljs-string">" lat."</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(infoStare); <span class="hljs-comment">// Wyświetli: Mam na imię Alicja i mam 30 lat.</span>

<span class="hljs-comment">// Nowy sposób z szablonami stringów: czytelniej i prościej!</span>
<span class="hljs-keyword">const</span> infoNowe = <span class="hljs-string">`Mam na imię <span class="hljs-subst">${imie}</span> i mam <span class="hljs-subst">${wiek}</span> lat.`</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(infoNowe); <span class="hljs-comment">// Wyświetli: Mam na imię Alicja i mam 30 lat.</span>

<span class="hljs-comment">// Możesz umieszczać dowolne wyrażenia JavaScript:</span>
<span class="hljs-keyword">const</span> cena = <span class="hljs-number">10.5</span>;
<span class="hljs-keyword">const</span> ilosc = <span class="hljs-number">2</span>;
<span class="hljs-keyword">const</span> rachunek = <span class="hljs-string">`Koszt zakupu: <span class="hljs-subst">${cena * ilosc}</span> zł.`</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(rachunek); <span class="hljs-comment">// Wyświetli: Koszt zakupu: 21 zł.</span>
</code></pre>
</li>
<li>
<p><strong>Łatwe tworzenie tekstów wielolinijkowych:</strong>
Koniec z dodawaniem <code>n</code> do każdej linii! W szablonach stringów możesz po prostu nacisnąć Enter, a tekst zachowa formatowanie z nowymi liniami. Jest to szczególnie przydatne przy generowaniu fragmentów HTML bezpośrednio w JavaScript.</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// Stary sposób: brzydkie i niewygodne</span>
<span class="hljs-keyword">const</span> htmlStare =
  <span class="hljs-string">"&#x3C;div>\n  &#x3C;h1>Witaj!&#x3C;/h1>\n  &#x3C;p>To jest wielolinijkowy tekst.&#x3C;/p>\n&#x3C;/div>"</span>;

<span class="hljs-comment">// Nowy sposób: super czytelne!</span>
<span class="hljs-keyword">const</span> htmlNowe = <span class="hljs-string">`
  &#x3C;div>
    &#x3C;h1>Witaj!&#x3C;/h1>
    &#x3C;p>To jest wielolinijkowy tekst. I kolejna linia w tym samym akapicie.&#x3C;/p>
  &#x3C;/div>
`</span>;

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(htmlNowe);
</code></pre>
</li>
</ul>
<h3 id="dodatkowe-możliwości" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#dodatkowe-możliwości">>>></a>Dodatkowe możliwości</h3>
<p>Szablony stringów wspierają także tzw. <strong>tagowane szablony</strong> (<code>tagged templates</code>), które pozwalają na zaawansowaną manipulację tekstem przed jego finalnym utworzeniem. Możesz zdefiniować funkcję ("tag"), która będzie przetwarzać części stringu i wartości zmiennych. Jest to bardziej zaawansowana funkcja, używana np. do tłumaczeń, walidacji, bezpiecznego generowania HTML (zapobieganie XSS) czy formatowania danych.</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// Przykład funkcji "tagującej"</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">upper</span>(<span class="hljs-params">strings, ...values</span>) {
  <span class="hljs-comment">// 'strings' to tablica tekstów, 'values' to tablica zmiennych</span>
  <span class="hljs-keyword">let</span> wynik = strings[<span class="hljs-number">0</span>];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &#x3C; values.<span class="hljs-property">length</span>; i++) {
    wynik += values[i].<span class="hljs-title function_">toUpperCase</span>() + strings[i + <span class="hljs-number">1</span>]; <span class="hljs-comment">// Zamienia zmienne na duże litery</span>
  }
  <span class="hljs-keyword">return</span> wynik;
}

<span class="hljs-keyword">const</span> imie = <span class="hljs-string">"Kasia"</span>;
<span class="hljs-keyword">const</span> wiek = <span class="hljs-number">20</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(upper<span class="hljs-string">`Cześć, <span class="hljs-subst">${imie}</span>! Masz <span class="hljs-subst">${wiek}</span> lat?`</span>); <span class="hljs-comment">// Wyświetli: Cześć, KASIA! Masz 20 lat?</span>
</code></pre>
<p>W tym przykładzie funkcja <code>upper</code> została "przypięta" do szablonu stringu i zmodyfikowała zmienną <code>imie</code> na wielkie litery.</p>
<hr>
<h2 id="destrukturyzacja-tablic-i-obiektów---wyciągnij-to-czego-potrzebujesz" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#destrukturyzacja-tablic-i-obiektów---wyciągnij-to-czego-potrzebujesz">>></a>Destrukturyzacja tablic i obiektów - wyciągnij to, czego potrzebujesz</h2>
<p>Destrukturyzacja to potężna i bardzo często używana funkcja w nowoczesnym JavaScript. Pozwala na "rozpakowanie" wartości z tablic lub właściwości z obiektów do oddzielnych zmiennych w bardzo zwięzły i czytelny sposób. Upraszcza kod i czyni go bardziej deklaratywnym.</p>
<h3 id="destrukturyzacja-tablic" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#destrukturyzacja-tablic">>>></a>Destrukturyzacja tablic</h3>
<p>Pozwala na szybkie przypisanie wartości z tablicy do zmiennych, bazując na ich pozycji.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> kolory = [<span class="hljs-string">"czerwony"</span>, <span class="hljs-string">"zielony"</span>, <span class="hljs-string">"niebieski"</span>];

<span class="hljs-comment">// Stary sposób:</span>
<span class="hljs-comment">// const kolor1 = kolory[0];</span>
<span class="hljs-comment">// const kolor2 = kolory[1];</span>

<span class="hljs-comment">// Nowy sposób z destrukturyzacją tablic:</span>
<span class="hljs-keyword">const</span> [pierwszyKolor, drugiKolor, trzeciKolor] = kolory;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pierwszyKolor); <span class="hljs-comment">// Wyświetli: czerwony</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(drugiKolor); <span class="hljs-comment">// Wyświetli: zielony</span>

<span class="hljs-comment">// Można pomijać niektóre elementy (używając przecinków):</span>
<span class="hljs-keyword">const</span> [a, , b] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]; <span class="hljs-comment">// Pomijamy drugi element (2)</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a, b); <span class="hljs-comment">// Wyświetli: 1 3</span>

<span class="hljs-comment">// Można przypisać wartości domyślne, jeśli element nie istnieje:</span>
<span class="hljs-keyword">const</span> [x, y, z = <span class="hljs-string">"domyślny"</span>] = [<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x, y, z); <span class="hljs-comment">// Wyświetli: A B domyślny</span>

<span class="hljs-comment">// Można zbierać pozostałe elementy do nowej tablicy (rest operator - patrz dalej):</span>
<span class="hljs-keyword">const</span> [pierwszy, ...resztaKolorow] = kolory;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pierwszy); <span class="hljs-comment">// Wyświetli: czerwony</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(resztaKolorow); <span class="hljs-comment">// Wyświetli: ["zielony", "niebieski"]</span>
</code></pre>
<h3 id="destrukturyzacja-obiektów" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#destrukturyzacja-obiektów">>>></a>Destrukturyzacja obiektów</h3>
<p>Pozwala na przypisanie wartości z obiektu do zmiennych na podstawie nazw ich <strong>kluczy (właściwości)</strong>. Kolejność nie ma znaczenia, liczy się nazwa klucza.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> samochod = { <span class="hljs-attr">marka</span>: <span class="hljs-string">"Ford"</span>, <span class="hljs-attr">model</span>: <span class="hljs-string">"Focus"</span>, <span class="hljs-attr">rok</span>: <span class="hljs-number">2018</span> };

<span class="hljs-comment">// Stary sposób:</span>
<span class="hljs-comment">// const markaSamochodu = samochod.marka;</span>
<span class="hljs-comment">// const modelSamochodu = samochod.model;</span>

<span class="hljs-comment">// Nowy sposób z destrukturyzacją obiektów:</span>
<span class="hljs-keyword">const</span> { marka, model } = samochod;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(marka); <span class="hljs-comment">// Wyświetli: Ford</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(model); <span class="hljs-comment">// Wyświetli: Focus</span>

<span class="hljs-comment">// Można przypisać wartości domyślne, jeśli właściwość nie istnieje:</span>
<span class="hljs-keyword">const</span> { <span class="hljs-attr">marka</span>: m, kolor = <span class="hljs-string">"czarny"</span> } = samochod; <span class="hljs-comment">// 'kolor' nie istnieje w obiekcie 'samochod'</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(m, kolor); <span class="hljs-comment">// Wyświetli: Ford czarny</span>

<span class="hljs-comment">// Można zmienić nazwę zmiennej, do której przypisujemy wartość:</span>
<span class="hljs-keyword">const</span> { <span class="hljs-attr">marka</span>: nazwaMarki, <span class="hljs-attr">model</span>: typModelu } = samochod;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(nazwaMarki, typModelu); <span class="hljs-comment">// Wyświetli: Ford Focus</span>

<span class="hljs-comment">// Można też zbierać pozostałe właściwości do nowego obiektu (rest operator - patrz dalej):</span>
<span class="hljs-keyword">const</span> { rok, ...resztaSamochodu } = samochod;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(rok); <span class="hljs-comment">// Wyświetli: 2018</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(resztaSamochodu); <span class="hljs-comment">// Wyświetli: { marka: "Ford", model: "Focus" }</span>
</code></pre>
<p>Destrukturyzacja jest szczególnie przydatna w funkcjach, gdy chcesz łatwo wyciągnąć konkretne dane z obiektów konfiguracyjnych lub z wyników API.</p>
<hr>
<h2 id="spread-i-rest-operator----elastyczność-w-manipulacji-danymi" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#spread-i-rest-operator----elastyczność-w-manipulacji-danymi">>></a>Spread i Rest Operator (<code>...</code>) - elastyczność w manipulacji danymi</h2>
<p>Operator <code>...</code> (trzy kropki) jest jednym z najbardziej uniwersalnych i potężnych narzędzi w nowoczesnym JavaScript. Nazywany jest <strong>operatorem spread</strong> lub <strong>operatorem rest</strong>, w zależności od kontekstu, w jakim jest używany.</p>
<h3 id="spread-operator-operator-rozproszenia" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#spread-operator-operator-rozproszenia">>>></a>Spread Operator (operator rozproszenia)</h3>
<p>Gdy używasz <code>...</code> do <strong>rozbicia</strong> elementów tablicy lub właściwości obiektu na pojedyncze elementy, mówimy o <strong>operatorze spread</strong>. Jest to jak "rozłożenie" zawartości kolekcji. 🌐</p>
<p><strong>Zastosowania Spread Operatora:</strong></p>
<ul>
<li>
<p><strong>Kopiowanie i łączenie tablic:</strong> Tworzenie płytkich kopii tablic lub łączenie ich bez modyfikowania oryginalnych.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> cyfry = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-keyword">const</span> noweCyfry = [...cyfry, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]; <span class="hljs-comment">// Rozwija [1, 2, 3] do 1, 2, 3, a potem dodaje 4, 5</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(noweCyfry); <span class="hljs-comment">// Wyświetli: [1, 2, 3, 4, 5]</span>

<span class="hljs-keyword">const</span> tablica1 = [<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>];
<span class="hljs-keyword">const</span> tablica2 = [<span class="hljs-string">"c"</span>, <span class="hljs-string">"d"</span>];
<span class="hljs-keyword">const</span> polaczoneTablice = [...tablica1, ...tablica2];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(polaczoneTablice); <span class="hljs-comment">// Wyświetli: ["a", "b", "c", "d"]</span>
</code></pre>
</li>
<li>
<p><strong>Kopiowanie i łączenie obiektów:</strong> Podobnie jak z tablicami, możesz tworzyć kopie obiektów i łączyć ich właściwości.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> osoba = { <span class="hljs-attr">imie</span>: <span class="hljs-string">"Anna"</span>, <span class="hljs-attr">wiek</span>: <span class="hljs-number">28</span> };
<span class="hljs-keyword">const</span> osobaZZawodem = { ...osoba, <span class="hljs-attr">zawod</span>: <span class="hljs-string">"Programista"</span> };
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(osobaZZawodem); <span class="hljs-comment">// Wyświetli: { imie: "Anna", wiek: 28, zawod: "Programista" }</span>

<span class="hljs-keyword">const</span> daneKontaktowe = { <span class="hljs-attr">email</span>: <span class="hljs-string">"a@example.com"</span>, <span class="hljs-attr">telefon</span>: <span class="hljs-string">"123-456-789"</span> };
<span class="hljs-keyword">const</span> pelneDane = { ...osoba, ...daneKontaktowe };
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pelneDane); <span class="hljs-comment">// Wyświetli: { imie: "Anna", wiek: 28, email: "a@example.com", telefon: "123-456-789" }</span>
</code></pre>
<p>Jeśli klucze się powtarzają, ostatnia wartość nadpisuje poprzednią.</p>
</li>
<li>
<p><strong>Przekazywanie argumentów funkcji:</strong> Możesz rozwijać tablicę jako argumenty funkcji.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sumuj</span>(<span class="hljs-params">a, b, c</span>) {
  <span class="hljs-keyword">return</span> a + b + c;
}
<span class="hljs-keyword">const</span> liczby = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sumuj</span>(...liczby)); <span class="hljs-comment">// Rozwija [10, 20, 30] do sumuj(10, 20, 30), wyświetli: 60</span>
</code></pre>
</li>
</ul>
<h3 id="rest-operator-operator-reszty" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#rest-operator-operator-reszty">>>></a>Rest Operator (operator reszty)</h3>
<p>Gdy używasz <code>...</code> do <strong>zbierania</strong> wielu elementów w jedną tablicę (lub właściwości w obiekt), mówimy o <strong>operatorze rest</strong>. Jest to jak "zbieranie" luźnych elementów w jedną kolekcję. 🧺</p>
<p><strong>Zastosowania Rest Operatora:</strong></p>
<ul>
<li>
<p><strong>Zbieranie argumentów funkcji:</strong> Pozwala funkcji przyjmować nieokreśloną liczbę argumentów i traktować je jako tablicę.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">suma</span>(<span class="hljs-params">...liczby</span>) {
  <span class="hljs-comment">// 'liczby' zbiera wszystkie przekazane argumenty w tablicę</span>
  <span class="hljs-keyword">return</span> liczby.<span class="hljs-title function_">reduce</span>(
    <span class="hljs-function">(<span class="hljs-params">akumulator, aktualnaLiczba</span>) =></span> akumulator + aktualnaLiczba,
    <span class="hljs-number">0</span>
  );
}
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">suma</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">// Wyświetli: 6</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">suma</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>)); <span class="hljs-comment">// Wyświetli: 100</span>
</code></pre>
</li>
<li>
<p><strong>W destrukturyzacji (jak widzieliśmy wcześniej):</strong> Zbieranie pozostałych elementów do nowej tablicy lub obiektu.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> [pierwszy, drugi, ...resztaTablicy] = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pierwszy); <span class="hljs-comment">// Wyświetli: 10</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(drugi); <span class="hljs-comment">// Wyświetli: 20</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(resztaTablicy); <span class="hljs-comment">// Wyświetli: [30, 40, 50]</span>

<span class="hljs-keyword">const</span> { imie, ...resztaOsoby } = {
  <span class="hljs-attr">imie</span>: <span class="hljs-string">"Ola"</span>,
  <span class="hljs-attr">wiek</span>: <span class="hljs-number">25</span>,
  <span class="hljs-attr">miasto</span>: <span class="hljs-string">"Warszawa"</span>,
};
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(imie); <span class="hljs-comment">// Wyświetli: Ola</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(resztaOsoby); <span class="hljs-comment">// Wyświetli: { wiek: 25, miasto: "Warszawa" }</span>
</code></pre>
</li>
</ul>
<p>Zarówno spread, jak i rest operator są niezwykle przydatne i sprawiają, że kod jest znacznie bardziej zwięzły i czytelny, szczególnie podczas pracy z tablicami i obiektami.</p>
<hr>
<h2 id="promise-api-i-obsługa-asynchroniczności---opowiadaj-historie-o-przyszłości" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#promise-api-i-obsługa-asynchroniczności---opowiadaj-historie-o-przyszłości">>></a>Promise API i obsługa asynchroniczności - opowiadaj historie o przyszłości</h2>
<p>JavaScript jest językiem <strong>jednowątkowym</strong>, co oznacza, że może wykonywać tylko jedną operację w danym momencie. Jednak wiele operacji, takich jak pobieranie danych z internetu, odczyt plików, czy operacje na bazie danych, trwa pewien czas. Gdyby JavaScript musiał czekać na ich zakończenie, strona internetowa by się "zawiesiła" (nie reagowałaby na kliknięcia, przewijanie itp.).</p>
<p>Tutaj wkracza <strong>asynchroniczność</strong>. Pozwala ona na rozpoczęcie operacji, a następnie przejście do kolejnych zadań, nie czekając na zakończenie tej pierwszej. Kiedy asynchroniczna operacja się zakończy, JavaScript wróci do niej i wykona dalsze kroki.</p>
<p>Starszym sposobem obsługi asynchroniczności były <strong>callbacki</strong> (funkcje zwrotne), które jednak często prowadziły do tzw. "callback hell" (piekła callbacków) - zagnieżdżonego, trudnego do czytania i utrzymania kodu.</p>
<h3 id="czym-jest-promise" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#czym-jest-promise">>>></a>Czym jest Promise?</h3>
<p><strong>Promise (Obietnica)</strong> to obiekt w JavaScript, który reprezentuje ostateczne zakończenie (lub niepowodzenie) operacji asynchronicznej. Możesz myśleć o Promise jako o "przyszłej wartości". Składasz obietnicę, że w przyszłości otrzymasz wynik - albo sukces, albo błąd. 📦</p>
<p>Promise może znajdować się w jednym z trzech stanów:</p>
<ol>
<li><strong><code>pending</code> (oczekujący)</strong>: Początkowy stan; ani spełniony, ani odrzucony. Operacja asynchroniczna nadal trwa.</li>
<li><strong><code>fulfilled</code> (spełniony)</strong>: Operacja asynchroniczna zakończyła się sukcesem i zwróciła wartość.</li>
<li><strong><code>rejected</code> (odrzucony)</strong>: Operacja asynchroniczna zakończyła się błędem.</li>
</ol>
<p>Możesz "podpiąć" funkcje, które zostaną wywołane, gdy Promise zmieni swój stan:</p>
<ul>
<li><strong><code>.then()</code></strong>: Wywoływany, gdy Promise zostanie <code>fulfilled</code> (operacja zakończy się sukcesem). Otrzymuje wartość zwróconą przez Promise.</li>
<li><strong><code>.catch()</code></strong>: Wywoływany, gdy Promise zostanie <code>rejected</code> (wystąpi błąd). Otrzymuje obiekt błędu.</li>
<li><strong><code>.finally()</code></strong>: Wywoływany zawsze, niezależnie od tego, czy Promise zakończył się sukcesem, czy błędem. Idealny do czyszczenia zasobów.</li>
</ul>
<p><strong>Przykład tworzenia i używania Promise:</strong></p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> obietnica = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> {
  <span class="hljs-comment">// Symulujemy operację asynchroniczną (np. pobieranie danych)</span>
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-keyword">const</span> sukces = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() > <span class="hljs-number">0.5</span>; <span class="hljs-comment">// Losowo decydujemy o sukcesie lub błędzie</span>

    <span class="hljs-keyword">if</span> (sukces) {
      <span class="hljs-title function_">resolve</span>(<span class="hljs-string">"Dane pobrane pomyślnie!"</span>); <span class="hljs-comment">// Jeśli sukces, wywołujemy resolve z wynikiem</span>
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"Nie udało się pobrać danych."</span>)); <span class="hljs-comment">// Jeśli błąd, wywołujemy reject z błędem</span>
    }
  }, <span class="hljs-number">2000</span>); <span class="hljs-comment">// Operacja trwa 2 sekundy</span>
});

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Rozpoczęto operację..."</span>);

obietnica
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">wiadomosc</span>) =></span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"SUKCES:"</span>, wiadomosc); <span class="hljs-comment">// Wykona się, jeśli obietnica się spełni</span>
  })
  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">blad</span>) =></span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"BŁĄD:"</span>, blad.<span class="hljs-property">message</span>); <span class="hljs-comment">// Wykona się, jeśli obietnica zostanie odrzucona</span>
  })
  .<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Operacja zakończona (niezależnie od wyniku)."</span>); <span class="hljs-comment">// Wykona się zawsze</span>
  });

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Kod po obietnicy nadal się wykonuje..."</span>); <span class="hljs-comment">// Pokazuje asynchroniczność</span>
</code></pre>
<h3 id="łańcuchy-promise-promise-chaining" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#łańcuchy-promise-promise-chaining">>>></a>Łańcuchy Promise (<code>Promise Chaining</code>)</h3>
<p>Jedną z największych zalet Promise jest możliwość łączenia wielu operacji asynchronicznych w jeden czytelny "łańcuch". Każdy <code>.then()</code> zwraca nowy Promise, co pozwala na kolejne <code>.then()</code> wywołane po sobie. Jest to idealne, gdy jedna operacja asynchroniczna zależy od wyniku poprzedniej.</p>
<p><strong>Przykład łańcucha Promise (pobieranie danych z API):</strong></p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// fetch() to wbudowana funkcja JS, która zwraca Promise</span>
<span class="hljs-title function_">fetch</span>(<span class="hljs-string">"https://jsonplaceholder.typicode.com/users/1"</span>) <span class="hljs-comment">// Pobierz dane użytkownika o ID 1</span>
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">response</span>) =></span> {
    <span class="hljs-comment">// Pierwsze .then: sprawdź, czy odpowiedź jest OK i sparsuj ją jako JSON</span>
    <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`Błąd HTTP! Status: <span class="hljs-subst">${response.status}</span>`</span>);
    }
    <span class="hljs-keyword">return</span> response.<span class="hljs-title function_">json</span>(); <span class="hljs-comment">// Zwróć kolejny Promise z danymi JSON</span>
  })
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">user</span>) =></span> {
    <span class="hljs-comment">// Drugie .then: otrzymaj sparsowane dane użytkownika</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Pobrany użytkownik:"</span>, user.<span class="hljs-property">name</span>, user.<span class="hljs-property">email</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">fetch</span>(
      <span class="hljs-string">`https://jsonplaceholder.typicode.com/posts?userId=<span class="hljs-subst">${user.id}</span>`</span>
    ); <span class="hljs-comment">// Pobierz posty tego użytkownika</span>
  })
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">response</span>) =></span> {
    <span class="hljs-comment">// Trzecie .then: sprawdź odpowiedź i sparsuj posty</span>
    <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`Błąd HTTP! Status: <span class="hljs-subst">${response.status}</span>`</span>);
    }
    <span class="hljs-keyword">return</span> response.<span class="hljs-title function_">json</span>();
  })
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">posts</span>) =></span> {
    <span class="hljs-comment">// Czwarte .then: otrzymaj posty</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Liczba postów użytkownika:"</span>, posts.<span class="hljs-property">length</span>);
  })
  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =></span> {
    <span class="hljs-comment">// .catch: Obsłuż każdy błąd, który wystąpił na dowolnym etapie łańcucha</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"Wystąpił błąd w łańcuchu Promise:"</span>, error);
  })
  .<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Pobieranie danych zakończone."</span>);
  });
</code></pre>
<p>Promise to podstawa nowoczesnego JS w obsłudze asynchroniczności, a kolejny rozdział pokaże Ci, jak jeszcze bardziej uprościć ich użycie.</p>
<hr>
<h2 id="asyncawait---nowoczesna-obsługa-kodu-asynchronicznego---pisz-asynchronicznie-myśl-synchronicznie" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#asyncawait---nowoczesna-obsługa-kodu-asynchronicznego---pisz-asynchronicznie-myśl-synchronicznie">>></a>Async/await - nowoczesna obsługa kodu asynchronicznego - pisz asynchronicznie, myśl synchronicznie</h2>
<p>Mimo że Promise są ogromnym krokiem naprzód w porównaniu do callbacków, kod z długimi łańcuchami <code>.then().then().catch()</code> może wciąż być trudny do czytania. Standard ES2017 wprowadził słowa kluczowe <strong><code>async</code></strong> i <strong><code>await</code></strong>, które pozwalają pisać kod asynchroniczny w sposób, który wygląda i zachowuje się niemal identycznie jak kod synchroniczny, jednocześnie zachowując asynchroniczną naturę. To game changer! 🎮</p>
<h3 id="uproszczenie-pracy-z-promise" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#uproszczenie-pracy-z-promise">>>></a>Uproszczenie pracy z Promise</h3>
<ul>
<li><strong><code>async</code></strong>: Musisz oznaczyć funkcję słowem kluczowym <code>async</code>, aby móc używać w niej <code>await</code>. Funkcja <code>async</code> <strong>zawsze zwraca Promise</strong>, nawet jeśli zwrócisz w niej zwykłą wartość - JavaScript automatycznie opakuje ją w Promise.</li>
<li><strong><code>await</code></strong>: Słowo kluczowe <code>await</code> może być użyte <strong>tylko wewnątrz funkcji <code>async</code></strong>. Powoduje ono, że wykonanie funkcji <code>async</code> zostaje <strong>wstrzymane</strong>, dopóki Promise, na który czeka <code>await</code>, nie zostanie <strong>spełniony (fulfilled)</strong>. Kiedy Promise się spełni, <code>await</code> "rozpakowuje" jego wartość i przypisuje ją do zmiennej. Jeśli Promise zostanie odrzucony (rejected), <code>await</code> "wyrzuci" błąd, który możesz obsłużyć za pomocą <code>try...catch</code>.</li>
</ul>
<p><strong>Przykład użycia <code>async/await</code> (porównaj z przykładem z Promise Chaining):</strong></p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">pobierzDaneUzytkownikaIPosty</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Rozpoczynam pobieranie danych..."</span>);

    <span class="hljs-comment">// Krok 1: Pobierz dane użytkownika</span>
    <span class="hljs-keyword">const</span> userResponse = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(
      <span class="hljs-string">"https://jsonplaceholder.typicode.com/users/1"</span>
    );
    <span class="hljs-keyword">if</span> (!userResponse.<span class="hljs-property">ok</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(
        <span class="hljs-string">`Błąd HTTP przy pobieraniu użytkownika! Status: <span class="hljs-subst">${userResponse.status}</span>`</span>
      );
    }
    <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> userResponse.<span class="hljs-title function_">json</span>(); <span class="hljs-comment">// Poczekaj na parsowanie JSON</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Pobrany użytkownik:"</span>, user.<span class="hljs-property">name</span>, user.<span class="hljs-property">email</span>);

    <span class="hljs-comment">// Krok 2: Pobierz posty tego użytkownika</span>
    <span class="hljs-keyword">const</span> postsResponse = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(
      <span class="hljs-string">`https://jsonplaceholder.typicode.com/posts?userId=<span class="hljs-subst">${user.id}</span>`</span>
    );
    <span class="hljs-keyword">if</span> (!postsResponse.<span class="hljs-property">ok</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(
        <span class="hljs-string">`Błąd HTTP przy pobieraniu postów! Status: <span class="hljs-subst">${postsResponse.status}</span>`</span>
      );
    }
    <span class="hljs-keyword">const</span> posts = <span class="hljs-keyword">await</span> postsResponse.<span class="hljs-title function_">json</span>(); <span class="hljs-comment">// Poczekaj na parsowanie JSON</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Liczba postów użytkownika:"</span>, posts.<span class="hljs-property">length</span>);

    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Wszystkie dane zostały pobrane pomyślnie."</span>);
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-comment">// Obsługa każdego błędu, który wystąpił na dowolnym etapie</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"Wystąpił błąd w funkcji async:"</span>, error.<span class="hljs-property">message</span>);
  } <span class="hljs-keyword">finally</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Operacja pobierania danych zakończona."</span>);
  }
}

<span class="hljs-comment">// Wywołanie funkcji async</span>
<span class="hljs-title function_">pobierzDaneUzytkownikaIPosty</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Kod poza funkcją async nadal się wykonuje..."</span>); <span class="hljs-comment">// Pokazuje asynchroniczność</span>
</code></pre>
<p>Widzisz, jak kod stał się znacznie bardziej liniowy i czytelny? Wygląda to prawie jak tradycyjny kod synchroniczny, mimo że w tle nadal działają Promise i cała magia asynchroniczności.</p>
<h3 id="zwracanie-wartości-i-obsługa-błędów" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#zwracanie-wartości-i-obsługa-błędów">>>></a>Zwracanie wartości i obsługa błędów</h3>
<ul>
<li>
<p><strong>Zwracanie wartości z funkcji <code>async</code></strong>:
Jeśli funkcja <code>async</code> zwraca jakąś wartość, ta wartość jest automatycznie opakowywana w Promise, który zostanie spełniony z tą wartością.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">zwrocLiczbe</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// Możesz też użyć await, np. await Promise.resolve(42);</span>
  <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;
}
<span class="hljs-title function_">zwrocLiczbe</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">val</span>) =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(val)); <span class="hljs-comment">// Wyświetli: 42</span>
</code></pre>
</li>
<li>
<p><strong>Obsługa błędów z <code>try...catch</code></strong>:
Największą zaletą <code>async/await</code> jest to, że pozwala na używanie standardowych bloków <code>try...catch</code> do obsługi błędów w kodzie asynchronicznym. Jeśli Promise, na który czeka <code>await</code>, zostanie odrzucony (rejected), <code>await</code> "rzuci" błąd, który zostanie przechwycony przez blok <code>catch</code>.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">symulujBlad</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> {
      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"Coś poszło nie tak!"</span>)), <span class="hljs-number">1000</span>);
    });
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result); <span class="hljs-comment">// To się nie wykona</span>
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"Złapano błąd:"</span>, error.<span class="hljs-property">message</span>); <span class="hljs-comment">// Wyświetli: Złapano błąd: Coś poszło nie tak!</span>
  }
}
<span class="hljs-title function_">symulujBlad</span>();
</code></pre>
</li>
</ul>
<p><code>async/await</code> to obecnie <strong>najczęściej rekomendowany</strong> sposób pracy z asynchronicznością w JavaScript, ponieważ znacząco poprawia czytelność i łatwość utrzymania kodu, sprawiając, że złożone operacje asynchroniczne stają się bardziej przejrzyste.</p>
<hr>
<h2 id="zadania-do-wykonania-sprawdź-swoją-wiedzę" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#zadania-do-wykonania-sprawdź-swoją-wiedzę">>></a>Zadania do wykonania: Sprawdź swoją wiedzę!</h2>
<p>Czas na praktykę! Rozwiąż te zadania, aby utrwalić to, czego się nauczyłeś/aś. Po każdym zadaniu możesz rozwinąć sekcję <code>Pokaż rozwiązanie</code>, aby sprawdzić swój kod. Powodzenia! 💪</p>
<h3 id="zadanie-1" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#zadanie-1">>>></a>Zadanie 1</h3>
<p>Napisz <strong>funkcję strzałkową</strong>, która przyjmuje dowolną liczbę argumentów numerycznych i zwraca ich sumę. Użyj <strong>rest operatora</strong> do zebrania argumentów.</p>
<details>
<summary>
<span>Pokaż rozwiązanie</span>
</summary>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">sumaWszystkichLiczb</span> = (<span class="hljs-params">...liczby</span>) => {
  <span class="hljs-keyword">return</span> liczby.<span class="hljs-title function_">reduce</span>(
    <span class="hljs-function">(<span class="hljs-params">akumulator, aktualnaLiczba</span>) =></span> akumulator + aktualnaLiczba,
    <span class="hljs-number">0</span>
  );
};

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sumaWszystkichLiczb</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">// Oczekiwany wynik: 6</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sumaWszystkichLiczb</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>)); <span class="hljs-comment">// Oczekiwany wynik: 100</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sumaWszystkichLiczb</span>()); <span class="hljs-comment">// Oczekiwany wynik: 0</span>
</code></pre>
</details>
<hr>
<h3 id="zadanie-2" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#zadanie-2">>>></a>Zadanie 2</h3>
<p>Utwórz obiekt reprezentujący produkt z kluczami: <code>nazwa</code>, <code>cena</code>, <code>dostepny</code>. Następnie użyj <strong>destrukturyzacji obiektu</strong>, aby wyodrębnić te wartości do osobnych zmiennych i wyświetlić je w konsoli. Dodaj również zmienną <code>producent</code> z wartością domyślną "Nieznany", na wypadek gdyby nie było jej w obiekcie.</p>
<details>
<summary>
<span>Pokaż rozwiązanie</span>
</summary>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> produkt = { <span class="hljs-attr">nazwa</span>: <span class="hljs-string">"Książka JS"</span>, <span class="hljs-attr">cena</span>: <span class="hljs-number">49.99</span>, <span class="hljs-attr">dostepny</span>: <span class="hljs-literal">true</span> };

<span class="hljs-keyword">const</span> { nazwa, cena, dostepny, producent = <span class="hljs-string">"Nieznany"</span> } = produkt;

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Nazwa: <span class="hljs-subst">${nazwa}</span>`</span>); <span class="hljs-comment">// Oczekiwany wynik: Nazwa: Książka JS</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Cena: <span class="hljs-subst">${cena}</span> zł`</span>); <span class="hljs-comment">// Oczekiwany wynik: Cena: 49.99 zł</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Dostępny: <span class="hljs-subst">${dostepny}</span>`</span>); <span class="hljs-comment">// Oczekiwany wynik: Dostępny: true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Producent: <span class="hljs-subst">${producent}</span>`</span>); <span class="hljs-comment">// Oczekiwany wynik: Producent: Nieznany</span>
</code></pre>
</details>
<hr>
<h3 id="zadanie-3" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#zadanie-3">>>></a>Zadanie 3</h3>
<p>Stwórz tablicę ulubionych filmów. Następnie użyj <strong>operatora spread</strong> do utworzenia nowej tablicy, która będzie zawierać wszystkie te filmy plus dwa dodatkowe filmy na końcu. Wyświetl nową tablicę w konsoli.</p>
<details>
<summary>
<span>Pokaż rozwiązanie</span>
</summary>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> ulubioneFilmy = [<span class="hljs-string">"Incepcja"</span>, <span class="hljs-string">"Matrix"</span>, <span class="hljs-string">"Interstellar"</span>];

<span class="hljs-keyword">const</span> nowaListaFilmow = [...ulubioneFilmy, <span class="hljs-string">"Pulp Fiction"</span>, <span class="hljs-string">"Forrest Gump"</span>];

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(nowaListaFilmow);
<span class="hljs-comment">// Oczekiwany wynik: ["Incepcja", "Matrix", "Interstellar", "Pulp Fiction", "Forrest Gump"]</span>
</code></pre>
</details>
<hr>
<h3 id="zadanie-4" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#zadanie-4">>>></a>Zadanie 4</h3>
<p>Napisz <strong>funkcję asynchroniczną</strong> o nazwie <code>pobierzWiadomosc</code>, która symuluje pobieranie wiadomości z serwera. Funkcja powinna używać <code>setTimeout</code>, aby po 3 sekundach zwrócić tekst "Wiadomość pobrana!". Użyj <code>async/await</code> do wywołania tej funkcji i wyświetlenia jej wyniku w konsoli. Dodaj również blok <code>try...catch</code> do obsługi potencjalnych błędów.</p>
<details>
<summary>
<span>Pokaż rozwiązanie</span>
</summary>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// Funkcja symulująca pobieranie danych (zwraca Promise)</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">pobierzWiadomoscAPI</span> = (<span class="hljs-params"></span>) => {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> {
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> {
      <span class="hljs-comment">// Możesz zmienić to na reject, aby przetestować obsługę błędów</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() > <span class="hljs-number">0.1</span>) {
        <span class="hljs-comment">// 90% szans na sukces, 10% na błąd</span>
        <span class="hljs-title function_">resolve</span>(<span class="hljs-string">"Wiadomość pobrana pomyślnie!"</span>);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"Błąd podczas pobierania wiadomości!"</span>));
      }
    }, <span class="hljs-number">3000</span>); <span class="hljs-comment">// Symulujemy 3 sekundy oczekiwania</span>
  });
};

<span class="hljs-comment">// Funkcja asynchroniczna używająca async/await</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">pobierzWiadomosc</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Rozpoczynam pobieranie wiadomości..."</span>);
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> wiadomosc = <span class="hljs-keyword">await</span> <span class="hljs-title function_">pobierzWiadomoscAPI</span>(); <span class="hljs-comment">// Czekaj, aż Promise się spełni</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Sukces:"</span>, wiadomosc);
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"Wystąpił błąd:"</span>, error.<span class="hljs-property">message</span>); <span class="hljs-comment">// Złap i wyświetl błąd</span>
  } <span class="hljs-keyword">finally</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Zakończono próbę pobierania wiadomości."</span>);
  }
}

<span class="hljs-comment">// Wywołaj funkcję asynchroniczną</span>
<span class="hljs-title function_">pobierzWiadomosc</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(
  <span class="hljs-string">"Ten tekst wyświetli się natychmiast po uruchomieniu programu, zanim wiadomość zostanie pobrana."</span>
);
</code></pre>
</details>
<hr>
<p>Gratulacje! 🎉 Dotarłeś/aś do końca kursu wprowadzającego w nowoczesny JavaScript. Masz teraz solidne podstawy do dalszego rozwoju. Pamiętaj, że kluczem jest praktyka - im więcej będziesz kodować, tym lepiej zrozumiesz te koncepcje.</p>
<p>Co chciałbyś/chciałabyś zgłębić dalej? Może:</p>
<ul>
<li><strong>Moduły ES6</strong> (import/export)?</li>
<li><strong>Klasy</strong> w JavaScript (obiektowość)?</li>
<li><strong>Metody tablicowe</strong> (map, filter, reduce)?</li>
<li>Głębsze nurkowanie w <strong>asynchroniczność</strong> i Web API?</li>
</ul>
<p>Daj znać! 😊</p></article><div class="container prose"><h2>Quiz: Podstawy nowoczesnego JavaScript</h2><div><p class="font-bold mb-0!">Pytanie <!-- -->1<!-- --> z <!-- -->5</p><div class="prose-p:mt-2"><p>Jaką główną różnicę między <code>let</code> a <code>var</code> podkreśla się w nowoczesnym JavaScript?</p></div><div class="grid grid-flow-row gap-3"><button data-slot="button" class="button button--variant-outline button--size-sm w-full text-left inline-flex justify-start transition-none text-wrap! min-h-min! py-1.5 cursor-pointer">Zakres blokowy (`block scope`) w `let`</button><button data-slot="button" class="button button--variant-outline button--size-sm w-full text-left inline-flex justify-start transition-none text-wrap! min-h-min! py-1.5 cursor-pointer">`var` nie istnieje w nowoczesnym JS</button><button data-slot="button" class="button button--variant-outline button--size-sm w-full text-left inline-flex justify-start transition-none text-wrap! min-h-min! py-1.5 cursor-pointer">`let` nie pozwala na przyjmowanie wartości domyślnej</button><button data-slot="button" class="button button--variant-outline button--size-sm w-full text-left inline-flex justify-start transition-none text-wrap! min-h-min! py-1.5 cursor-pointer">Obie są identyczne</button></div></div></div><div class="container"><p class="button button--variant-secondary button--size-lg w-full p-10 text-wrap flex-wrap h-auto text-center gap-y-4 text-wrap!" data-slot="button">Widzisz jakiś błąd, bądź literówkę? Chcesz coś poprawić?<a href="https://github.com/jakubszpil/jakubszpil.github.io/edit/main/app/content/courses/nowoczesny-javascript.md" target="_blank" rel="noreferrer" data-slot="button" class="button button--variant-link button--size-default">✏️ Przejdź do edycji tego pliku</a></p></div></main><footer class="prose max-w-full border-t"><div class="container flex items-center gap-3 justify-start flex-wrap-reverse lg:justify-between"><p class="xl:text-sm">© <!-- -->2025<a data-slot="button" class="button button--variant-link button--size-sm" href="/" data-discover="true">jakubszpil</a></p><nav class="flex items-center flex-wrap -ml-3"><a data-slot="button" class="button button--variant-link button--size-sm" href="/" data-discover="true">🏠 Strona główna</a><a data-slot="button" class="button button--variant-link button--size-sm" href="/blog" data-discover="true">📝 Blog</a><a data-slot="button" class="button button--variant-link button--size-sm" href="/learning" data-discover="true">🏫 Learning</a><a data-slot="button" class="button button--variant-link button--size-sm" href="/portfolio" data-discover="true">🛠️ Portfolio</a><a data-slot="button" class="button button--variant-link button--size-sm" href="/me" data-discover="true">🙋‍♂️ O mnie</a><a data-slot="button" class="button button--variant-link button--size-sm" href="/search" data-discover="true">🔍 Szukaj</a><a data-slot="button" class="button button--variant-link button--size-sm" href="/handbook" data-discover="true">📋 Handbook</a></nav></div></footer><script>((storageKey2, restoreKey) => {
    if (!window.history.state || !window.history.state.key) {
      let key = Math.random().toString(32).slice(2);
      window.history.replaceState({ key }, "");
    }
    try {
      let positions = JSON.parse(sessionStorage.getItem(storageKey2) || "{}");
      let storedY = positions[restoreKey || window.history.state.key];
      if (typeof storedY === "number") {
        window.scrollTo(0, storedY);
      }
    } catch (error) {
      console.error(error);
      sessionStorage.removeItem(storageKey2);
    }
  })("react-router-scroll-positions", "/learning/nowoczesny-javascript/.default")</script><script>window.__reactRouterContext = {"basename":"/","future":{"v8_middleware":false,"unstable_optimizeDeps":true,"unstable_splitRouteModules":true,"unstable_subResourceIntegrity":false,"unstable_viteEnvironmentApi":true},"routeDiscovery":{"mode":"initial"},"ssr":false,"isSpaMode":false};window.__reactRouterContext.stream = new ReadableStream({start(controller){window.__reactRouterContext.streamController = controller;}}).pipeThrough(new TextEncoderStream());</script><script type="module" async="">import "/assets/manifest-e0891c5e.js";
import * as route0 from "/assets/root-4AKZROQ4.js";
import * as route1 from "/assets/layout-dMgoSrpG.js";
import * as route2 from "/assets/course-details-DLJ6fZBl.js";
  
  window.__reactRouterRouteModules = {"root":route0,"routes/layout":route1,"course-details":route2};

import("/assets/entry.client-D07Jc1yP.js");</script><!--$?--><template id="B:0"></template><!--/$--><script id="_R_">requestAnimationFrame(function(){$RT=performance.now()});</script><div hidden id="S:0"><script>window.__reactRouterContext.streamController.enqueue("[{\"_1\":2,\"_7\":-5,\"_8\":-5},\"loaderData\",{\"_3\":4},\"course-details\",{\"_5\":6},\"v\",\"㞂⁆⁜⁊੠㬸ᧀ蘎䀈໩腈ಠദ̘נ➀㘂婠胶\\uda31䨊循ƺꁩ栀瀂衒偁큈톘ŘꙒ뀦―Ö든ִ찠挀倞準ꨒ㭄ٸ᧍牥쎛✧ᒀ଄経ཆ搛์\\u0013䙌儖ş⃔棊Ы娊฀챺娄儸䭇䩬泿ბ匄岂ꊤ兦䨀耺䰀甲婀偀㌀坌パ呑ₜ깞縡ㅌ牴고렖樾魀⅀ቬጛ⣲吕滒٦㡌3㺄ᵒ㕜ፔ氻⎓\\uda0f₸石茿缭鲀撡딺ꉊᆇ䟐ጡ芌̓闢ࡢᶰꡀྠ㟅䏧㧁ꢆ䐄㓢썣ₐ晘鲚梣፬찀ᑀ考恹ㆰ뢖蒄Ԓ老둀⩹㈖鸤鍃憼鶩鴟둃♟ଊ␑탊䤅\\udaa8偃Ӕ₃むº鉋搈刭曢ᭈฃ 　᤽\\u0016-㞵逘̳稀⫞ᨻỴ떣\\ude80ᚯ╅Ԁ䆠E㺭ᲉӀ\\u0015ᡑ་펉쵢柳灊品䋭樌考찠Ǳ존\\udd4cᦃ撈䀎юⱦ卉耲턴פֿݴ詛荶ঢເẙ甕幠剋闷瞀⋜帨躀䜄ͪL䉳鰉㪾쑧匛䨀㼖챢ਠ㉪荞⠦؃傌ຄ퉠\\u0005\\u0000愆뀺ࡌ묈瀼ဂ匾䧯а섧쨳⸅妒ᰑ血ᅸ䤞煸⃻꓆≉䂨혺ⷰꍋ窐䈋\\ude48㩩 が耎됮㐋ަ倷ꤠ′⸗ʈ쑗蜊ꁑੀ犁堒ᴇ悔उ硐ꠖ١䒜ℚ欑ع鈄\\ude58ᗃ犐\\udc47ψ¾䐛様ガ䫇踢揄ၢ㸧അ䐿ꛣ\\ud800㨈ᝣ筶螮䳈㈀˱攠㾍䃢頄셩ᦇ\\u0006躓鸪唅爌⎠앓鹖嗕丠ᣨ瀩䣀ࡑ❜론ᮦꃝ뻠 頙妀ਝ苓劐╀핔허`致ؘђ甀⌖瘤ᛓ퓭筅偷ധ姑璀\\udda7ꍶ㵷昀뭿勵േ篞琈鵨毶ⵖ耍쎖͏䠸㘝⍘킑䵟䳑ࠒ퀫\\ud898आŚ歲퀢⎹盗횕ꃺ㉹\\ud810秏埴䵜\\u0003谆ࣀዸ팣瓾혌ڢⴊ‒霵쩂䮼映묇፠☝䶞䞯ﺀ痋로卵Ԓ悡꼩벥퍮䡶橈驤২\\u0002‡㴏訒Ԫ躢㲳袬ᑴ椭ʆ㒘ᶿ䊆ꅸ刃뛐᝭\\ud8c5頩蜦೨斈튭\\udd4d솅櫢큗㫮愙忩 Ę⑔ऩ섖꘬窒ఈ슱됈ꦀ߿ગአၦ䧁걠ก늠쉭ˁ⾃Თȸ累⠂ਃᱭ詼瀀้䋲黆ﯷ〯ꀠꎥ䪀泝㎲ʻ靇봀ဦᰂ崼䔈삚℃懴౉쁢ᙰắ᰹\\ud879괅萭瘄砒㇬ヂ麁亩힦ᅍ㭅⨄懇ⓤ糓鿊\\udc61ሓ⤔돌嬣ꀶ࿅阁䕃큋쎁젙蚠쀃珍\\ud944㾄핱흮쁬鮀Ζ࡞䬸丱虽␀̖뢴㳣킃膰油쟢﬎쀯⎌裡隉텷ԣ፠颌\\ud801竖竏Ф柇싖㮅\\ud8aa聢顜䕮閆ୁ㪃ꀼ☄㤃━\\udd88ג퀛䝰봐ሜ瘆㇁ᣉ\\ud833Ⅳ屓邤넆❸찀ᦢ㤇킦⊀๺칁أ䍠줈蒧䢫\\ud840胧䐂ࡊp䁖ἕ硯㖠쥍릥夔豿腗㲢솚픶棕骫唔ᵋ息䳑냕᫣剪甧⚑䠠뀆듓斋瑫늱ꝗ턆Ꟶ乣펙\\udb28楮煮䊰䁊\\udc47꠵憳麛젌㵒쀘搉픅똖Ï⠛˗ꑴ깄훆\\udd86ᡀ鰩䙛ㄗᵓꤍ㪀դᛰ팀蔤晲ᅸ냹㋛뾘僱ꏌ媰匋୪媍⫹狇（脁圫엢즚伙梲㦟췆ﳎȋ乒糊㪻༸䉎ꊭꅶ뛜뫓⯫ۨЏ띷㣀α屪ɭꠁ⊈\\udd90댒邫좍鰁㙈࣐聢寈\\u0010돷ⷚ缐ړ桊䐹ࠄ⹋樅\u2029ӕἒ઀斌䱀쑖젠\\udc40╺挅밃㢖蔫䘔䀪Ɛ푆끰ᖔ⼠렝㶡䭃賹漫쏰섋楔幦憻կ恵誓젙蒠嗀틭᚛뀀䉌ࠁ砷\\u0000廾μ琓\\u0000ई쀁搀ಜ䖈㸏䀇攏䍹鶗\\udc98ਨဂλ莊臀鐐䝴⢂䅣蟦ᵳ᷂Ả詀䑽фȿ䄘䪔属ᶁ‘茧呦ᘃ턉ܬፎ粈冊У⠩ᑉꐌ薑倘⋨봀愌ᆆ〪ӆ倯뱒焚쯠ꈆ쓢⼔웙䰉呯ሃ䀘ኩ둏浓㐞臀묞儤娀㇋↥㑑b盪菚夫⌝鉩櫁♅ᗗ䀄ᕽ쨇퉝扝藨㐐␪Უ槡玆鐆⸄₏썢산엉屍䀘汋襉鰇 ⿂릟趛ԓ픳蚺跢蚐ゴ쫝詧瘈좀⣊씬᪞扏紈野ᑒ粸ደ僇誈吺⒜䅪胤⫄볣羀烎۰츾蜈簼읈紹㖀丅魐È鏝랷し칉㠙ᥴ뉿궴┗긇茤ൃ\\ude7a໺쎩ꈚᎼ䨉롒╎趔σ䅛툩漐䅄힊कࡈ⍉咔ᶆ餌胱퀊漰瘖犓䨋硧ᎂᲛ髁๦ṭⰹ\\u0018ܔ⎄瑀㌹㝉ꧤᩳ㳐䊊͜䆶쁎ᧈփ\\udc53ꅅ㐨쏍≚瘀ੲ忏ᝲ뾆뙊䗫畏脬漒꼤̺繭䀃ƅခ蟑䊔芫⪁耐˴ᝐ⃨ሄ샾ᆃ瀢褁ꗬ뫹갉갆渉଱垆袡ꮐ耝헦瀝鿸ᯁ灞耆≧鲉亭\\ud80a뛞폡쐧筀뜝㦧ᶟ頇먀呒ᖽ當․\\u0019휀旆ﳶ耆ଫf뉧2苆\\u0001䢢넩쿞ꨩ홴跱鏖봴鵙㋎棷ċᥳ将婇ﴆ鯃셏⠓聧匞᠛ゥ㒆鯆啀滤㴣ჱ\\ud8c3뜴⻠땻ឞீä′騹䀘᥯㈺䧳⏸擴␽남ି帼神௨拽⨀ㄧ訉䄊㔆쒝䐷⿊胃ౙ쇁㊘괳ɠᩉ\\udca1ﭩ김㡟鈈͞ᎁ㾃솿蟻或難侮勏본䞥叛臁ℕ毐빁頝똀䬡茈घ딝ġ詩ᴀ憯蹺澈솶踠ᰨ⩘㱫鞡䉄ꅀᠧ倐ㄆ䄤䆐䖡∜ᄥ膁큈쎜⛩䬀୐㈃愥䠯㱀儏肤㏃욼쇄۰砡艠哺퀰硘峻쮂塚滣킟䉯⮀ᰭ衋⒪搋㸋艐瞪蘵Іⶐ褞秺㬇አ羅Ҳ〼竸┣枀䭪ὃ령ɵװ㡓虐இ༦৐߁꼏螠齻я䉄䷪㐉ư㵡砢䖀㉄ꀹƘ瘄塌菱縄\\udba1ԗ⿱䐧蛹㼻＾灍ᙸؾ⎟ꪑ〛Ѐ✷ꪄ笄;၆茈ὀ䰝섧馒턭ʈ俰霽πᑋ䤞爀꫒섃硗ⱙ袆蒠飅搞栌긁礐䂬嫄䎠␢﮻무斆融萐䠂\\udbae슚軸₧蟠눁끦﫻㗻蚀䍔♀Ⱞ篧蹻䱈酧鏃〾䨜b쒁珨ឆøᐦ稲␗騧汗툦轲怲餖\\u0002䠼Ф肙膆눁Ვ뢌鷆꼥䩢毂㶍䓓숅ᯭ뤀㦒曠懠翄瑠◂䯂ꀔ녧齫鈵椤쉈튖ὀ⑆霥谚鏄株簹Ț朤≒삵ࠡ䱷ꣳ醧쉷★ꝓ⦋ꝭ먡䬟硪䜐뉌☠级꒚戤钟祦ꍉ쉸旚䤃褵ඥ멷썊沧쩸稪涸ᰦ엘`쐐䟝꼱往愁똁䐛ݺ늙陁㫌竻ነ䗃곆䱤앗ꏛ␴䋄ᬈ陲䈖㟲堅昀ហࡀᎬ㦛㰺人撴䏉ޒㅛ聹펮䅄௑䞽䆓잡﨧駺多磷譑林耏郸딕꒞㬸讧㨈㜺㨋뫋ஂ⦋蒹〔렛貺鬼먫늺ꮗڹᴶ맂ẹ﹜룷Ģ鮓Ġ►\\ud860▮䱹잂穸杸牺穁㛹ṣ斛鞅⮹页租ሃ힘议㍻\\udd18覷麫圇磹᝻脆ᘀ敋ṉ穙ꆆ辩ꎏ龺稀磶❃阬⁕蕃撬₊โ趈ൻ깴䉟⦠\\ud81d˞ਢ\\ud933䙚蜫\\u000e㈀㦺∠嫀候쏖᜖鸭ភ᧫쎨䉱ể咃饞萉砈⁰訓퀕䇴㪣㐅䁀鬊레邤᠀氼ⓙ接梍郫醬ꋙ䩁䐾陲ẋ᤾஀芕쨕䤕祽礞蓨㞅យ宸格὚ᝮ獻趄讃鰳顩垃㰀ꑘ맑料膰 言砋\u003cઠ값銔੩〾欆墚얶勓ꡣ⹪凐⤀斡ָ耇㥳趩\\ude40뭺Ⴘ王ᯥ腹쀫銸࠾뫮⟥쮀ᚐ⚻Ů렒זᮗ徃ᖭ䊦䞬힡向㐯픭䫗＋먑箻ĥ鄱忔㆙얈鈑⵪᏿㍺感몆㼖▬䃨↗連衐飂ꀴ浸斮投嗨䈣楨褞㹕袉垕泓랗遘꥔ᙃ䶒倕哶꨺쐬珕唁縦͉₶᰷䊁鵖쥇ᆑ㘣鰄⍐⇚ࠈ⚃꼱奏ᣈຩ쮎轫夀썙輷ﴛאַ默ᶣɔ汓ꐊ膉鰙㸬㣈䰘뤴Ⳣꈀꖠ᮴㞬⡜䔫㞸햣䥢♠쀲ᆀ訊ዮ먒\\ud8a7㶒렺⊌✉訪ᭁȔḘ蠀޻箾넶ꕄ䂸諂踀䩳碙袭\\\\┗脣뜄ీ砦茈ܐ⭒뚇䕵됧焸⡘掘௹痪㰁삑ᆃ甠\\udadb秂ՃѢ쐫ꔄ᧩㸟垛ᷘ模䐷孼ᆀ⅗钇慀\\udea7뙰멂༹신㹂䤙σꫳ妀琥鬷瘧狨˱䐤ě甹䲾冗ܹ茝厠㬳ⲛ区ኁ䊨ꡜ車挊⩵㕴鲙잀잊虘㔂画鐪ꬨጌ⣥☀鐏넷꘍ⴎ瑓ါ犸끃⟓瘩⪐浪僘ꮣ㋠᠚ੵ⛢渦ΐ儼듐኶靷䎗慃혾뛤൶郎෠헧謲⤐텶⩰㫑ツྃK탥퍺ᤨ죍⢰숣냗퉰瀸㺀戮䅼Ἄ㈢띶傌裶럫悳䣚踠쒨댿ನ》⤍⪼⥐免ࡀ濉檹膫๵欞貄냑轶এ됗\\ud9b6뒲퀃꧁⍶蠳甠⤲쐲\\ud8a9朂뜣和‥⣓㊫丘턠烗්脠됊닁ⱏ銪䰀⚻䍉㛳⦦ͺ뛲\\b‧덎밀少䈠៩㈈ޝ眏壩쌨ㆲ鬔䊸쵏ӳ࿔\\udb0e㓱輴쪛侘Ⱂ倜䳴\\udf4c೐캌怤콌쑩쀜캘ˎ瀗뤰૎몚챬᪪Ʞ㸗莘탻ጩ霳䇡ᕷ恳勹Է㟍⺷즁ᢣＦቛ惁譤둥瑻礉㕟ㅷ㸒寮䅶䲸餁㼧଒⚌낱੃ዀ탃鋠⡚羾聢셵๸袉뚚샙䬲∶q봇형ᆅ寡䈩掅躵즹ˮ⁐쐟ጄ㗃䜕舮ᢉ辁唛緶䵴픱骊搽ꗎˢ잦剻퓞囕헭嗤ᵤ묝知鵓핝窺\\udd50ᓫꠔ繑몽吗鮬ᐂ涺껳薭倕꿳趬垔】栶侌ʚퟨ츬泪郘襑几텽㟐㠯⨵〉웼䏵䋞嗦ﺩ䋻镯倯옿䗲鍵䤗琑듕䷠\\ude8f䯴賣慤⽙䋚㩁᭳Ｒ턨࢐ꎏ운督꺤⸢윷쵁꾮塔\\uda8e혠ꐚ胞鞂爿ዦ兵䎳⣷櫑莈‰膴㵯⠹ྭㄫ銺䀘棼㎷걱佔䎢ﻠ쬵芞츭Ѐ쮞침軌㔞㟭윷ꌁ셔犁䖄*鐛㚧䮒链胸㘯໽웁헵耽痨鎚쥝而꯯뻝偆瑳㸰肓鴁懌꓎団囒ㇱ쵮房歸啙洶鸞盕抯挿㽮⁽婰ꔜ赁脵衘今鱎ꫴ妀會ꨂ莜퐯ᾎ샋介\\ud9ce㠐ⱘ晅蕮톟덬홳千鱮勇⶘Ꝇ䍅癍㝗ᅭḁ䕅踉켮䕎ं\\ud9d8覝ꀀ졀똠̡耍뙊刖\\udc5e漦틟솥죹䋵芹঱ゃ鲪湫硔姴ᥟ롶ࢱ\\udb40쐙釞掲Ǵᷮ輑↜쟮㍋⯓妀b骃拵렼섗⃨⨁맴獡Њ痦䄛\\udc30썭졁報ウ蹋鰥倜ᢺ截γ뇷혡\\udc62螟篡\\ude84鴳䅔选ḡ픜ⅉ阧\\udf1d蠱\\uddf1㇌족褗\\uda7fꥎ倘¸㏣嗢ᤃ㲤᠚㰭䟔䭙ᇁ命쁺渜齡觝滪䧢⼶쓔瘕㻏鐯秌Ⳙ鰭컬ႍ풞苛⺁琲휊킷䋱牞ℚ嘶芹鄹۳〮ₘ꩖馭A拢쀜㘯ꊙ릓䭧ࠗ救뽣穃뎇ᅸ᫘漆婙ὀ拝鳙缚彼∙叩뻴롂뮢ݗ鏆똔焉镂킭䄩莑㧂鯚嗴鳬患≻挢ꅷⶐⱁ桏嗱ꦓ咤庯榑獥媙㝘䟵㵘吮ꌶꠊ൧暖ﴷ䫭释쀔\\udc9b懥㶶킞쩐ﶣ揷㽽\\udabf呞긌巑捉뷡胵혋琳淖쭮觷겎ᴷ踀쭓Ú쥵ⵌⓒ⨐⣓쮕쩃괦퀠젨탲潶㗒都폟︪㿧僽⯿쓶챨쟑㿆ᢤう๑꿤፜厨쉘勇ꔿ⤙䧔ᖋ‟쀢ꄿ鿼ीÎꇺݔ뿴聒䳶抓⸚笚䣉菩ꛩꒀꈦ䀓冎\\udab0쬎鰆乗Ꮣ⻵ᅄɕ쨫흐䃼\\uddfe㐳ゥ䀃░猏웡\\t귑쀟荡ꆄ\\ud916缦픩ൠ赿㢛룄ᒸࠨፍ⎊\\uda7dɤ킰ʀ︦ǝ腬ሁ見퀛㊥ਂ瀐팕߬쉸堡뾆톉䉀噀⌓\\u0017㟩ꃍ虦㍩큆ኀ禄턋৩㡂ྍїꁏዝ〉驰㓁蠶偨腔ᷝ㪈ꑌ⸖恳齁킁끾⃃諁礖鰄ࣔ㖻㆝抱斺๐䰕덈߈싾鉶씘䄅塒⠿ᐣʨఌ毈ⱬꥄ␔刓〧優貦䡺唐塯千䐂킯ꆶ蝀쁢ി佃꾄䚦ⵃ䋆₝﬍ᵔ䔄프쉼≲唙瀽ᡳ໺Ⓟ瑨탱惄㕁萎⁴酈Ṁ쨄쏚腅≞૰ن礸要ṥँ尺瞺䐼ꄞ㇠撩妏샟ᣣღ∋墨싪滲栅㐂ꊉꪱ搚냔(メ㬶䦪䷒憠먂ᘖᒴƯⅠ塚らà߂薄쓽꥓㊄䀺⇦ඈ斃턟僔䈏ᤀ큅⑈\\u0014䍠ᴃ뎙慎ૡ뭁穢鮸⟦斶餼ࢹ穰깒꣄녟♈-鈝媂좲㼋پࡳ쁘扈ቿ➄퀯蠯䫲魑갟⟱坛讐ჵ꧕缤᭿쨁䭜ƴ窇걃滵ホ굋㊋᪀쬪꣭馀ﯥ聡祿≾絅쁝囗㱐縊梪Π䊈⃓わ츘쀊섘ɲ茀豢々ē胑䦋ꌸ佀㍅狇卆깣새ቀࠋ嗠\\uda00帤Ა캐ᐲ앁Բ㍀通堶ൌη㈁᡻ᴕ縰陙捨Ā܏쐶屰ꈆᷥꈄɺ預磝ԇ։킆\\uda1a苬ᑖ蘗ठ葌①۱碙µ푰஁㠁䁍͙䐐琁ꌳ뷈ణඳᰟ窻°ـ㰂ᔙ㡶ʶ운\\ud9d5ྙᩙ蘿ﱆ⅐◤ᅍ棭꧚㫂ຍ粳ꏝᜮ均鵃혷厺랢珺☊膋芽률鲐棇炉㳶⍔俀䆦ຉ젠鱳᎐銍㑨⢍ၳ蒉ῢ㋎렁샱㼱섐ꠁ琫ᠼ滅\\ud88b规앢ᮉ절脂퓀ḇ\\ude8dⴍ櫏懻짖뚈댐꨼劁阬퇁߀唒瀣戴飋Ⴥⶌ\\ud86f閗∉꒙萵諸율ⅶ崱ⴔ髽⡻七熆ፐ㪠㐟拐隖驱瀹醰߁ᜒञ隫ꡱ큨猁郤ْ뀜ꇎ෭Ⴃ랞肺君Ɣ宅敞鴔颧Ꭶ䏽අ怚呀㕙஠쁢る蜲㕁ᆄ뀫邃弦ȱ鄠꒨䷉䬒牳蚄섑䑗턆ȃఒ새਄䠨셅恈兽͘키쀰Ü斈돹ᑕ䬴ৈ刀j瀣匚ꘌ輐凑⸙惜쟸褉踥舒ַᛜ΁暂꘥೙郓㓈䟽\\udb14ፈ達튤᧔㦤ꠟ憥쟚栨췡ਃ銓᭩敂娹팮鍴蚥⛗腠觱덑故ࢌ᪈␙老틠Წ梚져饐ദ砳暚塃茭⿩퐴톓﷨歴憄괣ﺬ캆㐩ㄞ풃᫬싁偆䰉ᦀ䖇툷䫜邲夒ⳇ꜅⧉貅㐿䃐䈢堣䇉\\ude87씜ْ㶪匨ℸڌ꫍㨑⃺෴뾠挮ᄘ쐺傂೘晈㒱缢솆ڙ刘匞؂쳘簲㚝\\ud862䟨ᤙ䭆ꙷ䌺輄㑱\\ude1d갳૨済㰉퐀\\u0010㥰*植❏в兛㓾壍ўﰄᾌ：ጦᇔ쩶刣즖롊曝ᯙ峍ꔘ㎝鼀걋묨㥔춆塲뺉呩⁌ၡꐴ숿㍫頬鱄訯ᄆ䜖摳䀮壁틌왽툕鈘肪蓮桪쨤ಅ庒㈀뇋脁蔇皝耹Ⅼ얣朵Ā챑땂鹊峺ㅘ跋派쁗侈䠣䌦만콆᫒ᆞ뉞й淊꠹պሀߤ\\uda91肓ꇮ淑떋೰蓣㽾藎ၱ猖謈鳥霢⛒મ忐従ⳤᓍ㮰껋蜐ટ鬠뻦ブ᧳췄窃䞕鍕툿␅劋ᄞ뇾惲᥹᤮䳞꘨㳱詍굷蓏\\udbb0⛋䄓ꇤ뤰阽⑿潹泮⵶ី迡蔔꺑呈縗퍕擠ᑨ닂ꀝ頠ਯḟ営㥰䂆阜ꑝ⡝ꨨ쀢碤䒀ⷵﮔ⳺⮜\\u0010᜕¼ꕱモ䀌檨ꣀ렬〗奜ࠥא즢狪∭塒Г\\ud9d0ոु澀ꆍ淈䔠뢂⿫☁轧朖낷쁤鉎究䡯䄂碀䴀䰩Ӥ㻴\\udee3Ⅱ媚앏튦㓊鶍徇炩Øƪ䛽ߥ伨␳襑↉呞䩚赾ᯇᡟ鲏赂眩킛棝꨾彪躏疞቎ꏹ䈧첲辺ꁭ⺬ᬊ▛誉彔₲ꌐ阢膕␞ⱈ\\ud893飞隈ꬤ䠐쪄ⷂ쟆ﳂ뙨햞끰ꉂᓤ눴髚ꕢ锞ڨ⑀逊‏腼徕䒬彽苳ᘠ쪎륋ተ참\\udea5踢ꂾ䠈㛁ኒ㔇웄鶼܀␘आ๬皻춒▾佹犁沂쀍芷\\udb0c頃祤⫬꬐ࠓ븻䤹Њ끕뀃瘢酙㡺렇贍ꥂ쒵᪱섕ᖢ圚ᔪӬ눴鋺袍턊嵘۰䀑蘤封᠇퀹ꏓ䷼쾄ಂꇦ٤沰畗踬⭢扈ᄞ⓱΀㐈교䶕䑘䢰ꑮ⒌阪ꑈ켹ㆴ᠈뎇㼑蔩ۿ䑘꒢併劋拠뽦邔뺐悩쾬婤寛ꀐ馈뎂⢁墆퀂䉄黬䋴祶⬰\\uda7a⋒纰侵憀쇇钱ᄼꂪ엤Е▹坩嵓럧ࣼ᪴橺졈委쬇甤煽侲徉ꜘ옐ϴ่륔䦫叴鼹ᛣ䱶嗲偙푕埼@߅ᖓ㉥黼ｧ洷椵Ǝ縨ꁕ\\udabc斠\\udf35䓍虖썺䥀亠ႆ螅똨ณ裸诨㨰憞팿庞㳃倔䂜쟈Ꮺಀ줺耈ក퐇\\udd66㎗嘴콤悳ᦇꪅ៲佛荜᭓㒅尰谦ꮛ䱼䟇Ἁ쑩挈ᅒ鼀睿萌୵䔅\\udd6a࢈Ƴ䰵麣ꥲ쵐痝⋥슁穲툲ﵴꑡꅀ⢎㢋倁苽㘐䛠崗冺賘떭䞰䆏虁祢軗烇쑣昛ꦑ窦ꘈ⯨ன⹝ƪ䟕紙썽忐캖瓢ᐁ꜍뒭蠵ᒁ鷘锨䓫ौ燪묺Ƿ쟩䱨퍈⊼斦\\ud817쪑咗춦䍲⦚裪ꡀ秌୵孺耷\\udea7懝脳毪畍⌰ꌱ꣡㳊喝趣ƖꪛἬ솬沰䭋楖ꪝ흧ᔄꎃ⿣帒ๆₗ蟁㗭צ︖눉⅄ॷȟꥨ循᥆蒱﫽욵䜕ᩄ쬋地ᕾΐ浖ﱗ୴쯔῅ꦠ㟭䀚ო粬偟⵵慬\\udb5f졨펺Ꞃใ聰溶樛㾛瑬᪞먭\\ud8ca孠ꠒ힦꒴ᦻ慆测䛱䳝೪朜㟵﵀ក錚⬷覎☍畈畘䛘錑놤ݩⰓ唢଄፪杄긘ꂫ盪皳馩몙甕ꀰᭀ킀瀶蠒ൈ憃槚玜譎ꎲ鯹✠썺鬠忦븆䷢↽換ﻖꩧ됾밍⾭爠뀬\\udd4c弴㎦ⴁ漄嗫Ɨʐ듭ꘁ筩䑹㭐Ờ섀胯浽䝂㧖夸⤹㝭識멙\\udba6萕ꖵ졩춺♳箘⺊剳㗹潅쭳ﲓࡖ⺼ﺝ䅩櫪Ö፳鏭늭ᣩ砉\\udb08啦赴\\ud9bb푴瑸㰻與鄪ǣ镝깇笨ࡘᴄꮷ鴉䤀ꖅၢ虛⇤琫連㔸찤뜫隢庿潸ᒌ륟刮焮䄯⩓䵀ŗ淍ᔳ耲̲爁勜ȣꅜ탦ࠂ䭛\\ud8d0圠ꎦ䈿Ⲡᚴⱝ刄䁼Ⰰ\\udd94⠐遲廞ⶸ姉啄㜋帏웖鑸뫺ꔶ䲆⧍霠⫀ ꜣ뻡㫇骏埓吾鬄䥉쮔ຐ⢂␞烁䂂䋥꣆玈壴衏ₒ⁨⼡稉⃉艪ᘘꅼ琣셽ୟ諒랎႘쫱䄲﯉䲾퇏閙凕限䓯夛颉ﺱʏꎖ埨絈㆝᛿椄ﾝⅪଈ䅂蔆ê葘‘瀏閚ﱐ᠐냋఍飷熈剔잣？請휡ᨍ⡙یᚸ錇렧ꅸꘘ嘃ꘗ⶟ᐒ췁鈊瀛ꅀ귣ᩔꅗ⹜͉觴넁ꢦ肱ౢ千쎇뺑爩癙㬢⑞艔봠㨇幊螰੢㝅或⑅絪ꔁ㎁龃驖ꥩ\\u00071ᎋ杈䰪惀ꙭ簁숋很嶉ቀ⋊ꑈ赞넙輴緄\\uda0d䂢Ӽ鸮ᠣ釞ѡޖ㽉붒쐕泡秪聣ⅶ苠佢䂲ৱ氠㞀ᠵ꾻뻳㰈쀐ꔜ鿥⍴밶Ú誂\\udd41炵⼂筊멘ꢐȡ袠帅碵삟ᜤ꠆죷កﻑြ靡⧑\\ud957㑄햖鄫̯務䟕썭饩谈ᙣ쟲мᖏ䳇年漇菜栠쬜ᬫ巋楛夸ᤧ໣鯇긱맯䜠눥胀쇕ᛔ⣑୙௡휴Ϭެ푵昮ࢻ⪰䴎倞ᎊ腈ᒔ픯˞۰灎ؚ荢舸ᑫ醯큞荸鎑焴踞굡猿ჺก肨祉ЩⳠᨳ遨⇩즾⵼\\uda8a胔ꖴ٢ͪ䚻侙罅ꋤڼᐵ﹐耭\\u0002偠⯺Ћ훒矛⧤錍퓀ᮎḘ⳦Ꮆ秖즳䋓䴌ꇣ⃷傰؄퀝䤳槡앃硲莃䦖䚧쾕ꧼ老巓ൠ﵆묕\\ud954ⷙ᠆娎풝䧈⺒鳌]㐹ᐙ珖ꏺ⬁꙳\\ud917䶴ﳼ쿿呀ⴅ㓢퇍ㆮ촷ⷐ衁桚旑몈떫ਲ਼谁賜ǻ鍮뮦຤奩㜡暃〄馵㩰䚜젰㑠烃噫㵇카蜲挾䐱豺적蕴≁➳\\ud870뀍觋鍚직䑯㝧망뛊듉졻㖹왰玿ퟑ㦔촾ᐹ嫬乲牫쩮Ꞑ⹻ⷃ䌛頁》媙⌋䇍\\udbf6靌돌ﰊঈ苔ՠꊹ㈎깃9饤\\ud9b4獢첡柦탊駙챭\\ud80b䮛苌㩖酦ꉢ⹄ꎐ단㙪猐꒜鱸ꃗ\\ud867虨᥏⋽ܑ鼳ⳣ蝨얠㓱嬐氥陓抏ᵡĸҗ㆜烯﨡曳휣볧닸⿠殂믝䯖챗簐\\r☐爃⠂좩௨㪺弶ֈ⽶ह扙䠀©爉б䃁悘\\ud83c᚝㮮텶ꅨ䇁氉뭧ᄙ\\ud9ca봅ٚ㋎脈뜼跏༬珢첲쾀沲л⽒⻘ኑ峁やꆵퟔᎈ뛞✅\\udc20츔氉렆욚೚ꍨ쯟ҍᝤ蛩晻얈蜽녰脶\\udc31ஸᯐ뤶胓ꐒ餆蕟憓\\ud845쯀㙐섖ৰ嵧㈊෉ꖪ홖Ȉ⠈ை贇喝嗛蛭ᜤ損㨡얎㜪擆ձೈ觓ᒠѐ␐ఏ偍䍁಄흅며⋹誓㒚ࠝ⟉㍙\\udaa7쩼髓犦迠얡س麛࠷Ꟁ譵﷐爟䂶䒤⡓䌿ۋ䶟⑋媟而ീ㻍괏巌쀊\\u0006䭮ᳪ蘊⣰슈ⴁ렏ᙩ᭓皛톻ࣚ憀ꠒ瑬\\udba6ﰱ쭥춬ꊳ暛苙쨋ꃕ\\udf8c㆖̭\\u0016ﴶ季鑅洋熛쳛곁ㆩ輥ꔄꕽ┰䇜웧鰝垾壞뙢鞭㾍쉯們龌씷\\udf36ⷶ氳榛㓢捪뜹뷍ꛑ寂\\ud8f6喹ⷸ祄虛峐\\udadb䂙⮦ᾀ焄닏鏭೉凌菨ś囄핰濭펁୲孜滗ᚉ瞅焭᫮싍㬠艭፱숪㽾㦏\\ude72卖’麶䳳䇚┗魘ᵣ梤಺픃㡍\\ud8f3헰颲鎏嵈ᬢ䄆츰ᣝ阂乩㷟呟瞗耽铛넡仝\\udcb5囶払鐨沃쨝쳌蒹࿦䬂롿燲탍依쑄퐈臨鳻긪굓冚衊\\uda0b큜㗕삃頫颅Ȕ퉈ꎈ܁咟ヸ耸➈蠕抦搊笆籝陳憨Ằ溢ទ脵嵕鷩됙謭晕韌Ʒ筢孎ᘈ镆᠞最罖ª螯꫱Ȱ츧\\udf1a뱮萌ᘓᢨ䨴⟼ٵ淪쐔ⲓ䜋෨⁷쑋ㅹ貞ꕃŘ逑礓ꫨꮠᦑ혣ꥯ㭚쵂䀚唻◵섓獤뼐\\u0001ꅺ氠死往믅쨇⧕쏕㎵ნ㾟殏뵬隺縓袡퍑鈬灖⒀˛㧈\\udb44䷝텝悵ⅹ잗搃컚雜켠Ҁᜑ荟䁐౺뉭ᅯ嬊殉掍缍꺨磸䤹䀶俹ꯗ୺敀⃘츷詛⎥鵨\\udd0e䀝﷭㝮龵ﴄǗ檩묃떸ᣩ稆쐶뛟韨ɥ鳧綷䛴Ֆ\\ud842卌鏤ɡ稧峩䭁‭Ģজ妪殩윜캞둂鴴嚇駢ഫ뤓ᴶ〗ໂώᑐ鲎藮썓ꋩ贸ᐽǋ㋓墎ຆ롣蛢浽扠➣Ҋ٦헎Ꙙ櫩텀摪ꙻ⭧㨂멩䊐뉼鱮橸机鴙슺鶿ᘐΙ槈瘄훷怛㋹꭬鲖퍘벀暖\\uda7f妝澞놝퀨⹘坛ㆅ좭錪묱孖ю訃駽䷦楝蹏붮ￏ쭓ꂜ펐櫠ڧ⺊廓✡⌗뢴⒮멯嬤忄攋ղ䁳⺩膒쩦鴖쏨櫌攑痒蹮섈젻닁⅖꒨漷⻌굾\\ud9c4ꐆ\\ude5c䁁स黮땜薐桌릛懌镋ीں氌ꟑ͸厞\\ude0eℊ씛삽瀞鏟\\udb4e俶唞싮哈뙅꿎坰䯼㿽姡⢯䁾㴑墈ກ⋙恈䍅޹名蹡⧲\\udca3疺۶㴽꽚ᱯ홞衞붝钐浻䥌₲⭱\\udcdd➓뷃ር\\ud945䭵儘裔劷쓵䢊泌⺑䳜抙슟Ἣ댥聝댴ᒢ㼙\\udd25䓢⮡쬔⻥⋍蠅ꃯᰮ뮑\\udc6d호稙莈壂윽⬪윅빼䌝桨㇣⭡뇑ሪ⺂࿘軫适ḧꡌ⛸㬸瓩쎬虤ឭ켉ሱ⧞踵䐇뻈뒵北\\udeb0蹰ና禩럍Ἅ\\uddcd考⏏ۥ巊塂醨྇慠ꈼ钻戰劂턙㜝\\udc98왮蝱믗க욷힕〣굇떱턳\\udf6d줒뭾䓈⩑㢃㑎綛뜉悅켞酞믱ℬ▅戨໗튔　ꍣ⸜冃ᜮẓˎ㸹㠌둲˄暀윳⁛砷෧ῴ娮頦芣ජ뎸뭠堁쀢彛ꙙঙ8堤⑦ꆄ腨绸㫰뤕䤏齫攗╩蛜㙂ש뀀ॵ獟㸖䦌Ꮜ᥈ ໘௫者෨ѠӵĶ榫퍟궈퟾悅סּ浺陥忥馹荮闰쉊竍浛흲븕悯ਜ਼䗄曼뀨ᯭ쭵縅侰ﶁ랉ꄾ鬬≅\\udbc0臉诗몾倄露쥂찋饻玣鲂蓧꠭諛⣖⎽ꫧ㧄夞磦ꋳ័忍䳮믩癙琬㙝팳鞲੿澱栆珯楜ꅲ徏佅臖ㅤ욨黖塰焽Რ逸쒅與ꉰ㺨褆蝲筞⨔랼沭꓁㯘彡锥뒽綮\\udd5a寺㱞㒷溠۝Ꮷ棹蛐璇赀꡽ײַὁං➡ྟ됫샽믘㿂턏欝磕ퟟ얗氾罧꺗Ⱪ蛦㼤㕀溰㱃螢䁄ሼ੬᱐멍져ﱅ샫쵏얿瓰⼛䇎褀佈퉊帠턯裰鈪往ᅌ暞㭯鞆鮋著弿쯊ꍺ袗ᴸߣ⸡ᮍ쥴䕺嵑廁渗큕ᣝ荟蕾裡늵矠ꆙ癑㋾䆿ޔ忣翌ᵸ阀ᤋᅧឈ向䷏\\ude67͠嘉㠋Їᘄ悸冑ᠢ䇞➦⩾哟콕஧廵䀄鱗ៈ홝䀑\\udf98ӏꚿ鷺뿃䊻팯ᗵ⺏疄栮篖壶쁟ꙇꏵ⮤夼ꋲ迱﷋䃽俙矙틹螽쮶䄋︘㋾᰷࿴龟ᐩ栧眾耩穕ɀ═她采ꀥ偆ஏ茊遊燢\\udeb7목肞疻⁥蒘鹳⢶魮쬨\\udb83풋\\ud9e0ᱮᲞ䐘屧渊Ī竜満滶⮻廥㞆\\udc9dꆞ求钢澗芦猄է訞呪\\ud9ed螕粏Ɩర᭨ᲈ彃連⣪ꬄ∞\\udbd9⼍Ɑm锜ሪ툈ᡬ烪꼆⒁眩捍蘈㙶㡶ꩿኦ为궢⺴朗擲➴가⮎氺퀍ૃⳐ鏼幀ࠍ뜴싡禾残Ꚉ̹돦숞Үଆꤌ๘◣讥倁׺씟딲甊怔숑݇ꗐ鋋抌낲⻃窨ⱗꆶ敺믫궿︵穸ᶷĀ嘂㠒ᤃ井խ榞饁ꠀ懈몠빅杖ᘐ䕁혁퐐」䆝Ըዐᵜ㐟꾂\\udec5Ӄ方ꤞ箚㒃䁯Ḗ≷ꜷ聸傸೪龐칋䋂胐牒뮁♂ᐅ『הᅷ꘲寸꟢팒븙﮲ꪾ㐚羨셅頻堄⢡ᐟ䮈몀ﭯ蠾睸뾇⻙零耰甀휇辥️׺쪏떚站ퟡ枹븭瀥ࠟ豴李슋숚ڑͣ㎾濠璴⸞視ဆꉁ彀㐝め耎ǵι崋䐕 쁦茇仁딅㠛ﾲ囿ײַӗ넚軻ꈙ䐉岫뉠¦ꌡꖂꦧ羀᪇ދ껰䧁篺ᖯ섄쉫⩈嵞肆ᯫ灶뺔⠄ᤴ㗴Ꚃ埬の䆖ৗْ걃上༊胀ꥸꭕ׬麺簌삩䰘꧴覈䣁ｊ\\ud812끎틑ᷘᄡ꤆齎蠖Յₐ䡁鵃ﰝや⃂͇즰䃀\\udb04偔䃻ݛ⨨䬺윆᎔ꅙ﨟垡ꠀ益ꀓআᾈ㦲첇ꫯﾝ쇣馪Ṭⱁ䵣舚﹵﨔գ㤀෸\\udf9e䋈蔡蝾䴩炫\\udf88烽豈諅ჾ匇巂ꀘﻍњ滯닞ꬆ䂃ꀜ︭ɿ¡扠劀졯䆥苆ᲅ茮睨\\udde4顫ﻟޜጨ巎줆⨓徕帗랠ᤅ㰝삋쇉力ᢘ穾銄癪顓\\udeb2藎ᇐ瑡և䟬࡙ښභ༢斅耜ꚾ 䘁䠨胚헃킯麓ƨټ恝◖昃嵦w姆蒔땢ค㺉﨑灢歺▆菣ꔠ효ჷ婬䡵ꨞ鬏퀟ӈꫵ꣒Ȯ㈓퉀줲湲衿괄靄Ꙃꀗ蓇ဗఱࣄ╀䈃줟䢋ዀ⺼֐籋㠆ǃ\\ud861▀䍮碡㛫蒙ćᨐἽ褁\\uddbb逖ǔ䡆쇄佄䧡쑓詃ጌ䂑邑䤘褝䄘釰㮬䤤囄鰘焫넹냻ႇѱ঑꜑뢩焑᎙ḱᔜ輓ⱋ摛쒛ቼ䥻ꡊొ됗釭◄∄٩萁琡䤮췲ꇀﰸ稦걢冠ই蕀쌡蠾̿ꩢ࿮ꒃ蕏ﮍ₀箤ꅧ⭼渀蜈ﴯ愷芏䳤峬⍳㔛쑄퀢⇴䆧⸀뢩쀅蠻愬⇎ꆊ㴠ሦ䪟琍䑱玑왅䔘둉쐁莁襊㉅ৢ㶦온ᨶ늑叛ń֬꾁餁萛鱫ꑶ擺䜭ោ䭑ꭄ་뀖버렰ᗁ뎑⋓甚焋兖ꬽቒ蕌Ꟛ蒠8郺쓸鏍즻諴큀製⇢牃磊㬽빅კʁ졹炭겗䘑ꃆ袌䧨抳ሩ쀬䁝䑹ጚ㺑ڲ⺋쎪肑⤱耼Θ恡䇮디栖𥉉ᅂ頂\\u0003솸\\u0002㻭剡⧉蓡ꉢํ턧턞䚠҉鮸⳱돏윑橲扙悂ࢦ༂ٮ뢬\\ude73낷౒赖숁劮똅拰⋐ۥ⽜뵪⬚䐫⫋징쨛둰嘸藧䃹䑹릁踸궪ꦚ\\udaea餺ቲ⁐窂藦ᾋ컏鯎\\udf41К臫᫡ꢻ踕㾉⁰Ņਛꮀꇸ屎胜ﭛⱰꘂ뻄돧溬陡앾ឭ꣚퀠ꐍꂉzઆ์Ј㨈霞떍䐢≃⹰ᾠ␃望⾈ꄛ蒗渨盡頪뀉勇ᇬ凡è鸐x얧꾠ꘀ怌䨬ŕᜣ⮱黋忀ힳ㺲륒Ꮻꁱ䗩吘\\tﮇፏꑱ瘅橭缏廋쑯០敐ꐃ쐑妙胯ᖈ䶲㢄丘쓶Ę⽜侘洁焢蔟ᢟ뷾꼅ᰐ䲻熘즿땲㜙᥄耛⏶桘䟞嫺⏤i桀䕯ኂ咀栧挍㱵ѓ쓂냚傲쬚ᓴțṰ᳁现阃ဘü䎇䴡ꥎὠ쵢혙虑俦ヺ្怉鰕誣ᅹ궱昅￁恣뇲졏览沈렚慟䃆澁뇸耏킃볾㡧ᾈ璉\\udd82䰣燾쐬⒰껱滸㼕ᱺ⋉茁ڨ࢈鈤屎袊焹즺ᔚ⥠娤꼑ι昇삁ⷜダ䒸劏ꉈ⣱薡氂疲ꀤ尖쨱覦⒮`㽱䎛ᘒꡡ⋚鯨ψ銉㺻氅䢮苫苰⥠㲈뢞ਙှ맒⌼梉穛抆䑛噧班懼帡᫩먘怪ꓡ۝ऐ昲襺ꀀ\\u0000鰀㧑堇䄊㢬㉟ᚢ磂＠ሀԖ\\uda8b䇔驥锡靂稊᠀恾茒舘᳄뙂ꉖ䅞☺ᾼ玡읉櫬詘鸐⡘㎅ᒛ찉䦀፤ᬼ挰⷇㙥롃蔾ၿ诡眺겔耺쥈΄鬬谶▇謤䢉⊓ꯄ鐄擂품꒒㰗選ⓒ䭉洦듉퉅∟诌༢ꌧ貙㉴즳➁ᜀ煖嚻꜍願폑촸⮲譈ᰄ瀧諥莑譜᥉潅桽삍傠㝀穋Ң঳૽挿䆼㵑ݘ꼪沁䀲გ올䓦⥊Ḡ屝ʽ獎࿞꺊쒂恧鸊頸ꖁ仇堖ᦎ㘫ꩻⲯ겺왪鴌鄔予ツ╄ꤺ瓦㡴⻇䠌韥騲珀崪䀒⻇♀첲抮袐徫缟뇁읨캼瞱᳸틠䰵覨࠺曪睠翇㜓硦鎸䩡휤檟瞧煏ꦪ锌겂ᜒ䞩협હ쟿䢾ᭃ棌屶逖습ᣜ穰ꠋК槧蒐ธМ뙂ₙ耫⃞꘷椄幺ⷘ叉튒Ō捱ჴ䏑鿹᦯欖텲䖏枴䓶ቸဒ瑺釫⨝ᖤ桬綸턤摳楟䚭ბਗ਼껡焲肑䒜䜄࿑궤̘঺瀠왰،䣸Ⴧ礗䔴ㅓ눶Აټ ఈ豕쎪̷阈搸ꌐ밊↫쌫俰萜磄ꈈ䱔Ⱝ䓆蟔罼፣錜ꀬ炴◝쑺纀갆ꟕ楺䏰㇚킉ꀛ䂀ǰ渀׻뷌援糆퐭墼악ᨬ泚዇ɣ伏ㇽ挦ఆ淊Ȃ꼡쩮\\\\ꑐ鰇韮詃쐍肽ꨄ㷠변งᩴ꓈䛥㈘䱧܉䱡\\ud8e5珁鸪嶱舤㬓娟麋Ш좪䎲辆柡岎椮⪷⒖龲鵂욛機\\ude35샭⚓謡ホἇᩥÐᎀᚊ嫇ㄍ阁訛⒊鮾낙锻끡ꤶꑐ৖⟁痈蚑쮍♥䫜ꧪ邸Ʃ亗탈榝ꚦ曒킁䘞\\ude86揯ꧾ⨀쨐릜ꙥ\\uda34ⶕ葙䮤崢Ќ姩υ郘綀툳撚꺸캕㋠생酚隥Ŋ牂빭씆釜䞙箅ꘗ玲꧑天阚眲ﻄ뿁첚䄜ךּ餥꼾糉삙꾤䥥꓉谨捦镦㿯硹盁ꕜ鏰䍙셥₡ᩪ꥞䊵鋌뭙\\udea4窕䮫ꤽ擳掦ꨦᖗ溟ꃞꐦ鎨䣦儥ꇉ婟囕꒕杊愙迒琍ぎ黴ˁୂ毀᡺퀎Øȸ橪⑤梨삀꣤आ䝡鰣⌟覻싼╹猺빹堟鉲섧⊭詐孻䏣㡜◤䥀ጾ廆뙶\\ud9a9앭龶䮩뭧궕홿녇攓阳陱\\udea6殺㙿ꦭ왍鋿굙㍧햓牬ဳ列쀶慾菆벙䊓ꦣ撾揢秉卥뎐Ꙭ\\ud99c⼹柸벞癏ꁗ蒜铎姉膧讒ɢ\\ud981⚾ᴺ樀\\ud8e7伄ЊธƂᦧኊ힕愶ݚ駬믉称屇㡴郛♰घ亙窤咞ꉬ覵❇铲煺沛ꆚ◈鶢灱麂㜗琀礶➨鯪ꡀฦ鼐ꉻ䂦苨予㾹唲ⲝ硱癪醮羉嫧Њ犆鈈哲쫦濮㙛섬橰砾צ㮜祃撂ᬊ࿉먉\\ud825鬹ò⒞炔⪑⊑殊⤈ג雝ꡊ쁀苉ᴱ炏ꈉ郰὾彄萆뢾肬䏝轋ⷖ董鰄咓呯K䦀ļ楃䴝ᆰ䂙䘈띢䑺鹢稂ᅈ䜀⎐堃ꊜựꆻ佀ᯜꝙ뾪쑪滐䬂䑼⠤쟡硎֫⒰醆䭩ቆ手芠꒸醑ȩ୐玹焃꓎⚄겑錩皘ꑾ톓\\ud8fa짫㇑䎦鴜熬黚䕝᪽逤巂ﾒ鶞溺勪䬙⠅썓聓쑖⑐ᜊ䐠ᰅ䒓詄腕⒳ꖘ䍉㧀䱇滭䅛⒡邦䩩㴅Ł䣲嫁䡴睢⁑禸全ꐁ㓑娂﨓䝍ꆽꐠᩰᯀ㰑별쀓엯ཤᰁ\\udec4ᒪ儁ᬜ䝰ȸ혺㈍怊\\uda2e躨⑊䊱邓慙頓쇨ΐⴉ市醟慌ҵǶ⬋꞊럤昬思¶ᡲꎾꎊ簓\\udc01쐨堊늅ዞ镀祝鸧簆ꅳ㩠঺䗺䃚㖂損ᡬͭ솔됄ᔀ夈쀇哚׀̆㣨桡䆠퀣蠗᝷〘⠂퀀밻㢯댄౜┠⼁纇႘퍇Аᾦ㨅屣뺢ξ쉪ꯊໍ砋顊譁橤錑쁱麋衱ง땠挔硐Ȳ躧ꎤೡ跖븀ꠄ밊粉⧩聦⹤ꠀ畂霰䃅ᒓ蕅唕硤愅媠䵈鰂걚ⅳ࢞ᐅ⛯╅濠透酜勈ቛ෨낛ᙁ쐙遪჆蕶ⴀ薨箈뒊偭䚬∢⁤ɑ᤻憝慒ꓽ鼪跩욇ꀯ㲰꧅ॢꏉγ鰊鑤䫌꠾鶔ﶹ꼮⏲崗呂⳼ꡒ奏齸܂䑄㑔䀘莛耚랸Ṓ䙄쪆择叐প霐뀻処㔛嗀Ꝓᤈ⭐\\udc44ﾓ\\udc26톷鎠娧띩恩➚鄝릝ᩀ僩靄꽯\\udbad롯ީ槊ڕ굋㩞]⼅᥂̞鰄ﳤᛒ䬄Ⲑᨉꁐ誱솽쥢અ璃䔯ᱍ설ಷᤉ蒥꣪ॻ씵姳쾉럀껋쫄ᦶႁᯑ遉噀㼁钢摰Ƽⱘづಔ脁휤ᑊ䶧־썫Ҵ깱玑ੀ⚀ᑱ詀ꅪ릐藙䈮締ꚃ㺈䂎ኟꝋⓥ恱됃㨠g㯜웰匵꼦㛓ꁮ©䓧췮⾀㤃঄蠳㰁伧㢜戣ꄈ栚밵꫁૸\\u0012腂䙟혡急膭脝나\\ud802垜é௜艺⟥ꖂ␆咱Ȯ醷⥥칢潂騷루艇왹崼䞂媍樭ꢱ䝵෹䀶ᰂ㹑㨡悠圏ฅ砎඗뱙䀏拺֍쭰਀\\udfa2಍ड़蛁刉맥䞂ໆ낱䐁娎೐壨ﺕ蕶ᦟ᧡巤㐐著ᅔ⪻耘୅曠ꞗ꜏莣䠶㩒⨯䥼쀄怿Ŋꌀீ\\udbe4༪늎䀱ꏰࠃṚ\\udb3b泰块ː҈蠃늋沑쉒ꃔ怼䏫楒ꕇ桢∡垎눕㞗ᙜ㰛앺Ծ੅槺蘂颭␀䢐茩쭀ꔕ㍀ง픣䢼ᛑ廏∬욊 䂖噺ꓹ䶕\\ud955葇灵霩尦㎕౗㯯ⰳᔷ雙Ǡ㝀ࠡ蘒嗁囦陂翂絫츇퀬嗵巉蘎㚢倂镮竖喤쭥䒪㐈텥怒꿪薴넗楐䕛悑崹礕⒆쑜╡聑\\udaeeசꊥ栝쥣᪏앏㒱貥焊媳়墪假❤박謚♀觪ㄈ餦䈹퉦俠籟隝烶占ꈹ滩⪚灗몝䋰劶稰腦㖗窨夰묈⒮ऀ豗쬌Ჭ㩑鑗衕欃簧ᅂໂ᜚䝁䃠뱫ใ琟င̯ꁶ㣩Ƣژ᫆栙͆蚪⬇춚肀㗔ⴍ徙퇹鋩镠䁒ᗰ椲\\udf55紅묪층晫靖忈阃怚냘䃿␜洌ঀ䞗⹍솃왮膆挪縂倁㴛閑圈Ḧ珃फ़ᘌ那Ⰼ䡫㍞ꄛ륌栕鴶撹羅찒롿嚁效䏉쀹耀⵰ตﯨਂ볉罁㞓ය⤪퓎孺┪횅朂耕떇堢᪚㍓趾‽쇓剭瑾Ĥ䍑䵻픫械缠攔婗쐨鱻ޔ⯩傈딸颤巃鄮❤되㱷땠獬ت聵觖ᡄ땐뗅晡ꄋ閺铥螐몉꓃掅厚텸ꐍ氱멚擥Ȕ⥙矆讞깫㦼ힳ關䪙৤ª㚯짡簙ᗃ靟鞋핸퍈웦擒糗庬⨼魓嵌豎ʑ褊ꖔ㖶鴟ꓵ㧧佗鹁➠꼢䀊Ђ斔倬艀ԟ藵哑訉ꇡ ⢈桜\\udbd6搂४ᔿ閩꘽滵䵧您镅仇퓋⩽倵ﬡЩ郗흢蝎ꦵ靺垘ɑ牾␭鳽睠䔀볃浆幔薸⧬⿵ⴊ䰄삙墳ꯚ＂锁찖ʧ曢∃唈怷⺁́蓘퇥噂叺汔陋ͦჰ㛗銯뭕퐁榙䵤˔흡୍䷵⟠ᩃ陰峵\\ud9d6㢙뱈}홦夂䩀\\udd16轢眈픬•굦వ情ⵐ⅚藺\\udfa0周뢁䣟鞦跌鏍叵돗뿠捂驙抽ಊكꢉՒ摛鐢彑ׄ鯔徉怆⬩입竅좥㝠聄옯䀯Ց奒룲簏炅㒂䀐⪤\\uda71ꔢ竭ᦁ佩ᚕ腀䗚寛芞ᆲ甀䁩剓濹攴㱧׮枓睍떕ᓞ瀲᳕슮唔†茶ꈥ焛Ũꔹ┑녘넘ꔃĵ\\udccaʮ偝ᇶ呲ᬒ풖刁橤㡺府阅煉ꩴ\\udf93筥ൣ鬩闦吠ו䑪煉욊劌Ⴜᑢ싄✁毨읯꘥橇膙吪⯍ᔰ矆⪆쥳孬鳡穴ᓅ⤅度镃剳渕朶ɖ⒐턄잛ୣ塺咤儎襐支킗୳奍ጶ骇Ц㔀ₘ莍祅璒㉋ﱳ檘ጎ綱튧࢖ꦼ㹺\\ud94c쒕羀퓪윍耝䑪낽躄夦\\ud8f1芫ᒔ蚿國鄮庍㜠ᤌ荐䷤\\ud938鮋脶팗 'స苳¡៨ૣ倉甙锼ޞː⬌铰ࠦ䎗墓惱▀㟨㡜렭擟ࡴಒ笇ᰚ驻횃♃䯍吴ㄡጕ㩧휃寤◬㇕缦ꍮභ퓰헃ᅠ\\udf17鰊ୢ莖䔐ფ잸淓䝉๥菀ୂ숌鄪背뀶往Ā搋蝙ᵷ仺흢謄ⓨ憶ᾆ묾騃Ⴅꔄ⺩燖⎑∜ꂩ퟊鷓蟕牦岖ඞ퀙ퟌ쀛妖뺠㺊먄怑脖ഺ㮦ᢢ櫓嬀Û䘀⣢ኔ현긪머\\udb7d孵捭펓駺墠ป卭먷菣ꭑꥷ㤀\\ud83c牠傔ಈ୤䃚埘园℀ᖴ띗ͩ뒓–亚悴ۖ荪餘㙵Ӗ༮醶ᕄ൶뒍뛞섁⛐敓䡪霶聛梎⧰沒遍\\udde3癹헦닫⍊꧚塣痱ິ୕멘ࢮ띇གྷ婞恴ࠃﭡ䶆檻ꕠⷎ㘪嫔읲媯楔鞎ꅚ㫔묔筬⸧䩽养岍誵‫₭뜌骫簐ࠉꭶ귡ƾ욱ᰀڵ᫒ᡦ䀫膚킈♐䌃 ᴌ邮䰫뎖䧈㇒퀒郛뙖\\udb7b氝얂痌㾕䚜ε쌴䴝\\ude06绝⍷㑗⿫䨍飉Ǒ꺌乫둆풖呭側웙嵽鷝䯮傇䯍⦵㕍魬镘醛ȹ⛹짥ᛜᴏ哀줣⵭默\\udb57ᵬ㙵ۛ稚퉵囝஗淌ö\\ud87b琮ﶷ涫ꍇ㗝艧嘻丮仞氚뗎\\udc30˭䌤⮟瑮ퟗ园苀尥뫠멅\\udbad凒쉷廘ᵘ딱퀒嗭싖宥ﭮಫ畫韧犭꠶阬᭺෫䨷⇠㼊慶䇕ꦴᶱ뙙䰻≭⇒㥅冣翱랄☛禤㗾퉇劍ﻹ刓陯瑕ᣈ䖇猀䷱퇓５䙳㪰틛毚쬹頍쵥\\uda9b畹\\uddb7依Ჹ⃙❾\\udd01瘝퐖䡭⁵紁䍄퀸㑅훷䐡￹髒〳樢툀娂∄颁ྣ嵂攨傂ഘ袖煤묁逩\\udb9cً怠\\ud975歹鹕处皃瑖䓵杚﵎甀⦤쫏䝅镖쉽앝㘙態凰郶疑⽩姠몣\\ud980ໝ搷죘ꍵ㈪㜥鴛夽賥௑㙗\\udd8f퓽\\ude6d纍勵釐ꉃ굘푡\\udb71哕⿇\\ud8df읅⢥曼쉕轠ꮔ㻪堹惱勾ᶘ侧偟ꪚ䵋쎭擻妌ς预ﰣ삃壥蔔괉⤑뀎Уẜ⊤⩠ደ̠嘫庚᩿餄驮ꖠ멂ꤚꓪ銇햩ⴽ沑☵꒨횦乛釤隓㟟㴻ᳶ鄣왙ࢅ\\uddf5ᩜ➎퇘֚宀僩ꩇ楡Ջ\\ud850ቁ接쪐祐츍綕䞰ݟ悅茫\\udf5c摦郄仟侀寵큐䤢摽\\uda21䠙쮻뮉죞銪䲠╈ﺓわ彆ꔃǡ嶭⬔隐ꍕ\\udf7c搳脣척⧽\\uddf5⡓\\ud83a諄O⫥ᗫ項\\udc12针躐ઠ丂⯜ଈ\\fӊ뜥⊔쑟빔솬鈇⒯壍肁筍즋췬ꈡ퉀漵텊慥虖㉵蝀辰鹒䗆脕讻⡪린Ⲁ榇ㄚ蚶友\\udb52ꆁപO䕵灰酙媚떜굗좨뽨荲愩埳栎Ꞌ␪㔧﷛ଶ⥞ΰꏏ稙郴六涀㊜宅բ⴪䁩䭂绹ᢴ䙌⼓銯胣腍⺃蹻⠶赪⃫믁魦ꃠ汴̑䃓ꆳ᠀ᵾ횥큊斵䖼ᇆ蚞ᖤ࿝둽渳⯔튤斥鏷䧡ꑑԣꞴ\\udd99၃静鞀ﹹ碑ල᤾׎呛䘶࣑嗖岳撱䑥镏⊋ꓒඥ庺㺜ⵢᡒ鲤㬀虰ᐠ壐潀\\ude08茀꧀∠✃Ꮰ◜⥗햪蠭숫续탍䌵꨿代䱨煂糖꽨嶈낥싰Ɛ뛻⺇ᐴ┭慑Ӈ당璋桟磹ᚠপ舠걸楄囷Ȕ貰㋱࠺렘쎵൱偀Ẕᣒ琱咘蠯ೖꗯⴃ湵ଐ務↔ణヾᎋ䰴爫쎼퀹효㊜킨净襇ᒐ購㌰끡ȸ謝䘨甠Ƨ୚一ⶪ⭟䳊棃刎효赏󠊅佾깔\\uda86氦ᖰ辙柱緃藕툷쎔迓䵌徘ඕꀻ㡨㭶䱰퍚꛻銐쥀⌚ᙵꡜ蹔툺앐ᔈ峈셬숎ᜥ偰馱啉ʽᨎゐ뼭㵠ℵ얥㾆輩⛡尦㵭⫭尉뻕Ꭳ룢尭竁ᬈ㗩⿃쨩›蘐蹢鋁∢⥃錵麏㍅䵌럵蕵嬭狗畬ꦈ〻疹킺즘흠땽ോ所颶ᵚ뀲䉘㚒ƴ쓮\\udb65嵋Ք֦熵௟⾕뷄㗸\\udb6f橣罵뽟馒膊摝䮽脗烡뵃赓眢眭￻饬遜烏阹퓫秀惴壁骕踉\\ud862叕䭀㇐焙\\ud826㒰濃쫞ྯⵊ랠ꅗ卣檵谨Ꝗ궛腞힫窝ﳂ槒歎鷦됱\\udc80㖭䒺\\udf5d꽬跫垗又疵⸸坊\\uddb0헴ᥝ䥧䇓❠丸\\udb55햾ꛣ畵Ⱀ흖Ꙭ묵\\udad7咝ၜ鶝畎팻䏖ꀶ換狵툰ፘʹ⮬뭋雀ž㲷佰ⴂ滜耍鴭픱곸쳝븸ꄌ皮㯛琮ᮍ㲆䓙\\udeb7䁺ふ쐧祳桎鼬篭ਠ௑潵捕펣䩣痥춐磥倔瑼䶄둵䟩杯檱\\udff0㴝鱴캡㴀ꓔ釭繞䡍徐扺ਸ較椦㕺鍓踥鶞ꖓ雛켝訴㷋踶후ਲ焳Ә뷘⣮㖏廣行ﮞ흂鵊皞㊧秣᩵ᐌ歂ࢦ랚\\udd0f冝隴駖吙鶢멙\\udd67䓝뙷䷒壛㉎菤ᑍ᤺\\udb4a䆀修㎗翭\\uddb6觗㣔ጩ픵㚝尓ꎴℷᵰᏘ뢡㟪ᨓ䖀愸ጠބ｝䮴諧惡古亍\\udf84Վ턹蚽ጔꋍ\\udcd4쁞过䏟鏝㤅㟥賓㱏ꏞ灿Ꮥ짙퐤㞢褻࠸鏥뙉㒴\\ude1d싵줸䝘鷄琗鲤저䃶升喋錐煝烵檈耢㷡亪쯣жꮘ揟畡澞劓틷퀙館\\ud991ᮕ烀⒗烖獵榽晚알必佨㍾嫁֯䕣㵍杬郫퐵뎌䅑覈棩喢Ε弯䜽蒚㈍콿顒䲋顃巡低诒붝佣\\udb27再닶댶콂뵄뀹⧿䚽峸輏㌀㍿辺ኀᨀ쵁篝끢㦆儌쇁ﳎ緓್뵰춐훴뢸飙蓧撥횘\\udf6f㘘麭匵틥朼鲨攪⢍쬷ᣠ雂콠꺘豈馏昱ꓶ\\udc79貽톷䓵蛎壩뎿瞛㣯䀊ꄵཇ䙅衰酄\\ud85d妅焷瘽썔嵂䲤\\udf70㑽擝癪⤂儩൒᧺昌낆꜡疇䶟䣖༘섋䞺Ҕ̋䚓ᚃ乪㤟窑⦸柔꩐嗏톂搠໯鹽᱀㋂㾥բ緦‎હ絢俀ꐅ냬鄏㘁娥Ď睨냼桥倅㌴蠔䎝Ꚛ坓禥㓓腁Բ磏\\udc41䎥㑋漻蔞뤿\\ud87cשׁ᩻瘏筼刱ᤳ᫾叽ൕ䐄蠹䌄敋ᥐ콨\\udfce糛ﳬ⇈㵐꥕慕↎릢もἴᡎᴷ䃟拐⓺ㄩ⎰ᝆ烣䁻完伈О䴂绬⎱ꮣ㇅ᜣ밚㒊쳰㱋샒鸘쎓⩈觵䳰ꌰ쐓㭎☸蚀诵较椀䃴烈轉\\udd17桻兘췝剕ᡅ挶䫻舯\\udf2a魀挏\\udc3b㡐痔ī謄ᾠ틹ఖ஡㍉Э\\udb57焹哦珫䮙奇䷼踢싖潡럽툊⁝⾘쓦亄ᷦ⾮ᔌ쵣槺쌹䤅ꅝ礽૥隐拄ᅶ㣖飂Ƛ怮㽃䳐ր⹔ꥨ횏ጳࣽ꠹䈉≖を㸁䑭더湨ⱆ荿咰陸鵮㕁㱲ಁ欩쉡뀴햅䃖䃈䃸閣铵\\ude25᪂ᒅ葼퐙楀⫇蕤⃲輮豈탅꒏㱑䣭ﶵ킈\\udcdc颍聗녗Кꏠ灪㳰횣瑑ㆇꣻ㡌뜲윔擻ᄯّ噳䷂趣擳내㭧௻錘\\udecfԷ㝨튛櫸댜왫썜鄓ꓘ㟹툖䄽靵惏⋯୥跫㥌솉䬄篫쓊ʳ圼滓钌袱ᱽ嶭䴢밒퓒쵴쫖ⳅ㪸퐗桭㨭荘ᵚ肐퓸뺣䝭냊躱㕯梪ꚪ뤵聶䵠⮢퐩㊯ꉵƶ鼭ӟ隰伎\\ud9d4㰓\\ud8ae捌僟挙ĩᶚ섁鷆㈛曌❮빚읥ᔶ㵑匏䰄볿벓槖⤹카⯀榝㐺ꎘ펀쑬裬ദⳣ֒툚州财냘쒽浶꫙吲怋숽߃龨૎ピ곋찪컩㡈窳尷睓着릅肺륑먀㺈堈ꮎ侊듢ᒫ뀶轗籀䤜遅鷲嶛ው\\ud976辏쩒谷䔴旧䊐࿄⏴훓リ묍腊梀ࢭ闺ꚠ偱䎏\\ud961걥㕅⠏搦慨៸膼钦攬䞧炐駁ᔜꪔ蹙\\ud935頰慯鉏똬䩗⸧閷⡘㙙揰ᘣ繓ṽ储慀ⱇ쨭ҝ열䨖䙡楤ꦵ๋大䛝Ķ䄹⚀⟌驛卾큊䝠呮ӽ䴵俛糅텭㕐ᡁ৫撚麼製ኗ꽞둰ᷫﬀ㺱罤䇦䬕㝤쁭\\ud80f\\ud922崣鏣荺塨ھ돀─ꀄ챐⃴գ⻲m巁纪ꕬ䋻셑ᤣᠶ烴핷荭譸သ瓎뤋봇撂愚㕪蛺䑇㺫慷ૉ㙢࿆콀蘨뜯鬟䌥笵굒Ḹﴘ\\ude86鐐Ṫ肔괺೨老哮漹ㆀᬭ䃚튁磊栔퓒㽹出촶\\uda53腽ꖣꑆ쮦쁠﩮穔䔏ᯧ¿쀙你艋䙄ﶫ䍥짅佨Ꭹ\\udd83쐲鰋뉿臆涩屧醞쩑䓯䂂腑놠ᡁ墎榮ཽ읢ꈬ珤謗㬬ꏚ耋岂㜙䄫렰쁸°槐鸆倀끟킢浘쟊䒛陡䨣驕导劃梶蒙붫\\udd5c䧉蹪늯銙죏ቅ걀䁀ⴢ쟲䋀圈晰狀공댋뫮譶ᦗ櫸㹞敾蚬᫓⟕㊱㛿늩柀㉨䙢얙㵚駭뤖櫐ᥥᶽ陭ꥹ昱ぎ灱靤閕璗跖곸\\udc6c욫完ꯧ᳛⯄瘍늌째捭ﲻ乻头鷖椹཮탊᱖౺겋ⴤㅅ쯁ꤰ计怣暎ᴤ쏾뉌綼\\udbd2萣㯬Ꝃꀄ㛾\\ud823濸Ў魦᎙໎\\ud99d햃땎筦疐೔✎즌࣮ꀿ唨鹞䕙︭掸ዉ돨궛㾎\\ud82bﶼ㛏藤鰭䜻就玱밒㮪േΠⅠ靦ﯚ試潔鹖讓橐ꂏ꼙낤䯫堖腥魟꼤㝼羯셊뢟컁뇅㟼ṯ瘋蜼䀮̚㡑⁵즕鬩똍鑢戸൸醁뎁酄砆憵튷袀㊙퉬㞋錜-폂췉鵑꜔櫆Ȇ孲戽鶑㿳눨槉㰊㰀喫䜇ᆄⰭ숙覛娡ᢖꑛ쇎㳸䣂ঢ妀➰ೈ횲㠥賔炔둸⻀扡襤嫞䑛햾ቀฉ吔\\ud8ce担鱮帊⚢萉ᲃᔟ鑅簼䎰鶱寜녖\\udb0cẘ햸됝寢漞ⓖ\\udc01⵭᾵ﴫⴜ⹆㗂컅ㄶ≧늃뾡㴦잲Ṽ猡㗂ැؠစ퉇뤽▹漞夹쇅降ㄋ䂭鏓뢃ᮡ⧭Ʇǌ늉뢦蚃ྰ뜺碓遯ஸ萘ᥑɻꚄ顆黜瓺錏붴咆쾺帝⅏⊻雾꽭嘹軑ഢ댽䟋趌嬿Р鉆稑㤀郝⮴易䓲㶂乘Ⲯ켻죯ꮸ堯ߨ舖๥뿻耟諐⻮爬ᰋ㶎킳鋮蚜໐ꭾч₞＇ﻻᄺ笒믹椷抻⋒⎻컴蝧ꀘ縼䰇궓異ꇽ께렓䎽섵⮩\\udee9얩㟹鈇ᰀ衾擘蟰甡욠薀錚箅莠싡拦讼玼㎜㼄ǰ䏭ለ懬牓䲮훾석茺ᇧ㯡ᶫ뤑쓍夜ᐃ⇒老᳄븬亻端滻盇겻먘ᦻ쏴宲ꢐﺻ㽃澴目ᛃⳓ\\ud802틽ᬏ䘸돂﹞㢞㩢뉍蹾㹌\\ud9ef焄ﶋ其⎵ဖ틐ဣ惦걧撬ि鉺⒭痐顮ꊀࠏဃ뼭ៈ꬝疆뀖q叁띵ꖪ횠뀭䞞䵠荫㗩\\ud90b㸊\\udeff〛쾴ꓑ\\uda84߮떰좓䆉냖炙Ỉ嫥绫聭滟뵲ﷻ뜯炵쭻᎐긿᪱⸈쀉ꈓ잡﮽㤆韨숂\\ud882Ǌ굆㕳吠๴㒟ℴ捸☦ლ襞ལᴹ\\udf18쵶⢜臅鶒䤧퐂鱅瀄鷉๮₧₂쪹䡓ꬠĖ઱む怒搃⟵╒ᚨ䎊䃆鴌‭\\udb30瀂窇氜훫퍳旲粡㥠銟〃珢ᶔ犏Շʂ唁䧪篔鱒⢙郾됂㉾¬鱿蕼ᨉ倈꧉❁듺熩조媟졃}䝐䔉섉솻듢韝鍫䕹邵ߨ❇ㄏ汦曻๾뒐㙮ﺽ瑷푩鱌鄱\\uda67䱽\\ud817鬟䫐\\ude15﹭䋂ᴗꇹ块࿬ꙀÜ爯䎗Ầ끉씩썌쑯鈕㒫숴襫墔㒪⬫芤㳵Ⳣ撪ꤵ檫崉筅慍䱮邪\\udb0c複䂰쪓ꩶ祽䣔壌붆䘹㻨웋简聾୧撇펡ថⷨ楚蜞ⶸ着ܘ差ꢁ挐텧⾴높젵䌗䮄숨㹑꤭ᖾ৞ﮐ鵒襖뽊쉸㖙ﮒ滜ਧ핬\\udfb1⩆✷噵늩輋ᄭ៬ທ쯯ɓ䀑涳稺悰騝數흲痤\\udf5b彯ᇑ\\ud9c8Ɗӄ磛읶䶻㛝㪈횊쐫ਲ਼犺쫻卼꽒䙐캇쨷涵엿늖훨덑焫潒鶷꬀楒둍愺ⓕ튿⮒帠쉯硝坵픴䗠⿪ᕺ໅蕖蠁혗壙挲辵踦碗丌╰ୋ侂밴踶㖴縻쫿偿ⅳ剌⚟䕠ⵘ郂홠ȥ퐻俰☁활譀俫㑘䰶錓稃鸈䂆⥠Ǆ↵␃棂闢䗽榹缕ኵ⋅뎕䏮稹퍾⫒諔㎽㜝皳밯䝕臜埮嶳寷䜫穜祷\\udb6a⮌屰纝缫ꋎ硻䧵䰹ຎ㖳痪녱禴꯬ツ팚奨뎸疢᳝큀⤗縨嬌渊窃Ɣ睠➍ꏕぽ塌㚊쫱圹\\ud917鿶ᚲꇩⳲ믂퉣伭桱쮋᝝鶱珙骧͜壪ꯂ뱩팗磭ꑺ嗬O䚶㺐ྊ䎝㗒㓶㳸긁芺櫒㧰뭍瘨ԇ좯길諟埾㙰竵㉁띉䝜㉇⶷ডﮁ壎ï镩ऄௌ雵ﵱ蜯햲軴섀獖櫗ﵺ㞤̾㣕ﳛᜮ훙櫦󳃉㫁ￗ腞ͽ芃ꭝ忢袗꒳泌톆ܧ꯮ꝺ넴⾫왍ꬹ썦덁껚爬顫誟쉖閂봦곫㾐ͺꥱ軁Ꝇ촚甭ｗ媮㪴捸㑠韛엜콴\\ud8a5䍴獛흼⟕窴\\ud959矆緡鶮낰፧㻏㵾灁㟝鹦믵쒷Ⳝ蔽ꇵ爰퐈畈剘㔂쁨里ᚅퟶ◥ⱹᴘ掃회瀌ఄ련Ἂ䦴怿侲엗ꐉ䰾鼙覞䄪彏恀쟧ఔ潼\\tᾱ\\udee5誦聰譸ᬛ酳愔ꁣ獰㿆ा\\udad2矄㘤䁀\\ud9e0匄艺ᒨ臁刿긠톓嗅聤෫ꔷ篦抖ᴜ뱈쥒ᓑ嶈ꁋ䜏簭憥ӆ乡䘀ሏ躇誱擂喘볂剼븺▙삟Ꙣᮚ\\udb83앟揌и᪴뻱≓듌娙吉놕袱蘐⦧Ò拳챈뀬ꈂ渂퉑ྵ슕棽㦖╁뺪骭顱霨୹翂缙䏭\\ud92d嗉躺᭺䏫闆瀯㱞䌈ɀ㖨䡣荖氷馬㳋쐌偔욂琗臲옪ꔋų噰琍ꠃⴌ遥ச쀬춣㦇툺鮀Ł诈㾀㈀搕鬉탢Ѐ\\u0000\",\"actionData\",\"errors\"]\n");</script><!--$?--><template id="B:1"></template><!--/$--></div><script>$RB=[];$RV=function(a){$RT=performance.now();for(var b=0;b<a.length;b+=2){var c=a[b],e=a[b+1];null!==e.parentNode&&e.parentNode.removeChild(e);var f=c.parentNode;if(f){var g=c.previousSibling,h=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d||"/&"===d)if(0===h)break;else h--;else"$"!==d&&"$?"!==d&&"$~"!==d&&"$!"!==d&&"&"!==d||h++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;e.firstChild;)f.insertBefore(e.firstChild,c);g.data="$";g._reactRetry&&requestAnimationFrame(g._reactRetry)}}a.length=0};
$RC=function(a,b){if(b=document.getElementById(b))(a=document.getElementById(a))?(a.previousSibling.data="$~",$RB.push(a,b),2===$RB.length&&("number"!==typeof $RT?requestAnimationFrame($RV.bind(null,$RB)):(a=performance.now(),setTimeout($RV.bind(null,$RB),2300>a&&2E3<a?2300-a:$RT+300-a)))):b.parentNode.removeChild(b)};$RC("B:0","S:0")</script><div hidden id="S:1"><script>window.__reactRouterContext.streamController.close();</script></div><script>$RC("B:1","S:1")</script></body></html>