<!DOCTYPE html><html lang="pl"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="modulepreload" href="/fetch.js"/><link rel="icon" href="/favicon.svg" sizes="any" type="image/svg+xml"/><link rel="preload" as="style" href="/assets/styles-BpGDlrHQ.css"/><link rel="preload prefetch" href="/fonts/geist.ttf" as="font" type="font/ttf" crossorigin="anonymous"/><title>Renesans w JS, czyli nowoczesny JavaScript - Jakub Szpil</title><meta name="description" content="JavaScript jest językiem programowania, który jest powszechnie stosowany do tworzenia dynamicznych i interaktywnych stron internetowych. W ciągu ostatnich lat JavaScript znacznie ewoluował, wprowadzając nowe funkcje i poprawiając istniejące mechanizmy. W tym kursie omówimy najważniejsze elementy nowoczesnego JavaScript, w tym ES6 i nowsze."/><meta name="keywords" content="javascript,kurs,wprowadzenie,przewodnik,web,frontend,learning"/><meta property="article:published_time" content="2024-06-30T00:00:00.000Z"/><meta property="og:type" content="article"/><meta property="og:url" content="https://jakubszpil.github.io/learning/nowoczesny-javascript/"/><meta property="og:title" content="Renesans w JS, czyli nowoczesny JavaScript - Jakub Szpil"/><meta property="og:description" content="JavaScript jest językiem programowania, który jest powszechnie stosowany do tworzenia dynamicznych i interaktywnych stron internetowych. W ciągu ostatnich lat JavaScript znacznie ewoluował, wprowadzając nowe funkcje i poprawiając istniejące mechanizmy. W tym kursie omówimy najważniejsze elementy nowoczesnego JavaScript, w tym ES6 i nowsze."/><meta property="twitter:card" content="summary_large_image"/><meta property="twitter:url" content="https://jakubszpil.github.io/learning/nowoczesny-javascript/"/><meta property="twitter:title" content="Renesans w JS, czyli nowoczesny JavaScript - Jakub Szpil"/><meta property="twitter:description" content="JavaScript jest językiem programowania, który jest powszechnie stosowany do tworzenia dynamicznych i interaktywnych stron internetowych. W ciągu ostatnich lat JavaScript znacznie ewoluował, wprowadzając nowe funkcje i poprawiając istniejące mechanizmy. W tym kursie omówimy najważniejsze elementy nowoczesnego JavaScript, w tym ES6 i nowsze."/><link rel="modulepreload" href="/assets/manifest-b7f9055d.js"/><link rel="modulepreload" href="/assets/entry.client-D07Jc1yP.js"/><link rel="modulepreload" href="/assets/jsx-runtime-D_zvdyIk.js"/><link rel="modulepreload" href="/assets/chunk-OIYGIGL5-Rdhby1S0.js"/><link rel="modulepreload" href="/assets/index-DJQXGD61.js"/><link rel="modulepreload" href="/assets/root-BT3np3FX.js"/><link rel="modulepreload" href="/assets/layout-DYpV2se7.js"/><link rel="modulepreload" href="/assets/button-BMGgmMxT.js"/><link rel="modulepreload" href="/assets/link-with-prefetch-BIs6hVLd.js"/><link rel="modulepreload" href="/assets/icons-BBGQWBin.js"/><link rel="modulepreload" href="/assets/socials-DGthjeXP.js"/><link rel="modulepreload" href="/assets/date-NK96Yl5Q.js"/><link rel="modulepreload" href="/assets/not-found-CGoFJWhv.js"/><link rel="modulepreload" href="/assets/seo-Do91G143.js"/><link rel="modulepreload" href="/assets/course-details-DLJ6fZBl.js"/><link rel="modulepreload" href="/assets/categories-BBucIGjV.js"/><link rel="modulepreload" href="/assets/edit-resource-Bp0MeTOm.js"/><link rel="modulepreload" href="/assets/banner-DCe0eTPI.js"/><link rel="modulepreload" href="/assets/compress-C_V_4BTm.js"/><link rel="modulepreload" href="/assets/creation-date-x1jkwlYO.js"/><link rel="stylesheet" href="/assets/styles-BpGDlrHQ.css"/><script>globalThis.timestamp=1761079971900</script><script>let k="theme";let t="dark";let s=localStorage;let c=document.documentElement.classList;let v=s.getItem(k);if(v===null||v==="SYSTEM")matchMedia("(prefers-color-scheme:dark)").matches?c.add(t):c.remove(t);else if(v==="DARK")c.add(t);else if(v==="LIGHT")c.remove(t);else s.removeItem(k);</script><script type="module" src="/fetch.js"></script></head><body style="-webkit-tap-highlight-color:transparent"><header class="sticky w-full bg-background top-0 left-0 z-50 border-b"><div class="container pb-3! pt-4! px-3! flex justify-between items-center"><a data-slot="button" class="button button--variant-ghost button--size-sm font-bold" href="/" data-discover="true">jakubszpil</a><div class="flex flex-1 justify-end items-center sm:gap-1"><nav class="hidden items-center lg:flex"><a data-slot="button" class="button button--variant-ghost button--size-sm" href="/" data-discover="true">🏠 Strona główna</a><a data-slot="button" class="button button--variant-ghost button--size-sm" href="/blog" data-discover="true">📝 Blog</a><a data-slot="button" class="button button--variant-ghost button--size-sm" href="/learning" data-discover="true">🏫 Learning</a><a data-slot="button" class="button button--variant-ghost button--size-sm" href="/portfolio" data-discover="true">🛠️ Portfolio</a><a data-slot="button" class="button button--variant-ghost button--size-sm" href="/me" data-discover="true">🙋‍♂️ O mnie</a></nav><a data-slot="button" class="button button--variant-ghost button--size-icon inline-flex items-center justify-center" aria-label="Szukaj" title="Szukaj (CTRL+K)" href="/search" data-discover="true"><span class="sr-only">Szukaj</span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="size-6"><path d="M10 10m-7 0a7 7 0 1 0 14 0a7 7 0 1 0 -14 0"></path><path d="M21 21l-6 -6"></path></svg></a><div class="hidden xs:flex items-center sm:gap-1"><a href="https://www.linkedin.com/in/jakubszpil/" target="_blank" rel="noreferrer" data-slot="button" class="button button--variant-ghost button--size-icon inline-flex items-center gap-1 no-underline" title="LinkedIn" aria-label="LinkedIn"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="size-6"><path d="M8 11v5"></path><path d="M8 8v.01"></path><path d="M12 16v-5"></path><path d="M16 16v-3a2 2 0 1 0 -4 0"></path><path d="M3 7a4 4 0 0 1 4 -4h10a4 4 0 0 1 4 4v10a4 4 0 0 1 -4 4h-10a4 4 0 0 1 -4 -4z"></path></svg><span class="sr-only">LinkedIn</span></a><a href="https://github.com/jakubszpil/" target="_blank" rel="noreferrer" data-slot="button" class="button button--variant-ghost button--size-icon inline-flex items-center gap-1 no-underline" title="GitHub" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="size-6"><path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5"></path></svg><span class="sr-only">GitHub</span></a></div><button data-slot="dropdown-menu-trigger" class="button button--variant-ghost button--size-icon cursor-pointer" title="Zmień motyw" type="button" id="radix-_R_4ej5_" aria-haspopup="menu" aria-expanded="false" data-state="closed"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="size-6"><path d="M9.173 14.83a4 4 0 1 1 5.657 -5.657"></path><path d="M11.294 12.707l.174 .247a7.5 7.5 0 0 0 8.845 2.492a9 9 0 0 1 -14.671 2.914"></path><path d="M3 12h1"></path><path d="M12 3v1"></path><path d="M5.6 5.6l.7 .7"></path><path d="M3 21l18 -18"></path></svg></button><button data-slot="button" class="button button--variant-link button--size-icon inline-flex items-center justify-center relative z-50 lg:hidden" aria-label="Otwórz menu"><span class="sr-only">Otwórz menu</span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="size-6 text-black! dark:text-white!"><path d="M4 6l16 0"></path><path d="M4 12l16 0"></path><path d="M4 18l16 0"></path></svg></button></div></div></header><main><header class="prose container"><h1 class="mb-5">Renesans w JS, czyli nowoczesny JavaScript</h1><div class="text-xs sm:text-sm my-6"><div class="inline-block" title="Data opublikowania"><span class="mr-0.5">📆</span><span class="hidden">Data opublikowania:</span><time>30 czerwca 2024</time></div><span class="ml-2 mr-1">/</span><div class="inline-block sm:inline" title="Czas potrzebny na przeczytanie"><span class="mr-0.5">⌛</span><span class="hidden">Czas potrzebny na przeczytanie:</span>18 minut<!-- --> czytania</div></div><div class="flex items-center gap-3 flex-wrap"><a data-slot="button" class="button button--variant-secondary button--size-sm no-underline!" href="/learning/kategorie/javascript" data-discover="true">JavaScript</a></div></header><article class="prose container pt-0 prose-emerald"><p>Witaj w świecie <strong>nowoczesnego JavaScriptu</strong>! 🚀 Jeśli HTML to szkielet strony, a CSS to jej wygląd, to JavaScript jest sercem i mózgiem - sprawia, że strona ożywa, staje się interaktywna i dynamiczna. W ciągu ostatnich lat JavaScript przeszedł prawdziwy "renesans". Dzięki wprowadzeniu standardu <strong>ES6</strong> (ECMAScript 2015) i kolejnych aktualizacji, pisanie kodu w JS stało się znacznie przyjemniejsze, bezpieczniejsze i bardziej efektywne.</p>
<p>Ten przewodnik zabierze Cię w podróż po najważniejszych nowościach, które musisz znać, aby pisać <strong>nowoczesny JavaScript</strong>. Nie martw się, jeśli jesteś początkujący/a - wszystko wyjaśnimy krok po kroku, z przykładami i analogiami, byś mógł/mogła od razu zastosować nową wiedzę w praktyce. Czas unowocześnić swoje umiejętności! ✨</p>
<h2 id="spis-treści" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#spis-treści">>></a>Spis treści</h2>
<ol>
<li><a href="#zmienne-let-const-i-zakresy-blokowe--po%C5%BCegnanie-z-var">Zmienne: <code>let</code>, <code>const</code> i zakresy blokowe - pożegnanie z <code>var</code>?</a></li>
<li><a href="#funkcje-strza%C5%82kowe-arrow-functions-i-ich-zastosowania--kr%C3%B3cej-i-czytelniej">Funkcje strzałkowe (Arrow Functions) i ich zastosowania - krócej i czytelniej</a></li>
<li><a href="#szablony-string%C3%B3w-template-literals--%C5%82atwiejsza-praca-z-tekstem">Szablony stringów (Template Literals) - łatwiejsza praca z tekstem</a></li>
<li><a href="#destrukturyzacja-tablic-i-obiekt%C3%B3w--wyci%C4%85gnij-to-czego-potrzebujesz">Destrukturyzacja tablic i obiektów - wyciągnij to, czego potrzebujesz</a></li>
<li><a href="#spread-i-rest-operator---elastyczno%C5%9B%C4%87-w-manipulacji-danymi">Spread i Rest Operator (<code>...</code>) - elastyczność w manipulacji danymi</a></li>
<li><a href="#promise-api-i-obs%C5%82uga-asynchroniczno%C5%9Bci--opowiadaj-historie-o-przysz%C5%82o%C5%9Bci">Promise API i obsługa asynchroniczności - opowiadaj historie o przyszłości</a></li>
<li><a href="#asyncawait--nowoczesna-obs%C5%82uga-kodu-asynchronicznego--pisz-asynchronicznie-my%C5%9Bl-synchronicznie">Async/await - nowoczesna obsługa kodu asynchronicznego - pisz asynchronicznie, myśl synchronicznie</a></li>
<li><a href="#zadania-do-wykonania-sprawd%C5%BA-swoj%C4%85-wiedz%C4%99">Zadania do wykonania: Sprawdź swoją wiedzę!</a></li>
</ol>
<hr>
<h2 id="zmienne-let-const-i-zakresy-blokowe---pożegnanie-z-var" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#zmienne-let-const-i-zakresy-blokowe---pożegnanie-z-var">>></a>Zmienne: <code>let</code>, <code>const</code> i zakresy blokowe - pożegnanie z <code>var</code>?</h2>
<p>W starszych wersjach JavaScriptu zmienne deklarowaliśmy wyłącznie za pomocą słowa kluczowego <code>var</code>. Często prowadziło to do pomyłek i trudnych do wykrycia błędów. Nowoczesny JavaScript wprowadza dwa nowe sposoby deklarowania zmiennych: <strong><code>let</code></strong> i <strong><code>const</code></strong>, które znacznie poprawiają bezpieczeństwo i przewidywalność kodu.</p>
<h3 id="zakres-blokowy-block-scope" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#zakres-blokowy-block-scope">>>></a>Zakres blokowy (<code>block scope</code>)</h3>
<p>To kluczowa różnica! Zmienne zadeklarowane za pomocą <code>let</code> i <code>const</code> mają <strong>zakres blokowy</strong>. Co to znaczy? Oznaczają, że zmienna istnieje tylko w obrębie najbliższego <strong>bloku kodu</strong>, czyli wszystko, co znajduje się między klamrowymi nawiasami <code>{ ... }</code>.</p>
<p>Pomyśl o tym jak o specjalnej, prywatnej przestrzeni. Jeśli zmienna <code>x</code> jest zadeklarowana wewnątrz bloku <code>if</code>, będzie dostępna tylko w tym bloku. Próba użycia jej poza nim spowoduje błąd. To chroni Cię przed przypadkowym nadpisaniem zmiennych o tej samej nazwie w innej części kodu.</p>
<p><strong>Przykład:</strong></p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) {
  <span class="hljs-keyword">let</span> x = <span class="hljs-number">5</span>; <span class="hljs-comment">// x istnieje tylko wewnątrz tego bloku if</span>
  <span class="hljs-keyword">const</span> y = <span class="hljs-number">10</span>; <span class="hljs-comment">// y również istnieje tylko wewnątrz tego bloku</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x); <span class="hljs-comment">// Wyświetli: 5 (dostępne, bo jesteśmy w bloku)</span>
}
<span class="hljs-comment">// console.log(x); // WYWOŁA BŁĄD! ReferenceError: x is not defined</span>
<span class="hljs-comment">// console.log(y); // WYWOŁA BŁĄD! ReferenceError: y is not defined</span>
</code></pre>
<p>Dla porównania, <code>var</code> ma <strong>zakres funkcyjny</strong> (function scope), co oznacza, że zmienna zadeklarowana w funkcji jest dostępna w całej funkcji, ale poza funkcją jest dostępna globalnie, co jest źródłem wielu problemów. Dlatego w nowoczesnym kodzie <strong>zdecydowanie unikamy <code>var</code></strong>.</p>
<h3 id="różnice-między-let-const-i-var" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#różnice-między-let-const-i-var">>>></a>Różnice między <code>let</code>, <code>const</code> i <code>var</code></h3>
<ul>
<li>
<p><strong><code>let</code></strong>:</p>
<ul>
<li><strong>Deklaruje zmienną</strong>, której wartość może być <strong>zmieniana</strong> w dowolnym momencie.</li>
<li>Ma <strong>zakres blokowy</strong>.</li>
<li>Nie można jej ponownie zadeklarować w tym samym bloku (np. <code>let x = 5; let x = 10;</code> to błąd), ale można zmienić jej wartość (<code>x = 10;</code>).</li>
<li>Używaj <code>let</code>, gdy wiesz, że wartość zmiennej będzie się zmieniać (np. licznik w pętli).</li>
</ul>
</li>
<li>
<p><strong><code>const</code></strong>:</p>
<ul>
<li>Deklaruje <strong>stałą</strong>, której wartość musi być <strong>przypisana od razu</strong> i <strong>nie może być zmieniana</strong> później.</li>
<li>Ma <strong>zakres blokowy</strong>.</li>
<li>Jeśli przypiszesz do <code>const</code> obiekt lub tablicę, nie możesz przypisać do niej <em>nowego</em> obiektu/tablicy, ale możesz <strong>modyfikować zawartość</strong> tego obiektu/tablicy (np. dodawać lub usuwać elementy). <code>const</code> gwarantuje, że referencja (wskaźnik) do obiektu pozostaje taka sama, ale nie "zamraża" samego obiektu.</li>
<li>Używaj <code>const</code>, gdy wartość zmiennej nie powinna się zmieniać. To jest domyślny wybór w nowoczesnym JS, chyba że potrzebujesz <code>let</code>.</li>
</ul>
</li>
<li>
<p><strong><code>var</code></strong>:</p>
<ul>
<li><strong>Ma zakres funkcyjny</strong> (lub globalny, jeśli jest poza funkcją).</li>
<li>Jest podatny na <strong>hoisting</strong> (podnoszenie deklaracji), co oznacza, że deklaracja zmiennej jest "przenoszona" na początek zakresu, co może prowadzić do nieintuicyjnych zachowań.</li>
<li>Można go <strong>wielokrotnie deklarować</strong> w tym samym zakresie, co łatwo prowadzi do przypadkowych nadpisań.</li>
<li><strong>Unikaj używania <code>var</code> w nowym kodzie!</strong></li>
</ul>
</li>
</ul>
<p><strong>Przykład <code>const</code> z obiektem/tablicą:</strong></p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> tablica = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
tablica.<span class="hljs-title function_">push</span>(<span class="hljs-number">4</span>); <span class="hljs-comment">// DOZWOLONE! Zmieniamy zawartość tablicy, nie przypisujemy nowej tablicy.</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(tablica); <span class="hljs-comment">// Wyświetli: [1, 2, 3, 4]</span>

<span class="hljs-comment">// tablica = [5, 6]; // WYWOŁA BŁĄD! TypeError: Assignment to constant variable.</span>
<span class="hljs-comment">// Próbujesz przypisać zupełnie nową tablicę do stałej referencji.</span>

<span class="hljs-keyword">const</span> osoba = { <span class="hljs-attr">imie</span>: <span class="hljs-string">"Anna"</span>, <span class="hljs-attr">wiek</span>: <span class="hljs-number">28</span> };
osoba.<span class="hljs-property">wiek</span> = <span class="hljs-number">29</span>; <span class="hljs-comment">// DOZWOLONE! Zmieniamy właściwość obiektu, nie przypisujemy nowego obiektu.</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(osoba); <span class="hljs-comment">// Wyświetli: { imie: "Anna", wiek: 29 }</span>

<span class="hljs-comment">// osoba = { nazwisko: "Nowak" }; // WYWOŁA BŁĄD!</span>
</code></pre>
<hr>
<h2 id="funkcje-strzałkowe-arrow-functions-i-ich-zastosowania---krócej-i-czytelniej" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#funkcje-strzałkowe-arrow-functions-i-ich-zastosowania---krócej-i-czytelniej">>></a>Funkcje strzałkowe (Arrow Functions) i ich zastosowania - krócej i czytelniej</h2>
<p>Funkcje strzałkowe to zwięzła alternatywa dla tradycyjnych funkcji JavaScript, która została wprowadzona w ES6. Są nie tylko krótsze, ale także rozwiązują pewien problem z kontekstem <code>this</code>, który często mylił początkujących programistów.</p>
<h3 id="składnia-funkcji-strzałkowej" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#składnia-funkcji-strzałkowej">>>></a>Składnia funkcji strzałkowej</h3>
<p>Największą zaletą funkcji strzałkowych jest ich zwięzła składnia, zwłaszcza dla prostych funkcji.</p>
<ul>
<li>
<p><strong>Szybszy zapis (szczególnie dla funkcji jedno-liniowych):</strong>
Jeśli funkcja składa się tylko z jednej instrukcji, która zwraca wartość, możesz pominąć nawiasy klamrowe <code>{}</code> i słowo kluczowe <code>return</code>.</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// Tradycyjna funkcja</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">dodajStara</span>(<span class="hljs-params">a, b</span>) {
  <span class="hljs-keyword">return</span> a + b;
}

<span class="hljs-comment">// Funkcja strzałkowa (krótszy zapis)</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">dodaj</span> = (<span class="hljs-params">a, b</span>) => a + b;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">dodaj</span>(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">// Wyświetli: 8</span>

<span class="hljs-comment">// Funkcja z jednym argumentem (można pominąć nawiasy wokół argumentu)</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">powitanie</span> = (<span class="hljs-params">imie</span>) => <span class="hljs-string">`Cześć, <span class="hljs-subst">${imie}</span>!`</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">powitanie</span>(<span class="hljs-string">"Ola"</span>)); <span class="hljs-comment">// Wyświetli: Cześć, Ola!</span>

<span class="hljs-comment">// Funkcja bez argumentów (konieczne puste nawiasy)</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">powiedzHello</span> = (<span class="hljs-params"></span>) => <span class="hljs-string">"Hello!"</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">powiedzHello</span>()); <span class="hljs-comment">// Wyświetli: Hello!</span>
</code></pre>
</li>
<li>
<p><strong>Brak własnego obiektu <code>arguments</code>:</strong> Funkcje strzałkowe nie mają własnego obiektu <code>arguments</code> (który zawiera wszystkie argumenty przekazane do funkcji). Jeśli go potrzebujesz, użyj <strong>rest operatora</strong> (<code>...</code>), o którym powiemy później.</p>
</li>
<li>
<p><strong>Brak możliwości użycia jako konstruktor:</strong> Nie możesz użyć funkcji strzałkowej do tworzenia nowych obiektów za pomocą słowa kluczowego <code>new</code>.</p>
</li>
</ul>
<h3 id="funkcje-strzałkowe-a-kontekst-this" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#funkcje-strzałkowe-a-kontekst-this">>>></a>Funkcje strzałkowe a kontekst <code>this</code></h3>
<p>To jest jeden z najważniejszych powodów, dla których wprowadzono funkcje strzałkowe. W tradycyjnych funkcjach, wartość <code>this</code> zależy od tego, jak funkcja jest wywoływana. To prowadziło do częstych błędów, zwłaszcza w callbackach (funkcjach wywoływanych przez inne funkcje, np. w <code>setTimeout</code> czy w obsłudze zdarzeń).</p>
<p>Funkcje strzałkowe rozwiązują ten problem: <strong>nie mają własnego <code>this</code></strong>. Zamiast tego, <strong>dziedziczą <code>this</code> z otoczenia, w którym zostały zadeklarowane</strong> (tzw. leksykalny <code>this</code>).</p>
<p><strong>Przykład problemu ze <code>this</code> w tradycyjnych funkcjach:</strong></p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// Tradycyjna funkcja, która "gubi" kontekst this</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">TimerProblem</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">sekundy</span> = <span class="hljs-number">0</span>;
  <span class="hljs-built_in">setInterval</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-comment">// Tutaj 'this' nie odnosi się do obiektu TimerProblem,</span>
    <span class="hljs-comment">// ale do obiektu globalnego (np. window w przeglądarce) lub jest undefined w trybie 'strict mode'</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">sekundy</span>++; <span class="hljs-comment">// To nie zadziała tak, jak byśmy chcieli!</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">sekundy</span>);
  }, <span class="hljs-number">1000</span>);
}
<span class="hljs-comment">// new TimerProblem(); // W konsoli prawdopodobnie zobaczysz NaN lub błąd</span>
</code></pre>
<p><strong>Rozwiązanie z funkcją strzałkową:</strong></p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">TimerPoprawny</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">sekundy</span> = <span class="hljs-number">0</span>;
  <span class="hljs-comment">// Funkcja strzałkowa dziedziczy 'this' z TimerPoprawny (czyli z obiektu TimerPoprawny)</span>
  <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">sekundy</span>++;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Sekundy: <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.sekundy}</span>`</span>);
  }, <span class="hljs-number">1000</span>);
}
<span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerPoprawny</span>(); <span class="hljs-comment">// Będzie poprawnie liczyć sekundy: Sekundy: 1, Sekundy: 2, itd.</span>
</code></pre>
<p>Dzięki temu funkcje strzałkowe są idealne do użycia w callbackach, metodach obiektów (choć nie jako metody obiektów najwyższego poziomu, bo wtedy <code>this</code> wskazałoby na <code>window</code>), czy w sytuacjach, gdzie chcesz, aby <code>this</code> zachowało kontekst nadrzędny.</p>
<hr>
<h2 id="szablony-stringów-template-literals---łatwiejsza-praca-z-tekstem" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#szablony-stringów-template-literals---łatwiejsza-praca-z-tekstem">>></a>Szablony stringów (Template Literals) - łatwiejsza praca z tekstem</h2>
<p>Szablony stringów, wprowadzone w ES6, to potężne narzędzie do tworzenia ciągów znaków (stringów). Zastępują tradycyjne łączenie stringów za pomocą operatora <code>+</code> i oferują znacznie większą elastyczność i czytelność. Używamy ich, otaczając tekst <strong>backtickami</strong> (apostrofami wstecznymi) <code> </code> zamiast pojedynczych lub podwójnych cudzysłowów.</p>
<h3 id="interpolacja-i-wielolinijkowość" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#interpolacja-i-wielolinijkowość">>>></a>Interpolacja i wielolinijkowość</h3>
<ul>
<li>
<p><strong>Interpolacja zmiennych i wyrażeń:</strong>
Możesz łatwo osadzać zmienne lub dowolne wyrażenia JavaScript bezpośrednio w stringu, używając składni <code>${...}</code>. To znacznie ułatwia budowanie dynamicznych komunikatów.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> imie = <span class="hljs-string">"Alicja"</span>;
<span class="hljs-keyword">const</span> wiek = <span class="hljs-number">30</span>;

<span class="hljs-comment">// Stary sposób: męczące łączenie stringów</span>
<span class="hljs-keyword">const</span> infoStare = <span class="hljs-string">"Mam na imię "</span> + imie + <span class="hljs-string">" i mam "</span> + wiek + <span class="hljs-string">" lat."</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(infoStare); <span class="hljs-comment">// Wyświetli: Mam na imię Alicja i mam 30 lat.</span>

<span class="hljs-comment">// Nowy sposób z szablonami stringów: czytelniej i prościej!</span>
<span class="hljs-keyword">const</span> infoNowe = <span class="hljs-string">`Mam na imię <span class="hljs-subst">${imie}</span> i mam <span class="hljs-subst">${wiek}</span> lat.`</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(infoNowe); <span class="hljs-comment">// Wyświetli: Mam na imię Alicja i mam 30 lat.</span>

<span class="hljs-comment">// Możesz umieszczać dowolne wyrażenia JavaScript:</span>
<span class="hljs-keyword">const</span> cena = <span class="hljs-number">10.5</span>;
<span class="hljs-keyword">const</span> ilosc = <span class="hljs-number">2</span>;
<span class="hljs-keyword">const</span> rachunek = <span class="hljs-string">`Koszt zakupu: <span class="hljs-subst">${cena * ilosc}</span> zł.`</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(rachunek); <span class="hljs-comment">// Wyświetli: Koszt zakupu: 21 zł.</span>
</code></pre>
</li>
<li>
<p><strong>Łatwe tworzenie tekstów wielolinijkowych:</strong>
Koniec z dodawaniem <code>n</code> do każdej linii! W szablonach stringów możesz po prostu nacisnąć Enter, a tekst zachowa formatowanie z nowymi liniami. Jest to szczególnie przydatne przy generowaniu fragmentów HTML bezpośrednio w JavaScript.</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// Stary sposób: brzydkie i niewygodne</span>
<span class="hljs-keyword">const</span> htmlStare =
  <span class="hljs-string">"&#x3C;div>\n  &#x3C;h1>Witaj!&#x3C;/h1>\n  &#x3C;p>To jest wielolinijkowy tekst.&#x3C;/p>\n&#x3C;/div>"</span>;

<span class="hljs-comment">// Nowy sposób: super czytelne!</span>
<span class="hljs-keyword">const</span> htmlNowe = <span class="hljs-string">`
  &#x3C;div>
    &#x3C;h1>Witaj!&#x3C;/h1>
    &#x3C;p>To jest wielolinijkowy tekst. I kolejna linia w tym samym akapicie.&#x3C;/p>
  &#x3C;/div>
`</span>;

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(htmlNowe);
</code></pre>
</li>
</ul>
<h3 id="dodatkowe-możliwości" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#dodatkowe-możliwości">>>></a>Dodatkowe możliwości</h3>
<p>Szablony stringów wspierają także tzw. <strong>tagowane szablony</strong> (<code>tagged templates</code>), które pozwalają na zaawansowaną manipulację tekstem przed jego finalnym utworzeniem. Możesz zdefiniować funkcję ("tag"), która będzie przetwarzać części stringu i wartości zmiennych. Jest to bardziej zaawansowana funkcja, używana np. do tłumaczeń, walidacji, bezpiecznego generowania HTML (zapobieganie XSS) czy formatowania danych.</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// Przykład funkcji "tagującej"</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">upper</span>(<span class="hljs-params">strings, ...values</span>) {
  <span class="hljs-comment">// 'strings' to tablica tekstów, 'values' to tablica zmiennych</span>
  <span class="hljs-keyword">let</span> wynik = strings[<span class="hljs-number">0</span>];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &#x3C; values.<span class="hljs-property">length</span>; i++) {
    wynik += values[i].<span class="hljs-title function_">toUpperCase</span>() + strings[i + <span class="hljs-number">1</span>]; <span class="hljs-comment">// Zamienia zmienne na duże litery</span>
  }
  <span class="hljs-keyword">return</span> wynik;
}

<span class="hljs-keyword">const</span> imie = <span class="hljs-string">"Kasia"</span>;
<span class="hljs-keyword">const</span> wiek = <span class="hljs-number">20</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(upper<span class="hljs-string">`Cześć, <span class="hljs-subst">${imie}</span>! Masz <span class="hljs-subst">${wiek}</span> lat?`</span>); <span class="hljs-comment">// Wyświetli: Cześć, KASIA! Masz 20 lat?</span>
</code></pre>
<p>W tym przykładzie funkcja <code>upper</code> została "przypięta" do szablonu stringu i zmodyfikowała zmienną <code>imie</code> na wielkie litery.</p>
<hr>
<h2 id="destrukturyzacja-tablic-i-obiektów---wyciągnij-to-czego-potrzebujesz" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#destrukturyzacja-tablic-i-obiektów---wyciągnij-to-czego-potrzebujesz">>></a>Destrukturyzacja tablic i obiektów - wyciągnij to, czego potrzebujesz</h2>
<p>Destrukturyzacja to potężna i bardzo często używana funkcja w nowoczesnym JavaScript. Pozwala na "rozpakowanie" wartości z tablic lub właściwości z obiektów do oddzielnych zmiennych w bardzo zwięzły i czytelny sposób. Upraszcza kod i czyni go bardziej deklaratywnym.</p>
<h3 id="destrukturyzacja-tablic" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#destrukturyzacja-tablic">>>></a>Destrukturyzacja tablic</h3>
<p>Pozwala na szybkie przypisanie wartości z tablicy do zmiennych, bazując na ich pozycji.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> kolory = [<span class="hljs-string">"czerwony"</span>, <span class="hljs-string">"zielony"</span>, <span class="hljs-string">"niebieski"</span>];

<span class="hljs-comment">// Stary sposób:</span>
<span class="hljs-comment">// const kolor1 = kolory[0];</span>
<span class="hljs-comment">// const kolor2 = kolory[1];</span>

<span class="hljs-comment">// Nowy sposób z destrukturyzacją tablic:</span>
<span class="hljs-keyword">const</span> [pierwszyKolor, drugiKolor, trzeciKolor] = kolory;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pierwszyKolor); <span class="hljs-comment">// Wyświetli: czerwony</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(drugiKolor); <span class="hljs-comment">// Wyświetli: zielony</span>

<span class="hljs-comment">// Można pomijać niektóre elementy (używając przecinków):</span>
<span class="hljs-keyword">const</span> [a, , b] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]; <span class="hljs-comment">// Pomijamy drugi element (2)</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a, b); <span class="hljs-comment">// Wyświetli: 1 3</span>

<span class="hljs-comment">// Można przypisać wartości domyślne, jeśli element nie istnieje:</span>
<span class="hljs-keyword">const</span> [x, y, z = <span class="hljs-string">"domyślny"</span>] = [<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x, y, z); <span class="hljs-comment">// Wyświetli: A B domyślny</span>

<span class="hljs-comment">// Można zbierać pozostałe elementy do nowej tablicy (rest operator - patrz dalej):</span>
<span class="hljs-keyword">const</span> [pierwszy, ...resztaKolorow] = kolory;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pierwszy); <span class="hljs-comment">// Wyświetli: czerwony</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(resztaKolorow); <span class="hljs-comment">// Wyświetli: ["zielony", "niebieski"]</span>
</code></pre>
<h3 id="destrukturyzacja-obiektów" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#destrukturyzacja-obiektów">>>></a>Destrukturyzacja obiektów</h3>
<p>Pozwala na przypisanie wartości z obiektu do zmiennych na podstawie nazw ich <strong>kluczy (właściwości)</strong>. Kolejność nie ma znaczenia, liczy się nazwa klucza.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> samochod = { <span class="hljs-attr">marka</span>: <span class="hljs-string">"Ford"</span>, <span class="hljs-attr">model</span>: <span class="hljs-string">"Focus"</span>, <span class="hljs-attr">rok</span>: <span class="hljs-number">2018</span> };

<span class="hljs-comment">// Stary sposób:</span>
<span class="hljs-comment">// const markaSamochodu = samochod.marka;</span>
<span class="hljs-comment">// const modelSamochodu = samochod.model;</span>

<span class="hljs-comment">// Nowy sposób z destrukturyzacją obiektów:</span>
<span class="hljs-keyword">const</span> { marka, model } = samochod;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(marka); <span class="hljs-comment">// Wyświetli: Ford</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(model); <span class="hljs-comment">// Wyświetli: Focus</span>

<span class="hljs-comment">// Można przypisać wartości domyślne, jeśli właściwość nie istnieje:</span>
<span class="hljs-keyword">const</span> { <span class="hljs-attr">marka</span>: m, kolor = <span class="hljs-string">"czarny"</span> } = samochod; <span class="hljs-comment">// 'kolor' nie istnieje w obiekcie 'samochod'</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(m, kolor); <span class="hljs-comment">// Wyświetli: Ford czarny</span>

<span class="hljs-comment">// Można zmienić nazwę zmiennej, do której przypisujemy wartość:</span>
<span class="hljs-keyword">const</span> { <span class="hljs-attr">marka</span>: nazwaMarki, <span class="hljs-attr">model</span>: typModelu } = samochod;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(nazwaMarki, typModelu); <span class="hljs-comment">// Wyświetli: Ford Focus</span>

<span class="hljs-comment">// Można też zbierać pozostałe właściwości do nowego obiektu (rest operator - patrz dalej):</span>
<span class="hljs-keyword">const</span> { rok, ...resztaSamochodu } = samochod;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(rok); <span class="hljs-comment">// Wyświetli: 2018</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(resztaSamochodu); <span class="hljs-comment">// Wyświetli: { marka: "Ford", model: "Focus" }</span>
</code></pre>
<p>Destrukturyzacja jest szczególnie przydatna w funkcjach, gdy chcesz łatwo wyciągnąć konkretne dane z obiektów konfiguracyjnych lub z wyników API.</p>
<hr>
<h2 id="spread-i-rest-operator----elastyczność-w-manipulacji-danymi" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#spread-i-rest-operator----elastyczność-w-manipulacji-danymi">>></a>Spread i Rest Operator (<code>...</code>) - elastyczność w manipulacji danymi</h2>
<p>Operator <code>...</code> (trzy kropki) jest jednym z najbardziej uniwersalnych i potężnych narzędzi w nowoczesnym JavaScript. Nazywany jest <strong>operatorem spread</strong> lub <strong>operatorem rest</strong>, w zależności od kontekstu, w jakim jest używany.</p>
<h3 id="spread-operator-operator-rozproszenia" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#spread-operator-operator-rozproszenia">>>></a>Spread Operator (operator rozproszenia)</h3>
<p>Gdy używasz <code>...</code> do <strong>rozbicia</strong> elementów tablicy lub właściwości obiektu na pojedyncze elementy, mówimy o <strong>operatorze spread</strong>. Jest to jak "rozłożenie" zawartości kolekcji. 🌐</p>
<p><strong>Zastosowania Spread Operatora:</strong></p>
<ul>
<li>
<p><strong>Kopiowanie i łączenie tablic:</strong> Tworzenie płytkich kopii tablic lub łączenie ich bez modyfikowania oryginalnych.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> cyfry = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-keyword">const</span> noweCyfry = [...cyfry, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]; <span class="hljs-comment">// Rozwija [1, 2, 3] do 1, 2, 3, a potem dodaje 4, 5</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(noweCyfry); <span class="hljs-comment">// Wyświetli: [1, 2, 3, 4, 5]</span>

<span class="hljs-keyword">const</span> tablica1 = [<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>];
<span class="hljs-keyword">const</span> tablica2 = [<span class="hljs-string">"c"</span>, <span class="hljs-string">"d"</span>];
<span class="hljs-keyword">const</span> polaczoneTablice = [...tablica1, ...tablica2];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(polaczoneTablice); <span class="hljs-comment">// Wyświetli: ["a", "b", "c", "d"]</span>
</code></pre>
</li>
<li>
<p><strong>Kopiowanie i łączenie obiektów:</strong> Podobnie jak z tablicami, możesz tworzyć kopie obiektów i łączyć ich właściwości.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> osoba = { <span class="hljs-attr">imie</span>: <span class="hljs-string">"Anna"</span>, <span class="hljs-attr">wiek</span>: <span class="hljs-number">28</span> };
<span class="hljs-keyword">const</span> osobaZZawodem = { ...osoba, <span class="hljs-attr">zawod</span>: <span class="hljs-string">"Programista"</span> };
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(osobaZZawodem); <span class="hljs-comment">// Wyświetli: { imie: "Anna", wiek: 28, zawod: "Programista" }</span>

<span class="hljs-keyword">const</span> daneKontaktowe = { <span class="hljs-attr">email</span>: <span class="hljs-string">"a@example.com"</span>, <span class="hljs-attr">telefon</span>: <span class="hljs-string">"123-456-789"</span> };
<span class="hljs-keyword">const</span> pelneDane = { ...osoba, ...daneKontaktowe };
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pelneDane); <span class="hljs-comment">// Wyświetli: { imie: "Anna", wiek: 28, email: "a@example.com", telefon: "123-456-789" }</span>
</code></pre>
<p>Jeśli klucze się powtarzają, ostatnia wartość nadpisuje poprzednią.</p>
</li>
<li>
<p><strong>Przekazywanie argumentów funkcji:</strong> Możesz rozwijać tablicę jako argumenty funkcji.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sumuj</span>(<span class="hljs-params">a, b, c</span>) {
  <span class="hljs-keyword">return</span> a + b + c;
}
<span class="hljs-keyword">const</span> liczby = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sumuj</span>(...liczby)); <span class="hljs-comment">// Rozwija [10, 20, 30] do sumuj(10, 20, 30), wyświetli: 60</span>
</code></pre>
</li>
</ul>
<h3 id="rest-operator-operator-reszty" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#rest-operator-operator-reszty">>>></a>Rest Operator (operator reszty)</h3>
<p>Gdy używasz <code>...</code> do <strong>zbierania</strong> wielu elementów w jedną tablicę (lub właściwości w obiekt), mówimy o <strong>operatorze rest</strong>. Jest to jak "zbieranie" luźnych elementów w jedną kolekcję. 🧺</p>
<p><strong>Zastosowania Rest Operatora:</strong></p>
<ul>
<li>
<p><strong>Zbieranie argumentów funkcji:</strong> Pozwala funkcji przyjmować nieokreśloną liczbę argumentów i traktować je jako tablicę.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">suma</span>(<span class="hljs-params">...liczby</span>) {
  <span class="hljs-comment">// 'liczby' zbiera wszystkie przekazane argumenty w tablicę</span>
  <span class="hljs-keyword">return</span> liczby.<span class="hljs-title function_">reduce</span>(
    <span class="hljs-function">(<span class="hljs-params">akumulator, aktualnaLiczba</span>) =></span> akumulator + aktualnaLiczba,
    <span class="hljs-number">0</span>
  );
}
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">suma</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">// Wyświetli: 6</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">suma</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>)); <span class="hljs-comment">// Wyświetli: 100</span>
</code></pre>
</li>
<li>
<p><strong>W destrukturyzacji (jak widzieliśmy wcześniej):</strong> Zbieranie pozostałych elementów do nowej tablicy lub obiektu.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> [pierwszy, drugi, ...resztaTablicy] = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pierwszy); <span class="hljs-comment">// Wyświetli: 10</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(drugi); <span class="hljs-comment">// Wyświetli: 20</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(resztaTablicy); <span class="hljs-comment">// Wyświetli: [30, 40, 50]</span>

<span class="hljs-keyword">const</span> { imie, ...resztaOsoby } = {
  <span class="hljs-attr">imie</span>: <span class="hljs-string">"Ola"</span>,
  <span class="hljs-attr">wiek</span>: <span class="hljs-number">25</span>,
  <span class="hljs-attr">miasto</span>: <span class="hljs-string">"Warszawa"</span>,
};
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(imie); <span class="hljs-comment">// Wyświetli: Ola</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(resztaOsoby); <span class="hljs-comment">// Wyświetli: { wiek: 25, miasto: "Warszawa" }</span>
</code></pre>
</li>
</ul>
<p>Zarówno spread, jak i rest operator są niezwykle przydatne i sprawiają, że kod jest znacznie bardziej zwięzły i czytelny, szczególnie podczas pracy z tablicami i obiektami.</p>
<hr>
<h2 id="promise-api-i-obsługa-asynchroniczności---opowiadaj-historie-o-przyszłości" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#promise-api-i-obsługa-asynchroniczności---opowiadaj-historie-o-przyszłości">>></a>Promise API i obsługa asynchroniczności - opowiadaj historie o przyszłości</h2>
<p>JavaScript jest językiem <strong>jednowątkowym</strong>, co oznacza, że może wykonywać tylko jedną operację w danym momencie. Jednak wiele operacji, takich jak pobieranie danych z internetu, odczyt plików, czy operacje na bazie danych, trwa pewien czas. Gdyby JavaScript musiał czekać na ich zakończenie, strona internetowa by się "zawiesiła" (nie reagowałaby na kliknięcia, przewijanie itp.).</p>
<p>Tutaj wkracza <strong>asynchroniczność</strong>. Pozwala ona na rozpoczęcie operacji, a następnie przejście do kolejnych zadań, nie czekając na zakończenie tej pierwszej. Kiedy asynchroniczna operacja się zakończy, JavaScript wróci do niej i wykona dalsze kroki.</p>
<p>Starszym sposobem obsługi asynchroniczności były <strong>callbacki</strong> (funkcje zwrotne), które jednak często prowadziły do tzw. "callback hell" (piekła callbacków) - zagnieżdżonego, trudnego do czytania i utrzymania kodu.</p>
<h3 id="czym-jest-promise" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#czym-jest-promise">>>></a>Czym jest Promise?</h3>
<p><strong>Promise (Obietnica)</strong> to obiekt w JavaScript, który reprezentuje ostateczne zakończenie (lub niepowodzenie) operacji asynchronicznej. Możesz myśleć o Promise jako o "przyszłej wartości". Składasz obietnicę, że w przyszłości otrzymasz wynik - albo sukces, albo błąd. 📦</p>
<p>Promise może znajdować się w jednym z trzech stanów:</p>
<ol>
<li><strong><code>pending</code> (oczekujący)</strong>: Początkowy stan; ani spełniony, ani odrzucony. Operacja asynchroniczna nadal trwa.</li>
<li><strong><code>fulfilled</code> (spełniony)</strong>: Operacja asynchroniczna zakończyła się sukcesem i zwróciła wartość.</li>
<li><strong><code>rejected</code> (odrzucony)</strong>: Operacja asynchroniczna zakończyła się błędem.</li>
</ol>
<p>Możesz "podpiąć" funkcje, które zostaną wywołane, gdy Promise zmieni swój stan:</p>
<ul>
<li><strong><code>.then()</code></strong>: Wywoływany, gdy Promise zostanie <code>fulfilled</code> (operacja zakończy się sukcesem). Otrzymuje wartość zwróconą przez Promise.</li>
<li><strong><code>.catch()</code></strong>: Wywoływany, gdy Promise zostanie <code>rejected</code> (wystąpi błąd). Otrzymuje obiekt błędu.</li>
<li><strong><code>.finally()</code></strong>: Wywoływany zawsze, niezależnie od tego, czy Promise zakończył się sukcesem, czy błędem. Idealny do czyszczenia zasobów.</li>
</ul>
<p><strong>Przykład tworzenia i używania Promise:</strong></p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> obietnica = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> {
  <span class="hljs-comment">// Symulujemy operację asynchroniczną (np. pobieranie danych)</span>
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-keyword">const</span> sukces = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() > <span class="hljs-number">0.5</span>; <span class="hljs-comment">// Losowo decydujemy o sukcesie lub błędzie</span>

    <span class="hljs-keyword">if</span> (sukces) {
      <span class="hljs-title function_">resolve</span>(<span class="hljs-string">"Dane pobrane pomyślnie!"</span>); <span class="hljs-comment">// Jeśli sukces, wywołujemy resolve z wynikiem</span>
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"Nie udało się pobrać danych."</span>)); <span class="hljs-comment">// Jeśli błąd, wywołujemy reject z błędem</span>
    }
  }, <span class="hljs-number">2000</span>); <span class="hljs-comment">// Operacja trwa 2 sekundy</span>
});

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Rozpoczęto operację..."</span>);

obietnica
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">wiadomosc</span>) =></span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"SUKCES:"</span>, wiadomosc); <span class="hljs-comment">// Wykona się, jeśli obietnica się spełni</span>
  })
  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">blad</span>) =></span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"BŁĄD:"</span>, blad.<span class="hljs-property">message</span>); <span class="hljs-comment">// Wykona się, jeśli obietnica zostanie odrzucona</span>
  })
  .<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Operacja zakończona (niezależnie od wyniku)."</span>); <span class="hljs-comment">// Wykona się zawsze</span>
  });

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Kod po obietnicy nadal się wykonuje..."</span>); <span class="hljs-comment">// Pokazuje asynchroniczność</span>
</code></pre>
<h3 id="łańcuchy-promise-promise-chaining" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#łańcuchy-promise-promise-chaining">>>></a>Łańcuchy Promise (<code>Promise Chaining</code>)</h3>
<p>Jedną z największych zalet Promise jest możliwość łączenia wielu operacji asynchronicznych w jeden czytelny "łańcuch". Każdy <code>.then()</code> zwraca nowy Promise, co pozwala na kolejne <code>.then()</code> wywołane po sobie. Jest to idealne, gdy jedna operacja asynchroniczna zależy od wyniku poprzedniej.</p>
<p><strong>Przykład łańcucha Promise (pobieranie danych z API):</strong></p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// fetch() to wbudowana funkcja JS, która zwraca Promise</span>
<span class="hljs-title function_">fetch</span>(<span class="hljs-string">"https://jsonplaceholder.typicode.com/users/1"</span>) <span class="hljs-comment">// Pobierz dane użytkownika o ID 1</span>
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">response</span>) =></span> {
    <span class="hljs-comment">// Pierwsze .then: sprawdź, czy odpowiedź jest OK i sparsuj ją jako JSON</span>
    <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`Błąd HTTP! Status: <span class="hljs-subst">${response.status}</span>`</span>);
    }
    <span class="hljs-keyword">return</span> response.<span class="hljs-title function_">json</span>(); <span class="hljs-comment">// Zwróć kolejny Promise z danymi JSON</span>
  })
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">user</span>) =></span> {
    <span class="hljs-comment">// Drugie .then: otrzymaj sparsowane dane użytkownika</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Pobrany użytkownik:"</span>, user.<span class="hljs-property">name</span>, user.<span class="hljs-property">email</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">fetch</span>(
      <span class="hljs-string">`https://jsonplaceholder.typicode.com/posts?userId=<span class="hljs-subst">${user.id}</span>`</span>
    ); <span class="hljs-comment">// Pobierz posty tego użytkownika</span>
  })
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">response</span>) =></span> {
    <span class="hljs-comment">// Trzecie .then: sprawdź odpowiedź i sparsuj posty</span>
    <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`Błąd HTTP! Status: <span class="hljs-subst">${response.status}</span>`</span>);
    }
    <span class="hljs-keyword">return</span> response.<span class="hljs-title function_">json</span>();
  })
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">posts</span>) =></span> {
    <span class="hljs-comment">// Czwarte .then: otrzymaj posty</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Liczba postów użytkownika:"</span>, posts.<span class="hljs-property">length</span>);
  })
  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =></span> {
    <span class="hljs-comment">// .catch: Obsłuż każdy błąd, który wystąpił na dowolnym etapie łańcucha</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"Wystąpił błąd w łańcuchu Promise:"</span>, error);
  })
  .<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Pobieranie danych zakończone."</span>);
  });
</code></pre>
<p>Promise to podstawa nowoczesnego JS w obsłudze asynchroniczności, a kolejny rozdział pokaże Ci, jak jeszcze bardziej uprościć ich użycie.</p>
<hr>
<h2 id="asyncawait---nowoczesna-obsługa-kodu-asynchronicznego---pisz-asynchronicznie-myśl-synchronicznie" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#asyncawait---nowoczesna-obsługa-kodu-asynchronicznego---pisz-asynchronicznie-myśl-synchronicznie">>></a>Async/await - nowoczesna obsługa kodu asynchronicznego - pisz asynchronicznie, myśl synchronicznie</h2>
<p>Mimo że Promise są ogromnym krokiem naprzód w porównaniu do callbacków, kod z długimi łańcuchami <code>.then().then().catch()</code> może wciąż być trudny do czytania. Standard ES2017 wprowadził słowa kluczowe <strong><code>async</code></strong> i <strong><code>await</code></strong>, które pozwalają pisać kod asynchroniczny w sposób, który wygląda i zachowuje się niemal identycznie jak kod synchroniczny, jednocześnie zachowując asynchroniczną naturę. To game changer! 🎮</p>
<h3 id="uproszczenie-pracy-z-promise" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#uproszczenie-pracy-z-promise">>>></a>Uproszczenie pracy z Promise</h3>
<ul>
<li><strong><code>async</code></strong>: Musisz oznaczyć funkcję słowem kluczowym <code>async</code>, aby móc używać w niej <code>await</code>. Funkcja <code>async</code> <strong>zawsze zwraca Promise</strong>, nawet jeśli zwrócisz w niej zwykłą wartość - JavaScript automatycznie opakuje ją w Promise.</li>
<li><strong><code>await</code></strong>: Słowo kluczowe <code>await</code> może być użyte <strong>tylko wewnątrz funkcji <code>async</code></strong>. Powoduje ono, że wykonanie funkcji <code>async</code> zostaje <strong>wstrzymane</strong>, dopóki Promise, na który czeka <code>await</code>, nie zostanie <strong>spełniony (fulfilled)</strong>. Kiedy Promise się spełni, <code>await</code> "rozpakowuje" jego wartość i przypisuje ją do zmiennej. Jeśli Promise zostanie odrzucony (rejected), <code>await</code> "wyrzuci" błąd, który możesz obsłużyć za pomocą <code>try...catch</code>.</li>
</ul>
<p><strong>Przykład użycia <code>async/await</code> (porównaj z przykładem z Promise Chaining):</strong></p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">pobierzDaneUzytkownikaIPosty</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Rozpoczynam pobieranie danych..."</span>);

    <span class="hljs-comment">// Krok 1: Pobierz dane użytkownika</span>
    <span class="hljs-keyword">const</span> userResponse = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(
      <span class="hljs-string">"https://jsonplaceholder.typicode.com/users/1"</span>
    );
    <span class="hljs-keyword">if</span> (!userResponse.<span class="hljs-property">ok</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(
        <span class="hljs-string">`Błąd HTTP przy pobieraniu użytkownika! Status: <span class="hljs-subst">${userResponse.status}</span>`</span>
      );
    }
    <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> userResponse.<span class="hljs-title function_">json</span>(); <span class="hljs-comment">// Poczekaj na parsowanie JSON</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Pobrany użytkownik:"</span>, user.<span class="hljs-property">name</span>, user.<span class="hljs-property">email</span>);

    <span class="hljs-comment">// Krok 2: Pobierz posty tego użytkownika</span>
    <span class="hljs-keyword">const</span> postsResponse = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(
      <span class="hljs-string">`https://jsonplaceholder.typicode.com/posts?userId=<span class="hljs-subst">${user.id}</span>`</span>
    );
    <span class="hljs-keyword">if</span> (!postsResponse.<span class="hljs-property">ok</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(
        <span class="hljs-string">`Błąd HTTP przy pobieraniu postów! Status: <span class="hljs-subst">${postsResponse.status}</span>`</span>
      );
    }
    <span class="hljs-keyword">const</span> posts = <span class="hljs-keyword">await</span> postsResponse.<span class="hljs-title function_">json</span>(); <span class="hljs-comment">// Poczekaj na parsowanie JSON</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Liczba postów użytkownika:"</span>, posts.<span class="hljs-property">length</span>);

    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Wszystkie dane zostały pobrane pomyślnie."</span>);
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-comment">// Obsługa każdego błędu, który wystąpił na dowolnym etapie</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"Wystąpił błąd w funkcji async:"</span>, error.<span class="hljs-property">message</span>);
  } <span class="hljs-keyword">finally</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Operacja pobierania danych zakończona."</span>);
  }
}

<span class="hljs-comment">// Wywołanie funkcji async</span>
<span class="hljs-title function_">pobierzDaneUzytkownikaIPosty</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Kod poza funkcją async nadal się wykonuje..."</span>); <span class="hljs-comment">// Pokazuje asynchroniczność</span>
</code></pre>
<p>Widzisz, jak kod stał się znacznie bardziej liniowy i czytelny? Wygląda to prawie jak tradycyjny kod synchroniczny, mimo że w tle nadal działają Promise i cała magia asynchroniczności.</p>
<h3 id="zwracanie-wartości-i-obsługa-błędów" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#zwracanie-wartości-i-obsługa-błędów">>>></a>Zwracanie wartości i obsługa błędów</h3>
<ul>
<li>
<p><strong>Zwracanie wartości z funkcji <code>async</code></strong>:
Jeśli funkcja <code>async</code> zwraca jakąś wartość, ta wartość jest automatycznie opakowywana w Promise, który zostanie spełniony z tą wartością.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">zwrocLiczbe</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// Możesz też użyć await, np. await Promise.resolve(42);</span>
  <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;
}
<span class="hljs-title function_">zwrocLiczbe</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">val</span>) =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(val)); <span class="hljs-comment">// Wyświetli: 42</span>
</code></pre>
</li>
<li>
<p><strong>Obsługa błędów z <code>try...catch</code></strong>:
Największą zaletą <code>async/await</code> jest to, że pozwala na używanie standardowych bloków <code>try...catch</code> do obsługi błędów w kodzie asynchronicznym. Jeśli Promise, na który czeka <code>await</code>, zostanie odrzucony (rejected), <code>await</code> "rzuci" błąd, który zostanie przechwycony przez blok <code>catch</code>.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">symulujBlad</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> {
      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"Coś poszło nie tak!"</span>)), <span class="hljs-number">1000</span>);
    });
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result); <span class="hljs-comment">// To się nie wykona</span>
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"Złapano błąd:"</span>, error.<span class="hljs-property">message</span>); <span class="hljs-comment">// Wyświetli: Złapano błąd: Coś poszło nie tak!</span>
  }
}
<span class="hljs-title function_">symulujBlad</span>();
</code></pre>
</li>
</ul>
<p><code>async/await</code> to obecnie <strong>najczęściej rekomendowany</strong> sposób pracy z asynchronicznością w JavaScript, ponieważ znacząco poprawia czytelność i łatwość utrzymania kodu, sprawiając, że złożone operacje asynchroniczne stają się bardziej przejrzyste.</p>
<hr>
<h2 id="zadania-do-wykonania-sprawdź-swoją-wiedzę" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#zadania-do-wykonania-sprawdź-swoją-wiedzę">>></a>Zadania do wykonania: Sprawdź swoją wiedzę!</h2>
<p>Czas na praktykę! Rozwiąż te zadania, aby utrwalić to, czego się nauczyłeś/aś. Po każdym zadaniu możesz rozwinąć sekcję <code>Pokaż rozwiązanie</code>, aby sprawdzić swój kod. Powodzenia! 💪</p>
<h3 id="zadanie-1" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#zadanie-1">>>></a>Zadanie 1</h3>
<p>Napisz <strong>funkcję strzałkową</strong>, która przyjmuje dowolną liczbę argumentów numerycznych i zwraca ich sumę. Użyj <strong>rest operatora</strong> do zebrania argumentów.</p>
<details>
<summary>
<span>Pokaż rozwiązanie</span>
</summary>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">sumaWszystkichLiczb</span> = (<span class="hljs-params">...liczby</span>) => {
  <span class="hljs-keyword">return</span> liczby.<span class="hljs-title function_">reduce</span>(
    <span class="hljs-function">(<span class="hljs-params">akumulator, aktualnaLiczba</span>) =></span> akumulator + aktualnaLiczba,
    <span class="hljs-number">0</span>
  );
};

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sumaWszystkichLiczb</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">// Oczekiwany wynik: 6</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sumaWszystkichLiczb</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>)); <span class="hljs-comment">// Oczekiwany wynik: 100</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sumaWszystkichLiczb</span>()); <span class="hljs-comment">// Oczekiwany wynik: 0</span>
</code></pre>
</details>
<hr>
<h3 id="zadanie-2" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#zadanie-2">>>></a>Zadanie 2</h3>
<p>Utwórz obiekt reprezentujący produkt z kluczami: <code>nazwa</code>, <code>cena</code>, <code>dostepny</code>. Następnie użyj <strong>destrukturyzacji obiektu</strong>, aby wyodrębnić te wartości do osobnych zmiennych i wyświetlić je w konsoli. Dodaj również zmienną <code>producent</code> z wartością domyślną "Nieznany", na wypadek gdyby nie było jej w obiekcie.</p>
<details>
<summary>
<span>Pokaż rozwiązanie</span>
</summary>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> produkt = { <span class="hljs-attr">nazwa</span>: <span class="hljs-string">"Książka JS"</span>, <span class="hljs-attr">cena</span>: <span class="hljs-number">49.99</span>, <span class="hljs-attr">dostepny</span>: <span class="hljs-literal">true</span> };

<span class="hljs-keyword">const</span> { nazwa, cena, dostepny, producent = <span class="hljs-string">"Nieznany"</span> } = produkt;

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Nazwa: <span class="hljs-subst">${nazwa}</span>`</span>); <span class="hljs-comment">// Oczekiwany wynik: Nazwa: Książka JS</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Cena: <span class="hljs-subst">${cena}</span> zł`</span>); <span class="hljs-comment">// Oczekiwany wynik: Cena: 49.99 zł</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Dostępny: <span class="hljs-subst">${dostepny}</span>`</span>); <span class="hljs-comment">// Oczekiwany wynik: Dostępny: true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Producent: <span class="hljs-subst">${producent}</span>`</span>); <span class="hljs-comment">// Oczekiwany wynik: Producent: Nieznany</span>
</code></pre>
</details>
<hr>
<h3 id="zadanie-3" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#zadanie-3">>>></a>Zadanie 3</h3>
<p>Stwórz tablicę ulubionych filmów. Następnie użyj <strong>operatora spread</strong> do utworzenia nowej tablicy, która będzie zawierać wszystkie te filmy plus dwa dodatkowe filmy na końcu. Wyświetl nową tablicę w konsoli.</p>
<details>
<summary>
<span>Pokaż rozwiązanie</span>
</summary>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> ulubioneFilmy = [<span class="hljs-string">"Incepcja"</span>, <span class="hljs-string">"Matrix"</span>, <span class="hljs-string">"Interstellar"</span>];

<span class="hljs-keyword">const</span> nowaListaFilmow = [...ulubioneFilmy, <span class="hljs-string">"Pulp Fiction"</span>, <span class="hljs-string">"Forrest Gump"</span>];

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(nowaListaFilmow);
<span class="hljs-comment">// Oczekiwany wynik: ["Incepcja", "Matrix", "Interstellar", "Pulp Fiction", "Forrest Gump"]</span>
</code></pre>
</details>
<hr>
<h3 id="zadanie-4" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#zadanie-4">>>></a>Zadanie 4</h3>
<p>Napisz <strong>funkcję asynchroniczną</strong> o nazwie <code>pobierzWiadomosc</code>, która symuluje pobieranie wiadomości z serwera. Funkcja powinna używać <code>setTimeout</code>, aby po 3 sekundach zwrócić tekst "Wiadomość pobrana!". Użyj <code>async/await</code> do wywołania tej funkcji i wyświetlenia jej wyniku w konsoli. Dodaj również blok <code>try...catch</code> do obsługi potencjalnych błędów.</p>
<details>
<summary>
<span>Pokaż rozwiązanie</span>
</summary>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// Funkcja symulująca pobieranie danych (zwraca Promise)</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">pobierzWiadomoscAPI</span> = (<span class="hljs-params"></span>) => {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> {
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> {
      <span class="hljs-comment">// Możesz zmienić to na reject, aby przetestować obsługę błędów</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() > <span class="hljs-number">0.1</span>) {
        <span class="hljs-comment">// 90% szans na sukces, 10% na błąd</span>
        <span class="hljs-title function_">resolve</span>(<span class="hljs-string">"Wiadomość pobrana pomyślnie!"</span>);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"Błąd podczas pobierania wiadomości!"</span>));
      }
    }, <span class="hljs-number">3000</span>); <span class="hljs-comment">// Symulujemy 3 sekundy oczekiwania</span>
  });
};

<span class="hljs-comment">// Funkcja asynchroniczna używająca async/await</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">pobierzWiadomosc</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Rozpoczynam pobieranie wiadomości..."</span>);
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> wiadomosc = <span class="hljs-keyword">await</span> <span class="hljs-title function_">pobierzWiadomoscAPI</span>(); <span class="hljs-comment">// Czekaj, aż Promise się spełni</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Sukces:"</span>, wiadomosc);
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"Wystąpił błąd:"</span>, error.<span class="hljs-property">message</span>); <span class="hljs-comment">// Złap i wyświetl błąd</span>
  } <span class="hljs-keyword">finally</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Zakończono próbę pobierania wiadomości."</span>);
  }
}

<span class="hljs-comment">// Wywołaj funkcję asynchroniczną</span>
<span class="hljs-title function_">pobierzWiadomosc</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(
  <span class="hljs-string">"Ten tekst wyświetli się natychmiast po uruchomieniu programu, zanim wiadomość zostanie pobrana."</span>
);
</code></pre>
</details>
<hr>
<p>Gratulacje! 🎉 Dotarłeś/aś do końca kursu wprowadzającego w nowoczesny JavaScript. Masz teraz solidne podstawy do dalszego rozwoju. Pamiętaj, że kluczem jest praktyka - im więcej będziesz kodować, tym lepiej zrozumiesz te koncepcje.</p>
<p>Co chciałbyś/chciałabyś zgłębić dalej? Może:</p>
<ul>
<li><strong>Moduły ES6</strong> (import/export)?</li>
<li><strong>Klasy</strong> w JavaScript (obiektowość)?</li>
<li><strong>Metody tablicowe</strong> (map, filter, reduce)?</li>
<li>Głębsze nurkowanie w <strong>asynchroniczność</strong> i Web API?</li>
</ul>
<p>Daj znać! 😊</p></article><div class="container prose"><h2>Quiz: Podstawy nowoczesnego JavaScript</h2><div><p class="font-bold mb-0!">Pytanie <!-- -->1<!-- --> z <!-- -->5</p><div class="prose-p:mt-2"><p>Jaką główną różnicę między <code>let</code> a <code>var</code> podkreśla się w nowoczesnym JavaScript?</p></div><div class="grid grid-flow-row gap-3"><button data-slot="button" class="button button--variant-outline button--size-sm w-full text-left inline-flex justify-start transition-none text-wrap! min-h-min! py-1.5 cursor-pointer">Obie są identyczne</button><button data-slot="button" class="button button--variant-outline button--size-sm w-full text-left inline-flex justify-start transition-none text-wrap! min-h-min! py-1.5 cursor-pointer">`let` nie pozwala na przyjmowanie wartości domyślnej</button><button data-slot="button" class="button button--variant-outline button--size-sm w-full text-left inline-flex justify-start transition-none text-wrap! min-h-min! py-1.5 cursor-pointer">Zakres blokowy (`block scope`) w `let`</button><button data-slot="button" class="button button--variant-outline button--size-sm w-full text-left inline-flex justify-start transition-none text-wrap! min-h-min! py-1.5 cursor-pointer">`var` nie istnieje w nowoczesnym JS</button></div></div></div><div class="container"><p class="button button--variant-secondary button--size-lg w-full p-10 text-wrap flex-wrap h-auto text-center gap-y-4 text-wrap!" data-slot="button">Widzisz jakiś błąd, bądź literówkę? Chcesz coś poprawić?<a href="https://github.com/jakubszpil/jakubszpil.github.io/edit/main/app/content/courses/nowoczesny-javascript.md" target="_blank" rel="noreferrer" data-slot="button" class="button button--variant-link button--size-default">✏️ Przejdź do edycji tego pliku</a></p></div></main><footer class="prose max-w-full border-t"><div class="container flex items-center gap-3 justify-start flex-wrap-reverse lg:justify-between"><p class="xl:text-sm">© <!-- -->2025<a data-slot="button" class="button button--variant-link button--size-sm" href="/" data-discover="true">jakubszpil</a></p><nav class="flex items-center flex-wrap -ml-3"><a data-slot="button" class="button button--variant-link button--size-sm" href="/" data-discover="true">🏠 Strona główna</a><a data-slot="button" class="button button--variant-link button--size-sm" href="/blog" data-discover="true">📝 Blog</a><a data-slot="button" class="button button--variant-link button--size-sm" href="/learning" data-discover="true">🏫 Learning</a><a data-slot="button" class="button button--variant-link button--size-sm" href="/portfolio" data-discover="true">🛠️ Portfolio</a><a data-slot="button" class="button button--variant-link button--size-sm" href="/me" data-discover="true">🙋‍♂️ O mnie</a><a data-slot="button" class="button button--variant-link button--size-sm" href="/search" data-discover="true">🔍 Szukaj</a><a data-slot="button" class="button button--variant-link button--size-sm" href="/handbook" data-discover="true">📋 Handbook</a></nav></div></footer><script>((storageKey2, restoreKey) => {
    if (!window.history.state || !window.history.state.key) {
      let key = Math.random().toString(32).slice(2);
      window.history.replaceState({ key }, "");
    }
    try {
      let positions = JSON.parse(sessionStorage.getItem(storageKey2) || "{}");
      let storedY = positions[restoreKey || window.history.state.key];
      if (typeof storedY === "number") {
        window.scrollTo(0, storedY);
      }
    } catch (error) {
      console.error(error);
      sessionStorage.removeItem(storageKey2);
    }
  })("react-router-scroll-positions", "/learning/nowoczesny-javascript/.default")</script><script>window.__reactRouterContext = {"basename":"/","future":{"v8_middleware":false,"unstable_optimizeDeps":true,"unstable_splitRouteModules":true,"unstable_subResourceIntegrity":false,"unstable_viteEnvironmentApi":true},"routeDiscovery":{"mode":"initial"},"ssr":false,"isSpaMode":false};window.__reactRouterContext.stream = new ReadableStream({start(controller){window.__reactRouterContext.streamController = controller;}}).pipeThrough(new TextEncoderStream());</script><script type="module" async="">import "/assets/manifest-b7f9055d.js";
import * as route0 from "/assets/root-BT3np3FX.js";
import * as route1 from "/assets/layout-DYpV2se7.js";
import * as route2 from "/assets/course-details-DLJ6fZBl.js";
  
  window.__reactRouterRouteModules = {"root":route0,"routes/layout":route1,"course-details":route2};

import("/assets/entry.client-D07Jc1yP.js");</script><!--$?--><template id="B:0"></template><!--/$--><script id="_R_">requestAnimationFrame(function(){$RT=performance.now()});</script><div hidden id="S:0"><script>window.__reactRouterContext.streamController.enqueue("[{\"_1\":2,\"_7\":-5,\"_8\":-5},\"loaderData\",{\"_3\":4},\"course-details\",{\"_5\":6},\"v\",\"㞂⁆⁜⁊੠㬸ᧀ蘎䀈໩腈ಠദ̘נ➀㘂婠胶\\uda31䨊循ƺꁩ栀瀂衒偁큈톘ŘꙒ뀦―Ö든ִ찠挀倞準ꨒ㭄ٸ᧍牥쎛✧ᒀ଄経ཆ搛์\\u0013䙌儖ş⃔棊Ы娊฀챺娄儸䭇䩬泿ბ匄岂ꊤ兦䨀耺䰀甲婀偀㌀坌パ呑ₜ깞縡ㅌ牴고렖樾魀⅀ቬጛ⣲吕滒٦㡌3㺄ᵒ㕜ፔ氻⎓\\uda0f₸石茿缭鲀撡딺ꉊᆇ䟐ጡ芌̓闢ࡢᶰꡀྠ㟅䏧㧁ꢆ䐄㓢썣ₐ晘鲚梣፬찀ᑀ考恹ㆰ뢖蒄Ԓ老둀⩹㈖鸤鍃憼鶩鴟둃♟ଊ␑탊䤅\\udaa8偃Ӕ₃むº鉋搈刭曢ᭈฃ 　᤽\\u0016-㞵逘̳稀⫞ᨻỴ떣\\ude80ᚯ╅Ԁ䆠E㺭ᲉӀ\\u0015ᡑ་펉쵢柳灊品䋭樌考찠Ǳ존\\udd4cᦃ撈䀎юⱦ卉耲턴פֿݴ詛荶ঢເẙ甕幠剋闷瞀⋜帨躀䜄ͪL䉳鰉㪾쑧匛䨀㼖챢ਠ\\u000f☃ӈë䋮Գ䂰窒\\u0000溻섌ぅᢉ│ꍘ쎂骍ⷪ䏐ㄈ⽹⃩ꒌ骠힊ঁ胔⌃ꄴ頀ŏܱ갎舓⻂ᰏЀ铏ꈗʈ⼄黈愙悔쮁噤蜄成횤聡䂞ꒀ胈飱슨ᑂ逜ౖυ뇘│䉞ᐪց顑✃⚚졁腧턷阅烜ꐮᇀ⾑ۚ瘽而⬓ꇣ餘ᢏ见녑࿩룶\\u000e舅񇦡逓㈌耀볙䠏㢦İ婽⨆懀ƣ곧評慜茈峤啕䵓蠆㨜੒。ᑅ휮᠆㝯레Ȧ๖怂蝨듔ꐩ堷喵爀ᠠ紁蘁ᑝ䀈언褍뛵뭾\\ud956ᴣ槞癝‷槪\\udd4f緙舽絞퀶뷃燑ȗ娙﵋喠Ͳ഍䝨\\ude34ⓓ矛㑸烂಴૶☂䆀嚺튴ࡈ\\ude53럵敘ㆌ鹶㌞瀵ﴳ圀ú㍣Ƃ〄脽\\ud8b4⣽ぷ茁ꢋ䊈ҥ쵲遒\\udf33콽ⱙ萬焤\\ud80cⓓ枑ᗿꀕ癠ꆯ⧨鮼놹휮ᑁ涺㩬澤저ࢀ蟑飴㸨䠔꨺裲츢衑톤됟ᣒ惆ﴊᦅᅈ໛䁝띫ᙠ꘨ᠲখ⍆듵㞙駅ᖫ譎廫뮷氦敿ꒀߚ 뜀㞿猂拓਺咨ۍ틲ᆂ䕀銜ᅪ拎제ሂ胇ࣾ㰢鼜\\u0003鉐벌ࣃꆴࢩ菻Ｔᜒꃌ晉솬怎Ʋꂤ洂샟茨ዞ衽ᚒʻꆻ봀ဦᰌ崼䔈쒚℃懴౉쁢♲\\udeafహ\\ud805ꛅ萭瘏砒Ϭチ㹁庩ᾣ菨角⪧ᢥ䂌㣤鲏驰՛讼㰢䏮뙅⊖禇摴ہ퀨꡺ॸ瀹̰퐞爘䁮离⢇ኺ깚ඣ瀀拗ຄꐆၰ㘳ஈ쏒뎱㘧側ބ샰剆簩⤡鑏༸薜ᐮ燶ᶂ빇᧲楉\\u0000㞔츓豣꼋ኢ誨ᨫ䘑漝肯굧갦⩇\u2029⋬ꀇٚɘ먝扂涎샧ႉ硓⹤層乲ᒖ⋄댙考㑇⃺ᇄ倁콙젠쑨氙⌐ᕻ㴐᳨聀酀จۂኟ௦됅⢏璧⎑迴⫧豚㌺껌骋卪ꊓꭽ兢ఙ먱ᩣ䉩䴮곤툩Ȗ胎饬賶瘲䅚₼ꂵﺙ쩺朝⥣ⷎ᷌嘈ᥘ䣵ອ㙋흹Ɨ꩘̌肺邵ዀק̐囵躵첚㣛냞柦楎瀫䙈ꓩ鴨旔+Ⴐ䚘ᐫ⍳颊▧춖㼡슏貞勐䑙勜卋ꖝ⾖뼱韸䐄ହ盋엌\\ud8fa쬥駍﹞〖瀈塲힑爖燕\\ud8b9숑畕挊疶奀\\udbd7䀤䩭ꆣ胶줁ᨐ\\u0000藻ꖬ库\\udce3\\u000e앱꠽뚠Ҋ⍶䋄䭂꯵盞鏸聴鐓ع↚腈ੇ뗋쒂ꁙ欓ဲᎲࠪ㛴膙肉塒듡䐂ꀙત欇ՙ亜勲உ폚㒴㣏雲밿఑뚕䏦昛낖墩㲁顊ྡྷ\\udd36텩묀Ф삀ឃ瀀ׯ읁　谀ᙀÉ쑘菠뙐య鯙緉膢脀‛꠸ꠜी葷䊈␆㡾绗㇜⻪⢤ᑇ큄䠣芩藅ሁ褲畁慠㴐遲콰蔘ꁂ㊂釈驀졙ᔁ舮诐ؐ섘挂ꁌ攀﯅㘑겾ਠ汬⋱ᱝ铀商㐁肪魀㍁ற䖠̜눚卅ဆ⭮ꠝꖒ눡\\uda27隇ቤ텙琀䅇\\udca0紕툥ꉞ膱ɂꇊ㻤ⅉ뼰웞ქ㸭蜸拠䈋\\udc36⛪簋شⱔ⎄퐁蛄뢌駀爀苼⎙뺁聁㍒롙ꩾꔉⲭ\\ud9a6睠貈Ҍ걒솨⍣⤾尉礨揅䐪ᴒ丿㕀爕憾ㆿ쀸會硧ὃ萾ṣꑾ颚쀧Íꠐ撉\\udb98⯧⒜ࢌ멉㗖\\uda27诸쑗́鈆ꇯ㴆絷釣퓑ഉ\\ude25Ӝ⤊ꕲ⨁ꗩᒷ蠠ꉫ쫅狑\\ude84␉꒪䨁싌虀磨ष頻ସ즥ּ㎉섎䷍悇ଊ皖ᲀః訑숺␙鲇ꛔ㢲ﰞ桰ඣ䔠禁긏孠ﭶ舌쇮᧒劚ᑢ〛\\u0005㤯祟쎛䠪Ꞔ阷蛹唷鈁鴀뚠ƀ슈Ã䩆啕䃀࡮穰̭눨琉ɠ缈솸ᅄ聢䯯髁櫀曠鼖芳祺欕쎱ࣾ션鴾最駿膼᜕扚燲᧙ዪ\\udd90ꦭ﴾᱃랴୲史燘֏뮠蕅↛덕漻ꈂ䀁鵰ؼ族栀撲繒耆ᬦ瀃ᠬ怀ᒚ⤒賵殢鵧䣟ḽꯓ䗕錬瀐늗㗁⑤䀱꼱ﺼ㰄㠊秉锱댈徂ፉ꼧麾敔Ӯϲ』ᶈ㾛ꭻ䋮⭑녙\\u000e佋敚ꦣ鐁麕ꜟ㈿螏칑ꂃ\\udb0a胓쾡霾蘷튠̜碠鐐ꍐ汅햃吚즚⻄煹㪵頦ɘ뷊髤แΉ鸞뫚怵᷸㰓똡渨葉㣹ﭏ衹唵렜༑隃௤ᦁ徍ﭠ⒲ᠰ耑ꭑ퀜ᤦ뇐ؒ꫸谓棢ǁ芥苆녺ᐡ訔Ɓ甁Ǡ䬒䐡њሢ焜堘┄谹슮뒰µ̠⢑咕ነ䌼Ⱬ찜䂷ނ᠊֏괃ﮱ蕏钸쾎ۮ̉સǁҤ끊Ꙁ㾀揠뺂㠉՚ꡡ遀懙ᤑ枟ꄰ優⌃䞯艒㩸蒶ꇴ㮃逗匷㖆\\ud865Ϙ滲悝|ϳ롺ॷ龄䑞ꍀ逛ϖក쑘Ǆ䨃逡薠熄侩蕠䖸狿ᑀ롟酳뿱톧聣ጂ぀ɱ媀䔰䀃닸䜺\\ud830致Ӂ\\udc1c箙㪒퀀蓿ㅳ퀼Ę递ভܐힹ牅뢋⡊਌噂Ꭰ쫠㞑м올漋䐺ɂ➻㮝䒘恻顶Ҁ►꠆⨀₋蟠눂な㧹ᲂ\\u0004㕂搂쉧뙸枘양᩹㰳ǘⅈ؜䯧㺂롇խ뤁艧ꀢ乻≚읽㱩伦ω酠$菀艈ঘੁ䉌⚌ꗇ\\udf15䦢毀\\udd85擓숉ᩐྀ\\ud98d曣ꁇ扠埇㑏욲䯂ꀴ놧靫鈹儤䉨튖ὀɘ歂妻뉬ᅄ堪簹˪燈ᩘ싹蜺倨앚묹╚矁甼騺嫛ꈴ녷誥愣⑂䰇橨桚氥搏楷虩㒫♚尧簉ɑ㔀萰昚矃詤Ꝋ灺쩥렜ૅ\\ud800惄⾅嶟㆟聡ﺶń⌅媼颖瘸䱲裸꾆䎄쒌䣅鞍\\udb24㑂쐻ख牂ᘷᥦ\\u0017ꀈ䍣萺㬔㪎ꩧ푣짻눱鮏멓깁䐫톇띳偄鍇껺작陵ቸ瞫冧鞀窵ᦤ鸓㯳謺ࠛ㡳霸짳ꈪர뤰⢸륋貹쮂뮾䗀ꮱ펫鰡殷铰ሡ뤰ሂ鮅蓼䫤䞔磇讆래欧謓꾟䘞䅺馱禞矒㮡螗靱‵箈뫣힃펈鍺炷꾑랓ኡ嶉咆ᛷꦘ漢ヹ箧ꃻ轢琹拂ㅘ后䫂ࢠ\\ud80e변垪ୱ뜍臐ⷠꈝ鏷ዃ鰁삇⬀าÙ먠쁚쁐ᧃ혻᚞ᔕ霑ꡃ愞샔趙麄ॸࠢ炟ᏐᕁꌴՀ䂻સᤐꐘl㳡∈\\udaa3ꥫ欑겣奊䅄⺖爵诤븋肬隚ᐆ䥡ᑹ畹ꤖ饓륥䝨㰧孥䔖湽礍裪喋膩拂念쌼༤뢅텹뺁뀠x଀㰊ꂬ␒鐒椰ⷢಹ驅蹐厨戮狦텱큷껤넩è।उ뢀㌺뎻꣞眻稯㬳鏧鬋撻䮬레㚺멋꿦逪렁暸ሙ힋蠔ᮗ㡁䫔쩨筍䨖넓䅽䋕⵿鸗㮝ᅙ㴗絍᨜碈ퟱ㿳ힰ酻ꡠ嫄⭱雩攉谪Ύ脖垄櫮⭰ꕁᆩ暄∦閈釢褕楕촳筹஋ᕇ椡堶\\ud925U䝨⎬䃇㶙㾗ထ서’꥔镡ʓ戹쁂㔀Ϡ肂栣觳貘朳睠\\ud900쎙Ꜵ̓﯎ꛛ੒\\uda30ॅ씺䂨႙䆓㳠䲄숋鍂츪⃲娃㭍秂뇇銽窍爴阼昌̡᠈ꇱ⛪ऐ䪿迀㤫莢⣁炏垨ꊡ됞ǎ봂셁耀笷돨፲嗊㷘슎ࡉ데鮈관尙ᔱᶷЌ䁸⚃ࠖዋ粵ݙ疴㣱㠠嬣頊凉㪔ᶈ䅸᪡呓ዚ魀䘬䄺紀斴厲嶯兞Ꮆꈔ䆵럁ᠬᑹ恶ᐅ國ꐶ⸃ᆐᐻ\\udf08햓豚歸ᗱ䐤ǫ䷵쪗㌻茽厠ܰ겻区ኃ䊈꩜껉挪⥵╶鲡윀쪪䞼虘㔁甫韊謪ጬ⫥☃슪㊊蒰ꊁ좫ᵺꃲ퉧攰ౣ␱紷悒鄍銙ಀ⸁膠青渦ऍ䭒郋䴃쭱睴⥶ᐽ捫湁坑ౠ혎罕즀️瘥ᗝ☂瀆폐僴㍽ᗓ稩⩈엤䬓ರ냢賸饃⋤ៃ烃⇋杧趆皵଄貨誫㍿捓䪯㏳₱ტꠢ霨挭⭼鼨㊦ꮘ㪲杶냨挾贒⬏냻䊽鍨쬭ͺ꜓흨舷刁錬䇍ꊖ瀮ͫ䈷裂R괱⪬䲍㱌ᐢ䶐⻹쪋䊫ܑ䓙⤘נּ\u0026뭁Čꘁ媌ࠠ޳躼\\\\ᅂ‛㿺鵇ౘ⠝뀻ᑁ㣥䰄奈퓂‘ᣬꠒ㍏頇ቐ㑌瓷仴ｎೈ춌톴컌瀛뤰ው骊춬綾螰㸗莎∛␹ᔞჹŗ瘫㗏끐獂팎ꅔ焎ᢣＰ醛惃୉㄁驗螏鈓岔ᄊ䋠ᳺ㱮畤칏ዙǷᜊ鋭Ȧ겱ꄊ䊒샣鋐쉒넠媿뺀拮琎磣醨褶髁奫㈢㘀놕ߖઐ蕛⥣֙젢퐮僄ēе셇ᖂ⸸誂뛎䓗厝᫸Ꙃ딭됮⑻깂ᗇ踕굕朹济푞廔计힜㇕繛闔\\udd46뤁羮䮨ᗸௗᮔ᝼方捥걳鳠\\udafc᙮䮄뤃棸쀅궾賢⛈意袰ⵗ└퍽̙柏㜣˄籭셯촡꿂풛㽔壖籦뜷ᄷ뜸똑睁哞ש暕쓎⌀塵ꐬ깝莤ặ㸆갋㪐仁㰻뱃䝶㋨䋊꺳法᫖熆趄ੁꠅ✢ᄶ柧䶃屛疻挠裇ဠめ됣濌웑ኙ⮮࿮윷ꀣ㍸윿铞먯던׮䈌闭ᄟ䮎ḉ౭⚌臞垲뇭䩱萀⪘ᯖꍯ坫鄔ﺀ딡셗ঀ⵷墝饉嶂಻ﵐ왔猾ゃá쒥乖ঢ়涿睐ꫣ禕幕涍䝣৉཭뜘祣啙炘䵙숓ቐ೬꫒꾥ﶪ\\u0003ꋯ雤⾄ꓯ鰴ﳮꀢᎀ๶≅驧ᡮ풘ểᗙᇮ觶䳙੄杔䝦卉潉촵롓藰摔㶝ƽ妙\\uda02಄ୢ′ᠷ壤ꔡ渡彤叱큐㋟쀹ﵚ歵膹㶳゠제ẟ◡ॕ펇悛ᶴృ館㬥‟䆍ﻱሉ쵾\\udd37㊍㖘⽋ꀳᔟ鮤콂滰焗⃨⨂秔犉Њ丛\\udc30쏭졁堉ㄦ깋Е倜₺截ĳ臷혩\\udd10긜ޡ῵䗩䧽㗥䤁釵ᾎ庞䮢睱ꢓᵷଞ佾伇Ԓ붫樂耋茾ྦྷ븱Ɛ㾀揊䃢聾ꖥ䟄汞긵㔞㞞০쿞৏扫䕬짋浵鲜﮽㹏ꐭ林⸄갮⻇᎟✯퐞듛캮甲킷䏱쾞牞⸚嘞뒸⤑؋〮∑Į騡髐␟⸦⻕瘬㢾瘙薐䭗૧啐뾐ᅥ㎖ᅸ⋘뜄楙ὀ拌ᾜ᜙餍䫥簬᧦ၓ榎璻ꈛ哓쟇⺤ᆖ䋈꺱⦂⤥뻶⻆ਲ௭潴훲썎怪蕵䁾㢌崯妓덉妙᭙쟃㱉풛ꏖꠋ撳촶쫝逪쀄藣쯓১濖쪯\\udf55\\uda3f䔽주崞ຆ鷡菵혋琛氶ﭭ뽁偿溍ᴇ軿歓ｺ쭵ᕎӨ࿬騫죳쭕쩀洖타ꣵ턋ϓ㿞⪿ﴑ౿엾泂᠄ꊡ갰表豜ꏟ\\udfc6\\ud830憤끹䈓桋ꣳᙀ㾁蕀ݿ\\udbb0纆플䴯涘ⓐ웬ヶထ錃퍕턁᷄䲅욳ᵵ愚ູἋЇꏉฐ㍅儔䇅䢢͵Ї촿㜚䪇頋⛦㞍숋ꅀ⩆⍆ষঀ⟲炙꬈蘜䞿둌屧詚骈Ầ줴派胒桘Ł崄聺䄶ऀﴅ栵驒鴁뀰큽䷯Łኄ肬葆☀칣팾頌\\ud866ꌴ쀄愨ࠤᦚ頎普鎄⽸큆稘팀Ȍ\\udd99䳔ឣȅ퓈臅蜜᤽ꋭ靶돌ྠ艀\\ud821ᇁ죀첋丂К狡⛜쉈뇝ᜨ阈\\ud98c˰捿椸⣌₢ᰨ谑腔Ȇᗢᘦ咬ᨊ儉頋ꡕ䞓఼ꪎ｜؀‒ꈄ킛䎠Ẅ䰣ǀད近韊牐ꃓড腤遁ﱆ蚪⊀檖懮ᔹ㊌䍥蕵Ꮠ⌖톛䊶泃䈆膤༠攃ꠙ耼欤ॊ埁븝䗷璹㦊聬ॳ⺉諣휂ጿʡｆ꡴͠洐ꏻࠦ咍㜐翐瘝匏釀㙁蠉嘄䲔ᖰ퐂꠬৙蝌剫ꂺȖด됀꼡憆ᨰ褀슅芸瞴쩣ࢩߠ㻡褌硠쇂ෝඡ슈絛ـᬑ椒wი݀䳠\\ud86b芒湳༅峔星㕧賉朠⁹쥓襲啅▂욅䷳〛粡㗟஄࿄繠煀侢뀓뼋蔐⾈㟲굂坧⮬夋齪ꃵ஫⮚阍뷔紞᭰⥆핪ᦕ鼠䣔ə㵆Ꞁ텤ᙅ黸῀ၳ䙀卖뼂偾୨ꨁ⁉䢀퐰蟹胊ሟ蹐耖㑆ŀ⁾࣐娫ㅝ圉梞壼ஊ죕ⱥ䄘䷾仲ʾᐜ逄㍅䇰唃㈳䅡掐㩘㘉䳃낲ธ䜙ᕮㄖ姰栁\\u0007ࡄᛪꍜ炢ݳᐜ斯䐜媘᭸\\udd00܋褄蓚᪂嘺៑༅怚餀헔瀋脸ŀ䴂奄ၴ£㮽저⍥댜ݺ묀뀆䀼Е埨瘊뚓努ࢣᾬ連䓰踼㘧쇏⢊杆浍텦ჴ珥봚ᬟ婾哪㺌ධ挀ꨘઑ뒂鑣ꂭ湫뎪ᜲ璷豟揗슠䁩㮔簄â筤᜝蒾☣多䐜䘄裓글灢䡌径⨋鵺읯ᡱ模ቀᣘ䔒爁㤚ⁿ㔰ހ瞧䭣姥ஞ賶澗处↏咠䚃㒜䇰⥄鰁\\ud8a3✲혱덤瘋좂唧ऋ縪뗊㡝䭭☿嘞펀㱎蓔ຨ囅촛\\ud874➥뚜封摬ɰ墖쑂뢜旪◢踌᳿ꈹẔ갇⡳聻吨췧ꀶ鑺장瑫㯓밵డṎ∋⟥ᕰﯷ䑂⌹蹚ຠ먈ٽཐ䉃㐔邈쉘෈ᇲ숸卸ᰴ\\udc18죍ᓈ뛅ᄢㄕ䖄\\udbe8⍴㠁Ɔॠ㐄퐶۠ꊰᐩ뺉갘剠᠀층婦ㆯᚥ抈蚇ꀀ㔓ၩ腓癆鄤轡蟹艋쒛ɱᘂ잉ḁ쀳䩓䪇곖ᆠꎨ梃ꍛ薭㞔ࠌ\\uda77憶銠ᎄ霆䲅⇈즁瓲ꌭԠ꽋\\u000e끮鼈ꥐ딉ᄾㅁ蒃ᆛõꜢ\\udfe4媢偽㉤ᓌ꺣ꌠ쫿藃뺃䌻ꏿ탩⿳慀᝴愢ሾ楱㔚嚂중␊䙠ൡ沊虇∷◈놤䧲挡䴏퀴ኈ莈び瞁厺є흩ᓕ衎£㺲캄䠾聃㨑꫊舘퉮䮌ڇ㲍馘裦矐䞧娔줽⍨퀶陞쌍刿䀄칚㴲ؕ푸∣軰䵤塬ദ༁甀$쀂蹜ª鑃凓섔钟佄䥸萁⨶愈⯆ỉꙂꦽ飌髇㌷ᅷ䄎炲첦㴒쌄๫狣镐∉సࠓ̘儍▗䌛ꓘ⤡\\uda0d䦢늓鐵ሁĂ恃楲겟Ꝗ➄織퀍鑈焈焟䒭喂ㆁ櫈倗様ఴ今娺ᬌ\\udae7㊁ᤷ䳮䨲閍\\udca6포Ŵ戦㋛鏌襠基⢑চ鳾蘏⋐쏉ﹻꤘ਺㇥\\udd0c馡쿼ꦠ妈⃏ᥓ㑁犧깫關鱆⠿맸Ɱ篳䦎丅翊偄刴赥쬧䄊콉ꋩ羐若䜶핑輠垴ﲤ앪抂弄ꑡ鋻苼舯엥䠩剦\\ude46䥻Ṙ컳蒐⊉⥉쫨䉱ᐈùԂ配㖏镖七뗟䂖ǀ⩑뛌ဉᛍ섬ﭰ㠤렠䝋癒캂⹥ᑠՄꨩ䜞῎嵤瀀侜圻࿑ᙇႮ㘜䠊赃ᔘῙ蘅欇鲼觺䩉麐됑紑콧䀻ξ緑ສ㔷⒔ﳠ좫겘̽龽\\udf41錩’㤠봄ৢऴḰꐓ逻픻뢅풠櫕㝊棐욆뗄䒀氀ﭑ▒鎧铽욬蒐ê➉訨\\udf16ꐌ䇠䥡쒏সꀢ殣뚯祝ꩺ⯖్መ鍄땰蘪뱡蹺醸增ୌ뱉規饫째脤阶ㅥ軉㧀刂ନϱ焤궵淄⃡ᢎ⧱扩ִ૆⨼൐䢁—䀟ϸ鼩ू뻎ಽꊷ鑡驱卋鱅䇂逐涃政丿⺑ᠬ฀䠰ሌ৘\\udd72鬺䯂鐊\\ud905耛ӯ먘簛န囐ᛊဧﱩ鉲࿥䂫怜ⅲ窕瀋᩷刅腪⪄ꄴ噔ᄊ३扩᧵鉴뮱휀㗢鸨耣ൈ렂』ꁍ뙟鏹鼇䏌᳈楣檿ᷤỄ\\udcb3벗赸㗢㠃䆊프饑喲誊䚢ﺕḓ㒅魀㡣劐῱喀ﳪ伤퉕繍⍱毠腬嘲᧞ᩲㅙ速才䅺蠝࡭$ↈ껆⼅묎ᵉ䥌ﱰ臄᠐ᰕ休㕪篮읍ⳉ놏⬱䩇뷹첋䯾髉ڑ눩㱩鍍鱶餼鎼톄ýԂጹ㹛세苼똡㝌繷憖铴蛧⌮䇿‵翀Ј뱱孳ⵙ쀮蔸鵴퐗霣Օ쫁䢃뺍媺杣㓀ꀗ傧贈䍁싁䚧੽昂둫䍇ힷ≘锕ꀵń׌粃ﺢ䢴鎨砍䁫횻⽵ި冀੯帜途崪Ӂ茋싱꒚뺴⯄ﱊ䵊\\udd78픩炄䃀코偋횠袀欳⍹ᩥ饆鹇\\uddc6⹢⨑⢽⎯堡먲バ\\u0011蜤䖨ͺ十뺔䣂颹쵈셔̞섁帡Е脻巀꼗赤澦䔳ꮝ芏흮꯵侯\\ud85f䣿巴6\\udb18෿䙺珓➔﫩〕瞴ྒྷ衒շ㩕겅㟇蛬볧旱곍깨墿㫥ऽ䊂냖峳㖾ꁔ撩덴ᨱ蝦쎇瘉쵀滕ҍ슏웷ꊋ㍆톃⭹䷯錀꼵ᣐ放వ䗪뎊舶厴줦Ƒ৻⌐䯃㵙꒞뮁핦넉呁凸嗖䷡帮엽䮉鵙뼗펩댡將⏢\\udfd4耙蠈槹檿뮳墕ꔾ극楮輻ᨯ哰终瀃ⴛ춽䛉䛌ᣅꊹꙂ嬿媈辶ᖡ췅楮㎛㆟䳰㒗㒍歯퍻妊ﻇ䕘Ⰹ고ⴚ䚦鏝꒰ൔ蠇ဍꚝക鷛ᶏ楸܁澘䰨㘀ꌘ끯荢ᨐಆ턂ꆮఘ楻擃酥퐶厭ᐅ䭀絩᪾\\ude4c\\ud8b6ﶢ췿溳总뽝턢뒕귈䋃獍ㆢ\\ud82e龶悸ﻔ쬐洳엝皂ថ릹쐯慨᭝鼜섀聠潃仜瑴㯨㧎וֹ펖ꤔ䠺嶔.巑讞㳹瞒衙퓪ꭧ큖ፖ蠴䬽涁黫ٕ皋琳㙘ᜥ㵛婱퓶霶늊契䃌ᣯ唧뜄ጢ各윩뫜诙糶倐낆ೀ঻Ð廌̘㩘儂葝鞪ḕ꜕貲䥲덪훚⒄Ȉ뮀᪃襢Β䪩㓔ڕ绝॓㠉⊖ᙕ洭쀾㮥옎悁綍Ͳᄻ쐮૊Ϋ嗅㔠䐏벘觙䊁꾩㗍閜ﮈ镔䀯헠㉪᥸䨯ꑓ䓋㼚\\ude13ኬȆ祐ᜟབ솮\\udd4d㖣粔ⲹ䃩ʈ≁ᐄ◎噲骉꜐藷䏄ꈉ∜艒አ鰍栨ꄾ覗\\udd42킹⽲쌀겴呫ⶼ蛋\\udd18省鐝坥鑏⑲먤鲡觡蹢寕ꌒ텸ఐ娅昆䃟֤⡐琌⡞舁蛀텙쿇臮ॼꢃ롔ቋ뢸㧀ƅἲ䈂ᶐ밌焱ධ卂饉킡،ט颲ࡂ哻ꗬ切蕙옂ᣜ宋搝团촁戗⒦芇ü拠튴뎶䲈봇楺䁴Ѽꔏ怉앴䁮별屃誹홋蕊㱦̹蘣䆥刀ปꋻ჎釡麝品职\\uddb8Άᚡႇᜤ臀౟闰韓魢ଟ梫覴࿮䐁尰✣밗䊛곖飺ꖃ⫙숋퀒䌅々셮었䊁搅䆯‱쥑逨핸ษ윢蕰봯඀✂䟇⃗停㝋뚤▚쐀끢⠗耞⹾㣱꟏줪ֲᗅ蠰瑒ය퍥⑊껹㶕큠㘌ᶺ衬Ḵ➜붃汍\\ud8c0臶㵯ᜋ᱿※쌸탔鹜痬恘훰砰⚂ੱ麱൒䤝댓驱㖥৿賂搴\\udbd1젽ì襠‱땟딝ꗊ≽㋤툲촀ﬀ졭᷆䣪庐鎊腈㢔픯˞۰鱌蜚艀໻ꈙꎨ䬲၀៣鳣蠗㶩Შ欃餈蟐氍淚쩈ⁱਙ朌㆜膱À\\udab7\\udbba५吺붴躯欿봲罞痧㒆㝌㝴塀༦䲈訉׿䅁呺ⴹ痌⛓恭ᙸ憡\\uda1e큑ꞷ榦葐﹈뮨堃ɨẤ㦱裢ꃢ㘡㯶䌼펋䮆槉蘿콕鐍凫듕具摠䥪\\udb59疧╺疧庐㲡À믨䳠ﴕ聋㓴힧穢뎶駠뾪‖肺楨溝ક\\udafa镴ᅋ䍄䛲滝袵삷⽝ᦜ怖曠ʞ뻎漡襡広　妫㩰躜젮㑠烀癮붔䮲쮖麉䓑螨愂萴⾁宱Ѱ냭迋뽛ু묕Ʌ뺽⦛멓鳲姍幼驜\\udda7릢촾ู렦띷恳鞜띶żᛯ趴㖓鲹蔡瞝ѡ标뮐堙녑ஹ嶈踜請䜲隍ꑿ⢅˙섗㚬듶켼酬Ⲃ툙謻릐퀞擘\\ude86㳅菏ㆼ듷鉺⺸鎑菪끉瀒猐겜屸ꂷ\\udfcf鶲펄쌠∀Ῡ嚠߻뫨ঀᙫ꜈내뿎▹呂奢ᢠ紵Ọۿ삋ɘ繪柿㩲下\\udab3산iゃ這䂖䋈彁췖״⽧㠀澢숀©爆旒͡畋\\ud81eឡ흮뢵ﶵ嶸⹋椋轙㦖暷⧋⹙퀃᝝铅不깫쬾ײﴑﲼ죣揅擳㻣魷쵸堧撔\\ud924琳셠貵螏ᦖ跁㜀ӓ䀂ɉ祻ɩ㛓㕪√몊ဧ\\udb86ⅷź㼦퀜瑼勠舾笴虲꓉杴堧섊鳈㐶⚇ꬕ堈″缠⁯∴੫㨑楳듼醐擫܆㡢ꮬᮒ堕䁳⇇䡒莄䀑䂐䀰㵃㔍Ӣቝ᫨颉䳲栠粟擧昐黽懔펧秽叝㪞䕦氳랛!惀΄⯃О胟β┡㓷俙磋]腄`樃칽桔\\udb66欲\\u0000ƒ宓㪡蚊Ȱꈋ䁮ͅ艆볟럼մ滂횘恟颖삶ᆉ롩涋璍諜ᛏ愁宝纮≦賷⥨ڷ閳鑜ꄛ獰식ᛷ有荌̬ফ祗鯆⌲ာ蔔ǽ䠔᾵㚗㇩ꁸ⣑鯌\\ude02얖삹췮쏁ᱛ糚囅량쟆ꍮ꭮宇ԝᦷ喱⍌ᤛ歛䣲ㄮ럙ꙵ뚃퉓䰿˂Ꮦ듟齝夘Ẉ肔젾脍넝셬㬵\\ude56푷犏藽⶞礫싮쭙ᛰ妮눖\\uddaa玺㾷ꠌ׭悉\\udb85櫽埩굅紦퇉ܹ❩銏쾒䧖ꘁ疙ߝ楁툧\\udc71喠帼狧趆쳥꽖趦斶邽꭛⽶\\ud884㶏㷵뻻抑囿쫓象ﰊ⡧菢ዤ㞙Ⰱᇳ쓋䒵㸩ᴰ섩ɍႀ⡰帟蹪୐楑䄪ଦꪸ遴䕿베䒚ᔕ徠韦Đ܋焑,僌텎郴䫒쓬㔃혜푢প몹봶茉纬妜㛆槀焊ꡐ㪪؎꫇帠긘졿耰膃閉䗄ﾀ庴戰㤅襈ᆠ⇩鯚셍ᇋࠟ똛輴䁍ꤒ꺀墇顚ꏦ甔딉\\u0005희萷흁쐰春\\ud992葀\\u0006觩䒎檫곝甪⬐ꚺ銍밄ᶽᮀ㒝枛놴捙喝ꅱﰾ樇ꫯ앭齲鮸櫶晗務㦬蛧ඝ》筱婸㲀ሃ᱃ൽŀㄛ\\ud9b4喘龰콍┿ꍌ烬ὲ\\ud856怅砕㥀ፎ禠㜛箥䀠♪勸ఈ潍픭\\ud919Ⱋ䀘爀鿫⽽࠽ｇL㯒瑥ꮭ䃈枲㗊芍敃뚆༂㛔䊓䥓蹲懀∀찉≭᫐෍쳴趢瓺枴ʴ㧎怑㧔昴Ἆ숅츴农蹅쉡玵㠔㴀嬻㏂偨졘⸍蝝俞ᆐ夯퉫ࡂ懅贄訄黓칠슦˪絞飲ԛ質㠡쫏钹⽚睧旋쳈\u003c볤㬂ꓷ덪짶즖봾⫋ହ뙆薖ꇍ㼽⭹橜ꢿ\\uddf5懤閚ṑ먗銜頬朣ஹ좯ⱖ읁맧‏贋૖ᝎ䁆⿀띩梅墼颺싂삪Ṝ匭◤츺巛햇퀝鳊㉦᪼走䈲ዬ᱊喃⩫켫錫ﾵ焩wꬂ〦焔⮃籡輤꩘䨀뗓恽㼏à毇鳦і\\udba0ᡸᦱ쁲敖ᕲ詄툮繪묂䈑젛伾䕺낈䑇듑ᔧ螊ረ✺엑寙룎㏨ꞍὨㆌᮺ댆㸶綯豟疉ㆴ귡䩡ઑ䁍훮㲳덯ਦ\\udbd2讄䒞븅䡏膋ᳮ⒉図ᒫ뤍㕜ᤠ\\udbdcm馠Ԑ䓆⤑܏뢾⊆ἓ駯靷慘䳇Ტ东隓ႂ촽ନ윈厅큥潽竊묄汷嬇顄跈įᯔ昐멕橺灑﹃㈎㝢郼㕻⯵뷈骢?㑻聂娻혩蠞\\ud847㡸괼\\udddb盗疪㳰ㅔ粵蓥᲎⃡戈ᘩꌅ躥困䌺逺錽힡⻦숗릭끁熚珶≰医訥屮睁뉠걎緈왜꟢귚ꠇ뽈胜儾✒쎡܇埭䨘ċ纐ﲏ죰鷕省᱐⣱㻀냞㣠宙젚ᆚ๐ꑮ᩸꣆餗榦ㆱ돺蛻秤驤騒贶被\\uda6d耂Š܁剳浖灡峞ର萜\\ude30풼ᗾ폟Ѿࢣ줠讛滙熭좽웰낥鿍亰䵻㓜聤墀⁣恭ᄯ글ᐷꄑ藭옯⋦㳝粚㦱﫰Ⱔ반⑯⫊䗇忘惭㭢弳쒞坶酏名햯ꞝ诚暞逨”ᭋ쬽箅瞱綁矉ꇞ贬摅므耩茷麾倃鞮촕앲㧂捼트ꅬ꺔ᙷ풡㷲힂庵쥗ᖑ鞬뻢侪﯍玌넫赵䞰Ἲ᠆綋䁰籹꬛쭸踚鑗﷓潛켤䎁郯艠ǆ␇ဠﳑ麩鄆萊棟냛䶕ⴓҘ擁篊幮馀鮡ￓ䯸ꎙ쿑䫲⾿仕槯ᶏ\\udf60㏬ℜ䓴ԺᇵẤ繙ꔟ뽾ᘥ᝽鰏훦欂ᾓส\\ud85c汱朻㡗\\udf49峻಩ꁄ馚磬뱥牤ᰈ룍퀸놏삫췏닥狴杄쓎褀ང툆屯⦗⣲ꈉ廀ὠ늿༾䰹碗팮굊鎥龷撋죿\\ud9a8⺍ﶓꨭϧ⭺컁澆븓릗뽑얿뗲齉⩘㈖葕엢ᔄ혫쮙삸ᓀ측⏹윌裁ሄㅳ䒽⺉訏ꨁ铼롾䇲黼쀡簍﷯໾絊噅횕썿ﷴᐘｋ䠾䱔浚ｘ⨟훹糯脲藾讃黻솿课美꾻ᗺ늉뾰쀻ﬄ澏鋦囹켦슀ꁏ珨౗镐␁唉垅ᱺŕ๠곚㕨蒩겳\\uda19ꀦ돪짢蒼黫⭯殊➬퐚ꧫ걔؜꛱봒吆끭Ꮇ脁랺駭﮶\\udebf뢆謾趞槁\\ud9e1萳䪮笠⹧぀顺Ꭶ⊄ࢊ㥟ꥸ㥠䶢ꈎ萘Еɫ䯒裰뭳簦䐖䫆즀מכ軌ꊜꚭ⋩⎞ꊆ侁ਡ鐇̄葞꣙䗡Ꮁ\\uda51㣓摥鼾㝳堁疓뀂衋諂\\ude40ࠏ뜂쉩拾梢ノ㋹㺯偍珢Ȑ武糧༮ၐ抙ﯓⴐ矐ꘃ찤䌠囼몋⊦㊲ਰ氥傽廷﨓跦ᷣ꾄ǣ祵络Ё堊쀴롂打ۭ㍁ꖀ됏偪X猦滟鎾റ초暾₍ոዐ䃀錹㐝䄫荐ௐ綾┅٬讪\\ude15מ榷뉄\\udc0c醭؟꧈炣琛钮銅ې品ⴄ緩隇︎憕轶奚ꌨX⻝ן絾탹낮ၔ킡➯艚䗻睮辿ﻙ孎櫊ⱁ퐁반슖飼Ⲑ浘좑谮海컯頼⟩ᴔ\\ud8a9팈꾇뺜臺柆ꀮ솋ע辰叒괈\\udd2e遷惝Ь⁠΀덹괇ᾤ쉌뤹٨㉾蔇鰖ど惠֍諰ͻ톨䡴됖ꠐ膻㭎砜暛﹋鯼᩿迾웺Ⴊ澞뫴虍ᐡᑨ숙惟Իۈ歾毊鈙ꡀ솨藎쑔먐펀䏇ત䫕卞촛ꓜ₈戟툉ⅇ砹慈征팈К栰䇙ԨẈ⻬䄄ꔦ遧ꄱیႰ萠숂⟂灀쁧ٌ᷈呀圅ﰓ灪噷يꗾ㑙⠥恀慺Ǟ蟠鑡㬫졭丟ؿ⨨ب衴亄甆ᡐ㦌矨㈯绅ৢᶠ䄞䏹舤亀쀜䎏⓾䱓信㖽\\udc2aϏ拾⿩璤࠺ί、簀尘᤬憞Ѵ႘懾犆ꘖ辔긠蔼ᘈ堮餄樗涀솰薰꾐濁錊渓ꆥ睠붇呌〨셫蔖Ⴏ菾倆刮ଐ䆨Ɗ⮨䈁쌇倇襰꣞蓶췩淤枈梹펽毁뮒靠ﵯ鮚\\udae5悃욾蟺텱剩稏蚽⯖茐뽘걆ꔺ視Ϩ转㽀鰑㜓䣤렄殀ത뒐触宅㢰ᢡ↱㭄燢瑊憽ᇴ䱑萠Დㄉ໷ᄛ잙㏄뎁မ礆뭜慁뤁吙鄥䁘⬟斧꧊玹솏쒭ᆙǑ㪀\\udc44ҫ쑚磼䔌䕱ゑ猑郤넸醫႞묑༃汌ꀮ쑆䐜䨒规䞁鱊摠量肉ᕤ揄脹瑢궷ᐱ悹Ꮡ᫐㞌ꂎူჾꞠ⢐맑씪묘⪇˱ר\\udab3ॆ耙ḕ趓ᘠ㯓ꐎƥ糐禩໸㡔⺀超朧籮̇ভӾ鍂袋ꑌ\\uda90뎍코休㞀傈ਰ䨀신Ŋ鰀墀ᇪ숆ϯꮀࡴ풊㊥ꨢ磠ፎ㬑虇蔘둾쐁股鍊剅層䒃䛯樻ꇶꩄ仯䁴\\ud8e9䗊\\uda47宀둃兂᪴困묁쮬虲᧶䛑₴ᵆ焃瑤࡞掭᫉ꥌ喳⍀8髺ၸ㗎풘䨴큀覭◢ꁂ賂묿뺹ቹ隁┆⊩눳ᭂ䯠㪾덱완蠵⊜˄໔殑㣇㔗ꁊ琪㯤캒鴘寀\\ud984غỴ੻뉒洂\\u0003솸\\u0002㻒㚭塶訑Ꙣ柡鞠冩ᬍ悄閒죒歅ࢪ頼ܙ뻢ﭺ⻄㰣䫝嬈૊鋘삋䀋鐃玍윬椶ʩ휚湑슥䒗꾰恷剡㦣渺ꑎ飛筤뾼庼ި㉞㌺奭嚤䆞앋뿐륹⾘ʉ藙椸玱꩙앍ᐚ溮Ϙⱱ⮱글ܖ岦˘஋ꢲ穛쌌塕꺄來괂ੀ؉ᠢ䀨怔쁀詞놂ῂẎ儨裨쮜ߨऀᧆᷨ꺽먩蝞ᐈ仡뷚舐㶘⺑읇ታᙱ郺阙큥씗᩠뵱ᨚ㚧⏟쟗낾侩㋦Þ윇梐圶怂ᱭ䉎읲뷼퍻켛馈癕䊐ઐ䉁䪻\\uda63谭幻ӯᄟꏀ謒ꊧ\\u0004怃炁榴㇄독츟뱞繍윟ꭱȑ\\udc5e쐾ဉ膔䠃㼕舂왛䬖降唄뱢Ǡ\\u0001ቼ樉粁ꀖѕ烺셠ᒒ떒鋅㰏ᓴǫṰ⳺썛ᘊ堰\\uda4bꓒ㷼콣浯嘧蚹䷦ऑ닇켌朊腭薣ᭀᖱꄺ.᎝넮л᧋귱ꜣ킇ꄳ୶஛꾡ꄇ\\uda62ズ䁧아መ凂ⷃ쐛கಞ耔ᳲᅁ䚇䣆ᱮ䏢Ⲙᴐ檂袋쓸訧ᆼ딡阉ꉑ쟚梼ఒ鏂웬뱓틺⟧ꅾ좈\\ude10什➫੢禉⮀᠄硱∧蝪ᴸ干抉⢔艣∭쌲Ⲿ㧘⼂阆⢛褐ꀩҼ欢鏇勬㎴䤑ᨵ關띚뼙䡪褲☘ࢩ☚鼖鞢ऀ\\t쀉鴕肔Ꮓ蓃ઉ凫划︙꡼세骼䗱啁崉态臺ъࡠ錓⾂\\ud917覅կᘞ뢉佊उᴇ냨ɔ馀㖉粈錌焩䥼쎔面ྉ㿄睦⮷﹭잦᮸䲮焆뉒\\u001b┠Ԓ掾종Ⓥቕ∴謮ꢒ䀑猊꒒䀭䥰榊⪀⭉ꁥ퉂 䟴鯹Ȁ抉貑㉔줳◌騄䘁怓\\ud828刚惘ᣇ㳴찁ⴷ䀑⮖ࢤᙒ조ሟ弧쁣텸½၀\\udd00甧艄놐돟䋜㕑睙墠倸葴끐雃鍈꺫⯨㈵峓茯ꛊ焠藢᎑Ꚏ־괗붱叆擫캢ꇚꙴ᱄Թᴨ䚞㉌䂔䵓닎ᎇ鶢䮩죄줱ঀ⯒ꐂ勥㱇脹誟겾勺棂뱮䆾옊ⶉ錊怯焛蜦ቿ雡ᑚ\\ude14ꡭ줊ꗷ椷຦ᣉ⠬焥ꤧ㌼鲹ꯉ頂꾰ꅗꢚ硠◆溌ꩊ耜䉨쑠뉩\\ude82䇇搙憬脺齕ꘁ貭㶜텴怙᝴巑쀄㦮붵Ԏ䣮㐛ꧨ瑦鹓뭩葬찄⻩餗ᇕꑵ᪴叡⃫ꛈ愓鄟䚹ᗴ柑떤̕ﶏ怠왰،䃸Ⴤ礗㖱ㆳ덷⹼瀄ఈ豀แ쎪޷阈밻ே螻懷쀫䄈ꐜኲጘᴉ㇡䓣᧑Ա꽛北쐓\\udc5b꟨ӎᫀ鹰멟嚇ꓷˌ巀騁됈\\u001f۠_믜왫䟌卂䶈亜Ⱡ䪢읭긬䋚⎣☉嗢쫚⯛⻊䤬幈傔⁃鸋詝螄⏬Ꟈ㨟〃艚鴸ォ륏ؙ᧷̯ꀪ缉ኤ\\udb14覚쫊饶ꇪ约⪘큁⢐ꭦ목\\udf43蚗ऋ壚ꘒ雲⯀䚙躷繦⥭躬羼楢\\ud8a9뉾朒ƂÜ騂೨剬賺ꔽℚ濾\\udca1⮏⛨팗鏎玭멥줔躦ѡ\\uddeb꘳絛ܡԀ腠유橴⁮柬䱪枙䵃禛懶§愯뻎郊惊㶽娆⒊忱ᜤ\\udc63섷⟮ჸ恩鎛ڜ♞멩웚齪恱뻆閔鱐焒쥆餀簉頀䦃⡚뉗螥隘殲ᦇ⨚쨞妨정骪䢲뚥ᚒ슎ꑕ醼鮩ͦ얚ⲟꁅꟐꅏ豉斄향艗剟㊖鳕븉邲理쁯Əၱȝ⌢ꑺ퀊ᚶhظ䪬憞眮樹Ͼ錗✂\\ud87b悌⼗\\udc6c搸ᇆ咩츇熘晜廆♭િ臨꫸ꔬ焂♤䥀Ⴞễ⹪⾸\\ud9c5旂ᐹ㚤쎞눓敋䣙꺧꜔婷瘟鹲怡ᥥ岑晹縹旜鍿꩐㕥삛殐ᰗ蓀Ⳗ帹굥霮홭짿枓頼嵙㺃厗ࢎ㥟陸鶸䄹奥᎒ɣ媠ఎ槰⳥樖塀ꃡ芘⢚儨썻嘖⻡윭ǲ煼胥㸚耐ၼ詰ʸ柚툤갧≝퀹Л걼䣲䯇뿃厙狔藌␲䎩ユ稀\\udc7d킖隢䴡퟊㐋湉뤮╕໐⦠ᨓꈃ鞮倧❣逹귁ￇ펞㦵줂慞㢹獥༜벡奭碇鳜瞩화禘廊₸嚹襑잓ᩩ蛼镞ꎂ릳ᾈ쀘ꊾ䂩㈩\\udeb8隒✙槣⦧݄,梫㔔ᚃ쁽蕎鸄㶈嶈쬱㚸掜͔荔漀ኙ耎⳩䅍ទ끀楇䞰窾恺ᰑ齚ꄊ堓遘Ũ䑢뷙띣퀊眳홐ᬱᢄꬑ ﱌ밀⑀遮錤邒㩍ᤇ␨銢俬꼤墐⤀⤫僻룡ȩ϶붺겢䁠䚊腀劑ꝇ借늭Ū䙶醤佩潛뚔骑䙂ᤩ䛏ẉ᯹ﲑࠅﹾⓂ鏅柾壩컢剎瀃ᄷ릠峉ၤ朗恘㔢停銿顒ᒸῤၘᴥ\\ud8bf淮ౘࣙ䴕ꀮ胟ꁀቑ찃脤鲦๯ᔜ绲序ꈿ哼꛰쒏ᇩ︪灅ꀒ䖮씳ᕶ뎣ꨎ銈걤◬䥣釰稀뙗耗昄ⵀ授䤏뺦串謘݀ᴑ⾹ጒ慽쁘䇹㏄Ꮹ吋ꔝ쁟䳤ᭀ讥媟셎ꚦ䁑蛀㻜䕋炙搣m劘ᜀИ쎡ↆ蚃䂀쥚鴆㋪온ꀍ쪞䧯댄ќ㐎緃羥纫灑섄ങ꺒㵑␨肟돚겍Ѡ푪軍砃顪膁牤圑䙃襡ʇ땠딗ᡐȩ蔢ք旵迀㟃힁癑蛕\\\"쑒ꊉ쁘䈤岑汆먓廊乯耪ƴǥ굈鰂࢞ᕅ◯ቅ俠透셆剰᎑ȟ㪎ᙁ讝и욝蟂眱妚ꔄ怅䇸⊈蟩᪾᜔와䞋墬ꢈ圣ࣺ揪뱊푒Ⱟ⤌蛢鏉쎳鰄鑺䩼꯾趔幹쐎Ή铆蟄₨㎂之瀣詊꨾褥鳹瞀瀈䐃䕄ƈㆸㆫ뮆誼ꠖ‬紀⚨䎻Ṃ拍ᤲ鏸؁딀摅肋쉭᠁岑䩻㚒ꞸԪ䕀呴䧶뀔䘡瑛ቢ鑊墲钥⭓ꛇ↢㢌苧䅁晐胅ꆑ\\uda05֜䂁஠똴჉鶓ᰩ\\udcae⁕ᒠレ鰀\\ude03ﰒ䁫熐鑊䶎ꓑ넋녷噂轢ࣴ誳왪␊䙋ᇐ匽⡤윔湧钌߰뉂䯁剌뺬䁑렒䧂⣬ㆆ庇ቺ뮕좤⤀騁凇⚱֢鎣ሒ␠얖턕\\ude12桠Ʀ魰਀ಳ㙞㴍N蠀᧎嚗졟春둤曤帴溲寓뮋䃼愢Ǐ㈰㎑⧌켸袂䈚֯ᠬ᱂븁Ґ僶隶쥂拘\\ud9db䨭胃퇀ΐ菈ޣṚ堢䃨폮蛐ケ↣艖蘚ꎻ躈㱼\\udbb1⹔砋ꡮꁺ蔔佐ꞕ썮京鲓ꑨ勉Ϲఔ豈ᥓ諤夷⭥叁᠆鴓앤䆮ⱊ뽈⹐\\udb38蠣끆죬ᑑ垔΋㐉쳀埞宼⏥\\udc5b녥0唾ࠪ껠؀慕렂썲鲺ꗠࠣ鬤츎ꋨ韌Ά཰첪々簏뺠圻ヤ䬚੘뇍줧㭒鈢 쨨横눖ಓପ㕅ꄖ㰒Ք郦ꯜ譨繗گ镆宼໅셓愧惘ĸꐄⵥ↤齆蕐조ᅑ邖ፈᐖㅛ╔顇዆訠@䩖돉ପ閊ꡩ堸᫺ꉕꕑ含ޅ童癀砍퀂࢝镄୥綕揑㩗䕷\\udcf4꙾啜ୀ몉䀀嗍넅儜㪕쪫퀢碷샽䘕赊둪ꛐ㾦饃ꢔ坁嵂ஶ᠎‱妀ⴤ뷩ꏃ᜘\\uda06䤴ꃘ븈ᬙ㞐쩽樏팗ೂ沖粕舅׈明긪䯙舦\\udb11娌废朝ꏰꖔ楥㱄穼攄阬㿈ᐖ訃馹杣☦稨⠀ଋ⸉1呇輺꩙㙌椄ɂ±㬂Ḗ䱙ꅹᔽ셉ꕡ䦊걐\\ud85f뻎⭎舚䡪㦡␇᫆ꡇ䛲흕玨䲁성枚锸尕鿩鹺튱஻ⷎ፟칿좖Éꁡ鴊頂윯๕಺壜⒈暲䘲꺇٬䁪뉐խⱊ臓兛〡闑尖㼖૪剤౏䡱࠭劄糩♦姁♙郵甀닢嵑Ⱃ⺏╠ꚙ๐럯ꀢ਋▀ꌂ嵾寈択핧﫛Ȫ꿵晰櫖쮃ꄭᇟꂙ꾋蒾箫㰶㕏㤫城䪵䃸뵙굡觧欝勼꧕ⓗ紀Ⴄ큁풍Ӌ駬湐徦핕薖˥쟡劎ꤸ춖쵽䲖흍ꍭ䬪盔뵓ꄝᔆᆔ쟆脮\\udeeb⎟湒怸ॽ廍笌ꑔ֩鞊䃦삻ꚳ⡐襦窚ṋ焭摧郎噹埸覜즰=ᘱ接鸖膞将畵稥쁵䒌晥ӏ\\udd55驂ꊳ⍴蘵䃩\\udd53줅ၡ轺阵ᒄ牁绺鯪槕瞇᎐ꉕ倄ϡ쇥두Ⲃ䀉龖톊^嵵ᇃᒎℑ狏嶍᭕ﾕ鹒暻痳핵錫꾕̺꽔諸呂舂댐晀֐絝饇헸鉽䁉霦卟졅Ȅ⌝斺ꛦ⨨﵉땋䆓İ⵺䃨ﺠ炈㫿ƕৌ൵委켡﯎诽晀⮋࠘ڄ唖䐃炐‷\\udd81嗔σ笺㖊玦딒ힿ婹㷕齘ɕ㔃픕飒神啀㝒핪⨩̔姦㷜땖낋䑣뉝鬐횃ᦵꔅ標ﵛ嗭狢߃嵞븥螐ꍟ\\udea0㝇餃僵䴧㋪숗耥闸賹䉤ꎔ籕儱쓓ힾᡏ襠똩轌ൿ䔨Ꝡ鲶䦬錩弌酺㐄亙歐窗䞈ࠈ⛕鯖馽鲥㭄聘ꑞ血嗚崁檔끫Ꞧꔱ눤\\udd75@䧠擑鍀䂊鎚๗餅ꏣ땤鍽䵍圯ɜ㢈嚗䔅鍫䷰퀈Ẋ侒뤙冪僠Ꮭ철ᖥ말쇂붾鱺윒쮺窅䛰왘﹂삔稞鼖ૹ쮪퓜鍁攬먭揾鹕੔‌啊標䣆賒묐ᐔ拆萰膕ᗊ趦⭪퓰峕獵ᐂ唉喃血襳⣬ꀌ炐䋿ඈ塕땄ᡞ덃圦䏤┪䓅㬄捦穤怤궶鵪剡쓯㼡췍㓴핉᷉襰퍛額‱᩶瞕梷藮녤꧇鈢浵䳇聜඀╄᪲䇠躡Kꯅ୳渭엺΅홣ⴐ㘏尲䞍賙㑜耤lモߌ㒄澣䮍䀹퐭Fᦐૠⴁデ伔艮մٵꄵ漢堪壃虋臟˶淲݋䤇낱삙ꂽ璂䯔䢈⨩⺪㕀턣掙ᯖ샟璊7녻垽篕⫦ὓ塡궇វʫ厭薂际က嚖̒鑭卅ā삋䋂ܑ⪀겳턅䠁઻廭洶틕㨟逾뙮섮꿪嵂넍♢땓왈蜨⑺軅ᥪᵖ仡ퟭ࿲ᑵ♒諗鞅䃚荺⋨ᆀ䘄堸鬿ԫ噾션\\udbac1涻葊浘\\udabb髦捌姥훻叏醖왤⣍㭆¥랟咨沭캷➮捻셛쬦ӱ烔꼶䐊╓쒫Ꮰඛ箈簴ࣛ뭀馎뒯姛殲퀶覙킵怪璍Ꙩビ좗뀸惘텳慠渨੟娊浚㠸覦妭뙁럋魃距횟峣悍鷅膇赆듓咺堈䜄䍸숿됈ݫ檨鐷\\ud9a5퐺䃿̑\\uddab夝ꤷ雝⧵✇ꠛ抹䔤滜\\udb52赘㛜脤ࢭ竨얚뭣⸡\\udbc1ī炀労쫞ဇᇀࢫ犭ꪷ鸁ꭂ⁙䄌ಀ០⑷吚깰壧≇䭀遀⻛魛ㄚ퉢빒ꙋ핕ᴾ蟅鹊㼍ꑫ퇞홅춘瑾픞酎家𣏕ⲷ㫿딉퀼囲ፉ乜ဘ消F탕㱭놵傯᭨量\\udf92Р䡴Ი貅둹펻宝ᑵᖩ孇\\uda82痦푥국찃훖≣洫ȕ\\ud983姕嵃뛙蝸ᚽ딻Һ⃭쎷ఊ㭱릌롎\\udf05铭\\udeb4컒퀜ș\\ud9ee닭汴㛗ꩃ薏䩮퇗盭蹴㫟뭺낉柢昌፶᎐⨫땇ꫧ勦䔹엔૞甠팣䵁蓺⎅騨ᷡ뜴複痬䌃쏠㝓奜钖葹錊㎙絚跃쩅鷝ᱝ쇜쀛籄瞋紝霸Ⴡ根㖬皑갃䎝⸴쪂〿ᶝ斯囫䷕龴鴥퐎ෑ헾\\udbb7䀝䆴఑ꭔ㷾ȖȄᨅⵦ뺮疩䣇႕梀䥗犥纣⚫끉ŝ맀\\ud8b6Ȁ靊禿웣麃䔵緖ⷔ转챕皛鲓≕ࠠ再㚳ವ晾죷ꨕ㷳瑃\\udb72㹀⏪裟晜㶘ퟺ킭稽눶Ꞗ陪ᴥ菉퀀叝ெ鮚杀ࣺ喣熸☵햫㝎ꠍ䲴น阌〬呲덄薛梡栕媥ፍ寧椟࿑踡훩悥⮶籄氃ǧ잺蹙ઘͼ⃈ྣႼ鳐ᢱᤲ벤麑玌ꤋ뷩ʸ䭾暤驏䅲搝렞䩩ⅽ놗婏ᤉ摉錺䗺翹␚쩝둖쩻䚶鍀砅ꤙ卹턿ᣆ캟护駵ᮊ䠩桪釧\\udcc9ᚤ䉣韕덩䣨冗\\udc0d渤嗴싛彾ꔙ덶۩㇈ẓ紬⊏퐩䃀샕虄씩꒛㐰屟t诶燂茯ע献赈걀㢱婛\\ude79耓슮쏱梈ꨄⶏƷ魠À벫ቐ딛仓擉ᑲꗲꀅ퍠⃮평哫嬨셶峞쨸෌뚔썍㲅䝤挓鲮厹䐵伥洡鞫\\udc8d꩎삲ʦⓄ阛奉佷䫖е❢⹕ꮂ뉌ꕬ誶燉呸ʤ틁〵혏ᕏ㓠먡폧͘ﺪ셠ƺ奺㗨텁疶c틤妽௥₷䄊ꔪ胩⭏酿烆㢇ꨊ㢤텈㲓觽즑「₠曊泉㿀ｄ倸였ݟ딁蕩 쟝䔜჆蒞ᦤ窔쩓⑂鹤ؔ틟犑݄꩑\\uda7b웠ᔰἁ旑丏뵤帎暈㋴憄»괒酥ᣘ⎹坯䂁퀽\\ud823΁咩冹굘쟴졐़㬀虰ᐠ㘆꽃帎䍅돮ժ戠✀䇤מּ峕౧폭ᲊ↣吸碚탘펌漭\\uda10嵓푺尯I˃刕쌣햂ꐺ軽菒᎕唣耉ꨈ肌б㰠꡹轄刿⶞嚘䖅嬃洎륁:劣䥐퍒뀺檵ᓲᔹ왫䕒邰씣鈙䀂ハ靃윢瀲㨼ả폜ߌ͕㢱癌礚\\udae5뉜㷐浪ᝰ㰲ꬠ욐甠⃚֧一熀䖆⡟䳊碊蜎퐲㚧൐赉考怕鰁≚閎샮尶㺁朗ﵶ䉁̖샀쯲팕淒ඨӎⴎ鶑㥟횛븎葢倸ಁ뛳왙浄唸轒굹儕揻߫ᕪ啴轤ト啀ቨ䕚ꣂ橪秵肆휙㑞ݦꮀ燇揜㊄ﱣ⥍冋䍪ྦ醕炬遯퇀﫥Ｐ踏娅\\ud816迦ꄹ䃍䌵၆䭗塢Ꟙᕋ毙㒷붒皠\\udd45ⓤ㘝笝눱쪚ꖬ붔⬚펭縜ֈ⇓ꬭ␥芙⦇兎喴훚鴒䀘雏緝㼸㫐ᩳ\\udd5c\\ud92dꨄ몦較塖鵰䶦㝗ݗ黝粅漡䆱숖ѯ䳾䑅委飍鵑殫툘Ḅ針넉涄햇闃ꕴ珜ꍷ탂뚠⒠蹝埗唍ジ鷒뙮ྻ粭뉴ଏ❘膊癪퉇爀몶ꓣᙌ\\udd7d贕\\ude76腭켠焊㨐畏࿷䙝⃩旕뤍趮\\ude76빝䦙營\\ud8da⡍럊驟葵\\udd82嗟㣏떧赻鷛䵝ﶶ໗㗆藘ퟝ㪰㗔惘瑪췦痛흭鵼梞㾋闝澍ᒘ㣶궣豯➺蓣佋ꄲ孂\\uddd3轶Է崊䞷䈐ぉ怛ᙃ즡Ᾱ㋆ဃ魩疠作ᜣ嚽年ṧ㶙薾\\udc27瞹 ᎦヨϷ刹穴僙⺈㫔眗鴝䩎㇝\\ud833ᵵ树㶜卣ⶎ稆\\ud8c1ⷦ眒෗ಓ衴煊馷烣㎶鄳擨掇྆㲭奾Ｂ츾갂躇昧䒝殍䧑룜鵅ª편節骶淞ꝶ궚皡㈕麝ٵଈ뭴癤槡㮗秣쥶帺㨽鎷趥\\udeb7䏣ᖵ搜鎒훈쇸摎퍫揿躶텗眽쁎⭛쓼縢瑁㝗兠큌዗ｉ部℡㓗磭蚺仓铆፷赡㒔॥箯蓲ඥ䵽靼曝乏演斅ጊ㌍㵄챣瑍䧝㝣Ꮖ蓆鋄ﭱ넼怇፷奱㽻喓릌\\uddd6荝\\udd42䰽푘ﺽ꣒+\\udd64틵慤캬ﬓ퓙캚䵐핳逽玌菗ꓒ懼亳퍴彘⹢Θꪦ痭橒긪혢듺퐢࡭簸폗閮铑ፆ賋儯揎꾏ぞ㵷䦈⻠숰Մ☨荤텆خ㵡ꏄ怭㷞愳톯䬽\\udce6ऱ೟딞䵳\\udb83宍抵㴷콹㴂峸ˢ겒紲䍞㏞㲤챁⠁ꀂ퐥뷤ꍣ㤘ﲽ蕔蝼跚㏇梓⭶଼㲦贰丒\\udd15⦽棑潟嶠鱐紭谴늪씄돠辎᷇漳농駟ᣢ挈俭슘엝\\udb4e睙꽘㍪픸ﺳᵥ苨룗隋텯º겼㆕핐⍁㕏存䤋蓕朤䵪ດ槗్䭥㞫씤ဵ≸ꮶ檃쌀冋酬年熨ᾒ燤脥\\u0002팤츠쁚뭛ﺁ襺䪑᭶ꀙᎰ만瀇ᤝﶓ䜐Ⲱꀘ빐έ蠃腚囘륅ﬆՍ紐铟ȩ盆̍慉⁪շ蕌툠希㚔żꕾಶ逐\\udb69䄎턣ŗ絰ᕩᛄ꛳䗣漳繍ק偼ﱃ샐\\udcdbᨛ麤꘥~滽\\udd55䐄蠆䌲喭銫⧭饈Ｒ䐖ữං㧰퇃蔫衰湰⽂䳞⛳쨏屷ꂒ鶚⹴쬎㐃疺쏆ᒲ㛊돠좍꨻ꕫᓸ辞垡볃뿌ꌛ噱閵䲩襷携贔锘뫶乯ᐫ¯瓙釫戽ᔳꩬ餦蘦彘垊茡尵ꪛ䁗೬㟤⏕瀀焇뻳ߗ굤틓䍶技筍博⒬ⶢᔰ洼⋩¢⽍힬잳⾷ᢿཪ\\uddca넜뇠䦢⃖\\udda0칳㸌\\uda1d般蒔ꂆ᪙푣\\ud85e汉᜴竴ꑚ巘ळﺑ뼷푕樆辗ಀퟃᶢ㽐耴鋹拉⏠⹆댵샻ꐔ䳓䮝ㅄꏌཌတ稑࿆㄃荘吃搸萟誤떏匭췢놣䅀壻찁麔ኬ舎⣝봣ಓퟸ臓횏툿\\udf75瓔⸑E䷥磨뵚䣬ꎥ⸲㲇늣䳢꨺裬쮀蠂ߡ⦆㵑㒃搂ﳩⷥ䳂ﻚ魔ഡ심펇⍰럸췋㎎崦閭蛦屄⃐ⳁ᩟럺큌\\udab3梣榥곧ଞ׹±㊀첄ᢲ쬧呆㏸쥝낯뤰Ӑ썢侣嫢찍ሯ\\udd56ₓ헶햨¬ឋ켠븼퓬㕹臓ꂍ栺着᪢赋鷊\\ud88a켳⛺ݝᎲ㍕〢﮳Mĺ請↦۶㹈␔ㆥ眱따ꉁ촎唌臨ꬵ潰㎗蕝〈圳į묵೺끠꿁ꆜ뙣丏醓ീ㐂댴⸳硫꽾讜뭷桳ऻ䓄봼㲘ᗰ佀樔돎꓋㠐鲳婌탔곱绪꺮搼綫肓ꀄ먓艤₫咽⻤ꇛ㲖刲ᇍ벷肟ⲵឮꉙ鼰쒹㕭⺐ݨ箂㩑琩䉫䅭ᒎ龛\\udb5dꦢ\\u001c됚ᙶ炃⤎蛎铒˨ΐꌠ갉蠉腠䪛않罤젢빮㬉बᎎ쿉礈ˇ馁ؘ鍊ᕑ쉁欥鋢饞⋠糹ꀏ礪ıᆨ꓊\\ud993ᙏ餐⏅鉆퀹㕤谁ᰀ\\ud918ȟ㞓卽뜚⩒卲ꗭ刐쥍愍\\udf33ᬡ䬞듃稒枬庵竗ᷘᴐ㦓䕉\\ud93f˶䘗僤壢庺㤾삚ď쵿婰裣㤇⁬㠺ʡ묚合頎䴙愮逑纘ﲤ㕗뮛嗩5ⵅ巠止\\ude0fޙ㎧㘗쎙À䛑혀梁邿ᙳ碩飕큔夛偼庎鐏쏡霤ฺӨ老哯\\ud830竛撸釪\\udf5f旆跶⧠十킠᜔\\ud8f1ꁃ꾮꩙\\udf63ŕ㓷\\ud999࿫橮駡۫ᑢﮚ帧㒒ᆐ쉚僆\\uda5a爢ꨠ帐揓叝䙤馴条阍誐淚덞⛑ꍨ佘끩☍ﷀ༤ⳝᰦ姙㈇樆泖餁汵⮸ダ火 鎙킁ِ൐睠ɬﴖ\\uda02뚒㱒勑狛ୗⷒ툊퓡ᭌᖛೊ駦៸૷翲測股♟駰尿嚯哱鱴♏˨皣╦寨\\ude4c촲જ롲ၙ搻騞頑晉钞娌㭴⣊\\udb40⊽⽄យ봴䀌ꭃ擃鑚䒌襧᳇㏦꺣쯋ﺤ㴹೒ꇍ淃㛖읛첮喒噪煌풬⟬璳갧澅꺾꿗嬑淰퉎턘堃奮컊ᜪﲡ懍媱ᳱ掁Ⳋߢ綽쫙\\udb12귃驢﬐蹑㬐鴶堻苐䎱啴㭀灝뼚퇾朥櫁挀ﯝ㴌\\ud8db঒훱됟湉鴷攻䁃厵໤灲习ཎ၇魫佖寳邟騧鏜ꩮ딉䐾벧ꔁ䪖ᦲ升緗캙뷟䬁㠒妼껵魊ꨳ睠쐂ꌹᏛ姩䎲⭡奄☣胏裘ᆐㄔ䞁堝崣磪壻븢ᙌ瀁㝇ଌꛒ䣌喫᠈ㅭ욥Ѧ솏ᅽ얧Յ癁幜괼᱄湈ሦ鼢쒴匿鑥옼ﺈ戉耳ᖷ陣ᰜ㷀힋뀐顡堖벴഑賕ဃ腕ਸ਼㶘\\ud978㈯鮟苹꧱هᖩ葁䉔輨⡮캖첻訐쌥嬰訕뫄㝫䉮閼ꢰ楹浕뚵䬋ఱ࢞싽嬏⼔骴⻬䊽㡰愲❻냒䆽ቌ祧࠷䀘荝졀ཉ䮛刖ᖆ\\udb5eꉗ啃ᾠ⌐됌\\ud91a㤰୒᠞黥霭讂ై㍻౟뤨㖼깴Ҕ亥떡﨓޽ᴶꑵ㚜ꦹᷮខ졞覔샗넧鐇쳵㎷盙︛亣룴쉲퉋\\ud9ec흼纭瓧╠瘓ꛔ᫜䳰뮑˓땁蘒薃徹能ﬄs髣Ȼ㺦⪲ᴛ㲫몖㐜눗䇨囪孪ۀ쥎஺쇺㰚臚鿯羲㄂蟼ᴑ晪ⳮ\\udd38壈鎑켸븡쿘챜庀팺眀\\u0001윀谜嫣등ꔋ끴氞许堕蟙㌇롘㈌稟⇺礏澇モ\\ud887嶵ꗯТԡ찂囨櫯臝筎ᶘ\\udcc1\\udb87⨟㳨䝚敱ᰔࡘᘇ켒⶝ዔ묙淔鶖\\udaa2㠼滘悪㓚槳侬ᦱ糑鯁రᨐ\\ud99b蛬셄껭䜟캏荦ꀋ\\ud9bdﶵ묳鲎㧰츧ڄ걕䞇빰ݼ凭䦃瑚裬䘮섂ጎ쫇뙇癧鹋ꯑ컡빅⧗⦛컰䂗즺芈┄땣䐋ꔵ\\udb9c窯d䤵舍ྉ⃇ꐔ⦚눢뼗润凬뮔ꁕ뫠ś䕭⾲⛬\\udaab뮿ۻ㕭붕왰掼Ⰾ㔸忕ꁃᮈꈌ쟮옮㪆鯨숁҈ﻔ䝏䶓吠♴㢝脱⛺Ꮊ詞ⵣ䬸\\udf14扝胹鮒䨧퐃ᱹ炈鰼蜀⌧₂එ臄鍅耬䰠 餂ﲄ䧸鏃흼២週权ࠉ뱽댨㘸\\udbac\\ud907쓥퉷ℹ悜鼰ƚ䘳롲\\udc27螪᳤猀䠀ᢝ޽觃⋹魏℧ꚞ᩶蚙❭쎠韉ʜꉷ₺ৢ鼇ऩ풄頥䒳艽嘿ᵏ륑ﱍᯌ䞍꜀宦텍פּ둳껛᱾맑\\udf69ὐ퐈杽ᾁ뙮쩱쌜ﶚ튔㰍惬㵆݄⢔啕슛㹀⵨晀뽛뵭䏮渦仲ﷀꛎ녌ﵵ胷섴趫炔欯㳓䑤⮪鈵咬骪⛕꧞㑍䴮겪㱟쩗쫋꩖綽纜짗\\udd8c浵䚑ꉒﲣ箁祈ꪀ녻킂㜉됾뉚⇄譩ᆟᲱ贾藨ഖ촊䮠膤뮌퐱璸ꀑ탩蒒쓻饯嗢䰿쟹淏됉섛쉭ꖂ킿龯럨퐧膌쉺\\udd5b쭫⒚\\udac0鍅壎頮㥿㜚ᶽ탔㎾䡳쯡Მﳧ햜ㄙ훆⯮ⳇ‶䍬颷૕ᴈ껡粎諾ᒓꐵ⮳澺\\uda45젊ꭚ酮⬑뀒믎鄫썟亣㫈휎狅汜㸗䫂豄겚뱻沋ᒛ㧉䛕隷嚑낖ጨ띘搪ॴⱍ㞪퉝픰㐿졤혃㱡\\udb3bꘜ퍑䐴\\udd0cힿ늰艠拹䢴퓼靌䳆鈱㞠᧢샮耖X䇋剀⚌幟硛樾鞮徙魄휗᫔䥸釯㴘鎓䢹쨳퓻ꌲ⫍덍䶜ᔼ枵ဝ쥼䫉蜑嵊㪍凕瑜坧⬍䳣돉၎㤄踓柭邶窽詗핥䴶䚊픃댌㕵黨摾﵏픍鿳帹텺茂끷思赁猢챩\\udacb͒逋㻇̯㴉㹫䄟ݚᣝ쯔彾㭲Ꮛ앝ꡁ᝱彘ب㩣睖昷⧊ᴊ곫풪폛ᳮ徼㵙揕聖㭕쒁筞꽣壊덙迃솗ﯯ㲏嗹隐꼬鲴孜ㅿ藉鎄忭穀ㄗ౏畿匒犇並蹣⏽侂킶쳼㬆Ὴ뿢輪∝病ݜ\\ud810ե䨀⺮穲댳ﲶᗓ〡ᴸ\\ud98d쌫䪄\\udabdᗅ圞㜋㝌쩕䓟ﲛ⳯펔睽ת\\udd0d嵜㬳좀欂龼屏評몮쪑곈跀괐籽稷䘝葼෥ힶ꼏刍᷅ꢪ\\udd0e⦟ꚬ학摃嬲ུ팟䠳뱕鎳ឣ㳡杰系滗ۜ᳃㭹豣罢赍柪湜堵Ϝꮞ퐁㑭갰ဤ橆⍸팈㉍䯂⨀〴ሐꏯꊶ醀닮딴힡葸숀᦬﫢✟꜕᱓艾䋩秃落㼦l였ट뉞\\udb8aꚂ炋砣ᬱ煁凲谠鍰倽옦액銕ᨕᲖ镆쉀࣭鰋ऄⒸ㯟襹邊ኾ䐣ᘁ逾㢇ő캠梈勰Ĥ텃诀侱ꔈﬞ慆\\u0012෦ר帪▯瞽橢缾⵪住鐛궸ⷷ﹨薯【큣謿迀˓१㥥銠ⳳᎻ㚤킗覈⼵⋿㊈সᭉ휄\\udf24놥䌁ꙶ斘⺕찁륄≈鯴范칕㳱侦뺵屧ȋ췤む␁몇س햎썙馃슼䃄Ձ鲎ㆧ䄄ጬ亪邱篟鳫凴δඨ㔤璒攍髗踵輦偻擢聗䌯讛⧐蔄\\u0000\",\"actionData\",\"errors\"]\n");</script><!--$?--><template id="B:1"></template><!--/$--></div><script>$RB=[];$RV=function(a){$RT=performance.now();for(var b=0;b<a.length;b+=2){var c=a[b],e=a[b+1];null!==e.parentNode&&e.parentNode.removeChild(e);var f=c.parentNode;if(f){var g=c.previousSibling,h=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d||"/&"===d)if(0===h)break;else h--;else"$"!==d&&"$?"!==d&&"$~"!==d&&"$!"!==d&&"&"!==d||h++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;e.firstChild;)f.insertBefore(e.firstChild,c);g.data="$";g._reactRetry&&requestAnimationFrame(g._reactRetry)}}a.length=0};
$RC=function(a,b){if(b=document.getElementById(b))(a=document.getElementById(a))?(a.previousSibling.data="$~",$RB.push(a,b),2===$RB.length&&("number"!==typeof $RT?requestAnimationFrame($RV.bind(null,$RB)):(a=performance.now(),setTimeout($RV.bind(null,$RB),2300>a&&2E3<a?2300-a:$RT+300-a)))):b.parentNode.removeChild(b)};$RC("B:0","S:0")</script><div hidden id="S:1"><script>window.__reactRouterContext.streamController.close();</script></div><script>$RC("B:1","S:1")</script></body></html>