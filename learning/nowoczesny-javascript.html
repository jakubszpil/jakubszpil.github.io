<!DOCTYPE html><html lang="pl"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="modulepreload" href="/fetch.js"/><link rel="icon" href="/favicon.svg" sizes="any" type="image/svg+xml"/><link rel="preload" as="style" href="/assets/styles-DC0ABVnQ.css"/><link rel="preload prefetch" href="/fonts/geist.ttf" as="font" type="font/ttf" crossorigin="anonymous"/><title>Renesans w JS, czyli nowoczesny JavaScript - Jakub Szpil</title><meta name="description" content="JavaScript jest językiem programowania, który jest powszechnie stosowany do tworzenia dynamicznych i interaktywnych stron internetowych. W ciągu ostatnich lat JavaScript znacznie ewoluował, wprowadzając nowe funkcje i poprawiając istniejące mechanizmy. W tym kursie omówimy najważniejsze elementy nowoczesnego JavaScript, w tym ES6 i nowsze."/><meta name="keywords" content="javascript,kurs,wprowadzenie,przewodnik,web,frontend,learning"/><meta property="article:published_time" content="2024-06-30T00:00:00.000Z"/><meta property="og:type" content="article"/><meta property="og:url" content="https://jakubszpil.github.io/learning/nowoczesny-javascript/"/><meta property="og:title" content="Renesans w JS, czyli nowoczesny JavaScript - Jakub Szpil"/><meta property="og:description" content="JavaScript jest językiem programowania, który jest powszechnie stosowany do tworzenia dynamicznych i interaktywnych stron internetowych. W ciągu ostatnich lat JavaScript znacznie ewoluował, wprowadzając nowe funkcje i poprawiając istniejące mechanizmy. W tym kursie omówimy najważniejsze elementy nowoczesnego JavaScript, w tym ES6 i nowsze."/><meta property="twitter:card" content="summary_large_image"/><meta property="twitter:url" content="https://jakubszpil.github.io/learning/nowoczesny-javascript/"/><meta property="twitter:title" content="Renesans w JS, czyli nowoczesny JavaScript - Jakub Szpil"/><meta property="twitter:description" content="JavaScript jest językiem programowania, który jest powszechnie stosowany do tworzenia dynamicznych i interaktywnych stron internetowych. W ciągu ostatnich lat JavaScript znacznie ewoluował, wprowadzając nowe funkcje i poprawiając istniejące mechanizmy. W tym kursie omówimy najważniejsze elementy nowoczesnego JavaScript, w tym ES6 i nowsze."/><link rel="modulepreload" href="/assets/manifest-1770ae74.js"/><link rel="modulepreload" href="/assets/entry.client-D07Jc1yP.js"/><link rel="modulepreload" href="/assets/jsx-runtime-D_zvdyIk.js"/><link rel="modulepreload" href="/assets/chunk-OIYGIGL5-Rdhby1S0.js"/><link rel="modulepreload" href="/assets/index-DJQXGD61.js"/><link rel="modulepreload" href="/assets/root-B4SihuEH.js"/><link rel="modulepreload" href="/assets/layout-DYpV2se7.js"/><link rel="modulepreload" href="/assets/button-BMGgmMxT.js"/><link rel="modulepreload" href="/assets/link-with-prefetch-BIs6hVLd.js"/><link rel="modulepreload" href="/assets/icons-BBGQWBin.js"/><link rel="modulepreload" href="/assets/socials-DGthjeXP.js"/><link rel="modulepreload" href="/assets/date-NK96Yl5Q.js"/><link rel="modulepreload" href="/assets/not-found-CGoFJWhv.js"/><link rel="modulepreload" href="/assets/seo-Do91G143.js"/><link rel="modulepreload" href="/assets/course-details-DLJ6fZBl.js"/><link rel="modulepreload" href="/assets/categories-BBucIGjV.js"/><link rel="modulepreload" href="/assets/edit-resource-Bp0MeTOm.js"/><link rel="modulepreload" href="/assets/banner-DCe0eTPI.js"/><link rel="modulepreload" href="/assets/compress-C_V_4BTm.js"/><link rel="modulepreload" href="/assets/creation-date-x1jkwlYO.js"/><link rel="stylesheet" href="/assets/styles-DC0ABVnQ.css"/><script>globalThis.timestamp=1760783880073</script><script>let k="theme";let t="dark";let s=localStorage;let c=document.documentElement.classList;let v=s.getItem(k);if(v===null||v==="SYSTEM")matchMedia("(prefers-color-scheme:dark)").matches?c.add(t):c.remove(t);else if(v==="DARK")c.add(t);else if(v==="LIGHT")c.remove(t);else s.removeItem(k);</script><script type="module" src="/fetch.js"></script></head><body style="-webkit-tap-highlight-color:transparent"><header class="sticky w-full bg-background top-0 left-0 z-50 border-b"><div class="container pb-3! pt-4! px-3! flex justify-between items-center"><a data-slot="button" class="button button--variant-ghost button--size-sm font-bold" href="/" data-discover="true">jakubszpil</a><div class="flex flex-1 justify-end items-center sm:gap-1"><nav class="hidden items-center lg:flex"><a data-slot="button" class="button button--variant-ghost button--size-sm" href="/" data-discover="true">🏠 Strona główna</a><a data-slot="button" class="button button--variant-ghost button--size-sm" href="/blog" data-discover="true">📝 Blog</a><a data-slot="button" class="button button--variant-ghost button--size-sm" href="/learning" data-discover="true">🏫 Learning</a><a data-slot="button" class="button button--variant-ghost button--size-sm" href="/portfolio" data-discover="true">🛠️ Portfolio</a><a data-slot="button" class="button button--variant-ghost button--size-sm" href="/me" data-discover="true">🙋‍♂️ O mnie</a></nav><a data-slot="button" class="button button--variant-ghost button--size-icon inline-flex items-center justify-center" aria-label="Szukaj" title="Szukaj (CTRL+K)" href="/search" data-discover="true"><span class="sr-only">Szukaj</span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="size-6"><path d="M10 10m-7 0a7 7 0 1 0 14 0a7 7 0 1 0 -14 0"></path><path d="M21 21l-6 -6"></path></svg></a><div class="hidden xs:flex items-center sm:gap-1"><a href="https://www.linkedin.com/in/jakubszpil/" target="_blank" rel="noreferrer" data-slot="button" class="button button--variant-ghost button--size-icon inline-flex items-center gap-1 no-underline" title="LinkedIn" aria-label="LinkedIn"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="size-6"><path d="M8 11v5"></path><path d="M8 8v.01"></path><path d="M12 16v-5"></path><path d="M16 16v-3a2 2 0 1 0 -4 0"></path><path d="M3 7a4 4 0 0 1 4 -4h10a4 4 0 0 1 4 4v10a4 4 0 0 1 -4 4h-10a4 4 0 0 1 -4 -4z"></path></svg><span class="sr-only">LinkedIn</span></a><a href="https://github.com/jakubszpil/" target="_blank" rel="noreferrer" data-slot="button" class="button button--variant-ghost button--size-icon inline-flex items-center gap-1 no-underline" title="GitHub" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="size-6"><path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5"></path></svg><span class="sr-only">GitHub</span></a></div><button data-slot="dropdown-menu-trigger" class="button button--variant-ghost button--size-icon cursor-pointer" title="Zmień motyw" type="button" id="radix-_R_4ej5_" aria-haspopup="menu" aria-expanded="false" data-state="closed"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="size-6"><path d="M9.173 14.83a4 4 0 1 1 5.657 -5.657"></path><path d="M11.294 12.707l.174 .247a7.5 7.5 0 0 0 8.845 2.492a9 9 0 0 1 -14.671 2.914"></path><path d="M3 12h1"></path><path d="M12 3v1"></path><path d="M5.6 5.6l.7 .7"></path><path d="M3 21l18 -18"></path></svg></button><button data-slot="button" class="button button--variant-link button--size-icon inline-flex items-center justify-center relative z-50 lg:hidden" aria-label="Otwórz menu"><span class="sr-only">Otwórz menu</span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="size-6 text-black! dark:text-white!"><path d="M4 6l16 0"></path><path d="M4 12l16 0"></path><path d="M4 18l16 0"></path></svg></button></div></div></header><main><header class="prose container"><h1 class="mb-5">Renesans w JS, czyli nowoczesny JavaScript</h1><div class="text-xs sm:text-sm my-6"><div class="inline-block" title="Data opublikowania"><span class="mr-0.5">📆</span><span class="hidden">Data opublikowania:</span><time>30 czerwca 2024</time></div><span class="ml-2 mr-1">/</span><div class="inline-block sm:inline" title="Czas potrzebny na przeczytanie"><span class="mr-0.5">⌛</span><span class="hidden">Czas potrzebny na przeczytanie:</span>18 minut<!-- --> czytania</div></div><div class="flex items-center gap-3 flex-wrap"><a data-slot="button" class="button button--variant-secondary button--size-sm no-underline!" href="/learning/kategorie/javascript" data-discover="true">JavaScript</a></div></header><article class="prose container pt-0 prose-emerald"><p>Witaj w świecie <strong>nowoczesnego JavaScriptu</strong>! 🚀 Jeśli HTML to szkielet strony, a CSS to jej wygląd, to JavaScript jest sercem i mózgiem - sprawia, że strona ożywa, staje się interaktywna i dynamiczna. W ciągu ostatnich lat JavaScript przeszedł prawdziwy "renesans". Dzięki wprowadzeniu standardu <strong>ES6</strong> (ECMAScript 2015) i kolejnych aktualizacji, pisanie kodu w JS stało się znacznie przyjemniejsze, bezpieczniejsze i bardziej efektywne.</p>
<p>Ten przewodnik zabierze Cię w podróż po najważniejszych nowościach, które musisz znać, aby pisać <strong>nowoczesny JavaScript</strong>. Nie martw się, jeśli jesteś początkujący/a - wszystko wyjaśnimy krok po kroku, z przykładami i analogiami, byś mógł/mogła od razu zastosować nową wiedzę w praktyce. Czas unowocześnić swoje umiejętności! ✨</p>
<h2 id="spis-treści" class="scroll-mt-20 lg:scroll-mt-10"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#spis-treści">>></a>Spis treści</h2>
<ol>
<li><a href="#zmienne-let-const-i-zakresy-blokowe--po%C5%BCegnanie-z-var">Zmienne: <code>let</code>, <code>const</code> i zakresy blokowe - pożegnanie z <code>var</code>?</a></li>
<li><a href="#funkcje-strza%C5%82kowe-arrow-functions-i-ich-zastosowania--kr%C3%B3cej-i-czytelniej">Funkcje strzałkowe (Arrow Functions) i ich zastosowania - krócej i czytelniej</a></li>
<li><a href="#szablony-string%C3%B3w-template-literals--%C5%82atwiejsza-praca-z-tekstem">Szablony stringów (Template Literals) - łatwiejsza praca z tekstem</a></li>
<li><a href="#destrukturyzacja-tablic-i-obiekt%C3%B3w--wyci%C4%85gnij-to-czego-potrzebujesz">Destrukturyzacja tablic i obiektów - wyciągnij to, czego potrzebujesz</a></li>
<li><a href="#spread-i-rest-operator---elastyczno%C5%9B%C4%87-w-manipulacji-danymi">Spread i Rest Operator (<code>...</code>) - elastyczność w manipulacji danymi</a></li>
<li><a href="#promise-api-i-obs%C5%82uga-asynchroniczno%C5%9Bci--opowiadaj-historie-o-przysz%C5%82o%C5%9Bci">Promise API i obsługa asynchroniczności - opowiadaj historie o przyszłości</a></li>
<li><a href="#asyncawait--nowoczesna-obs%C5%82uga-kodu-asynchronicznego--pisz-asynchronicznie-my%C5%9Bl-synchronicznie">Async/await - nowoczesna obsługa kodu asynchronicznego - pisz asynchronicznie, myśl synchronicznie</a></li>
<li><a href="#zadania-do-wykonania-sprawd%C5%BA-swoj%C4%85-wiedz%C4%99">Zadania do wykonania: Sprawdź swoją wiedzę!</a></li>
</ol>
<hr>
<h2 id="zmienne-let-const-i-zakresy-blokowe---pożegnanie-z-var" class="scroll-mt-20 lg:scroll-mt-10"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#zmienne-let-const-i-zakresy-blokowe---pożegnanie-z-var">>></a>Zmienne: <code>let</code>, <code>const</code> i zakresy blokowe - pożegnanie z <code>var</code>?</h2>
<p>W starszych wersjach JavaScriptu zmienne deklarowaliśmy wyłącznie za pomocą słowa kluczowego <code>var</code>. Często prowadziło to do pomyłek i trudnych do wykrycia błędów. Nowoczesny JavaScript wprowadza dwa nowe sposoby deklarowania zmiennych: <strong><code>let</code></strong> i <strong><code>const</code></strong>, które znacznie poprawiają bezpieczeństwo i przewidywalność kodu.</p>
<h3 id="zakres-blokowy-block-scope" class="scroll-mt-20 lg:scroll-mt-10"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#zakres-blokowy-block-scope">>>></a>Zakres blokowy (<code>block scope</code>)</h3>
<p>To kluczowa różnica! Zmienne zadeklarowane za pomocą <code>let</code> i <code>const</code> mają <strong>zakres blokowy</strong>. Co to znaczy? Oznaczają, że zmienna istnieje tylko w obrębie najbliższego <strong>bloku kodu</strong>, czyli wszystko, co znajduje się między klamrowymi nawiasami <code>{ ... }</code>.</p>
<p>Pomyśl o tym jak o specjalnej, prywatnej przestrzeni. Jeśli zmienna <code>x</code> jest zadeklarowana wewnątrz bloku <code>if</code>, będzie dostępna tylko w tym bloku. Próba użycia jej poza nim spowoduje błąd. To chroni Cię przed przypadkowym nadpisaniem zmiennych o tej samej nazwie w innej części kodu.</p>
<p><strong>Przykład:</strong></p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) {
  <span class="hljs-keyword">let</span> x = <span class="hljs-number">5</span>; <span class="hljs-comment">// x istnieje tylko wewnątrz tego bloku if</span>
  <span class="hljs-keyword">const</span> y = <span class="hljs-number">10</span>; <span class="hljs-comment">// y również istnieje tylko wewnątrz tego bloku</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x); <span class="hljs-comment">// Wyświetli: 5 (dostępne, bo jesteśmy w bloku)</span>
}
<span class="hljs-comment">// console.log(x); // WYWOŁA BŁĄD! ReferenceError: x is not defined</span>
<span class="hljs-comment">// console.log(y); // WYWOŁA BŁĄD! ReferenceError: y is not defined</span>
</code></pre>
<p>Dla porównania, <code>var</code> ma <strong>zakres funkcyjny</strong> (function scope), co oznacza, że zmienna zadeklarowana w funkcji jest dostępna w całej funkcji, ale poza funkcją jest dostępna globalnie, co jest źródłem wielu problemów. Dlatego w nowoczesnym kodzie <strong>zdecydowanie unikamy <code>var</code></strong>.</p>
<h3 id="różnice-między-let-const-i-var" class="scroll-mt-20 lg:scroll-mt-10"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#różnice-między-let-const-i-var">>>></a>Różnice między <code>let</code>, <code>const</code> i <code>var</code></h3>
<ul>
<li>
<p><strong><code>let</code></strong>:</p>
<ul>
<li><strong>Deklaruje zmienną</strong>, której wartość może być <strong>zmieniana</strong> w dowolnym momencie.</li>
<li>Ma <strong>zakres blokowy</strong>.</li>
<li>Nie można jej ponownie zadeklarować w tym samym bloku (np. <code>let x = 5; let x = 10;</code> to błąd), ale można zmienić jej wartość (<code>x = 10;</code>).</li>
<li>Używaj <code>let</code>, gdy wiesz, że wartość zmiennej będzie się zmieniać (np. licznik w pętli).</li>
</ul>
</li>
<li>
<p><strong><code>const</code></strong>:</p>
<ul>
<li>Deklaruje <strong>stałą</strong>, której wartość musi być <strong>przypisana od razu</strong> i <strong>nie może być zmieniana</strong> później.</li>
<li>Ma <strong>zakres blokowy</strong>.</li>
<li>Jeśli przypiszesz do <code>const</code> obiekt lub tablicę, nie możesz przypisać do niej <em>nowego</em> obiektu/tablicy, ale możesz <strong>modyfikować zawartość</strong> tego obiektu/tablicy (np. dodawać lub usuwać elementy). <code>const</code> gwarantuje, że referencja (wskaźnik) do obiektu pozostaje taka sama, ale nie "zamraża" samego obiektu.</li>
<li>Używaj <code>const</code>, gdy wartość zmiennej nie powinna się zmieniać. To jest domyślny wybór w nowoczesnym JS, chyba że potrzebujesz <code>let</code>.</li>
</ul>
</li>
<li>
<p><strong><code>var</code></strong>:</p>
<ul>
<li><strong>Ma zakres funkcyjny</strong> (lub globalny, jeśli jest poza funkcją).</li>
<li>Jest podatny na <strong>hoisting</strong> (podnoszenie deklaracji), co oznacza, że deklaracja zmiennej jest "przenoszona" na początek zakresu, co może prowadzić do nieintuicyjnych zachowań.</li>
<li>Można go <strong>wielokrotnie deklarować</strong> w tym samym zakresie, co łatwo prowadzi do przypadkowych nadpisań.</li>
<li><strong>Unikaj używania <code>var</code> w nowym kodzie!</strong></li>
</ul>
</li>
</ul>
<p><strong>Przykład <code>const</code> z obiektem/tablicą:</strong></p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> tablica = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
tablica.<span class="hljs-title function_">push</span>(<span class="hljs-number">4</span>); <span class="hljs-comment">// DOZWOLONE! Zmieniamy zawartość tablicy, nie przypisujemy nowej tablicy.</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(tablica); <span class="hljs-comment">// Wyświetli: [1, 2, 3, 4]</span>

<span class="hljs-comment">// tablica = [5, 6]; // WYWOŁA BŁĄD! TypeError: Assignment to constant variable.</span>
<span class="hljs-comment">// Próbujesz przypisać zupełnie nową tablicę do stałej referencji.</span>

<span class="hljs-keyword">const</span> osoba = { <span class="hljs-attr">imie</span>: <span class="hljs-string">"Anna"</span>, <span class="hljs-attr">wiek</span>: <span class="hljs-number">28</span> };
osoba.<span class="hljs-property">wiek</span> = <span class="hljs-number">29</span>; <span class="hljs-comment">// DOZWOLONE! Zmieniamy właściwość obiektu, nie przypisujemy nowego obiektu.</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(osoba); <span class="hljs-comment">// Wyświetli: { imie: "Anna", wiek: 29 }</span>

<span class="hljs-comment">// osoba = { nazwisko: "Nowak" }; // WYWOŁA BŁĄD!</span>
</code></pre>
<hr>
<h2 id="funkcje-strzałkowe-arrow-functions-i-ich-zastosowania---krócej-i-czytelniej" class="scroll-mt-20 lg:scroll-mt-10"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#funkcje-strzałkowe-arrow-functions-i-ich-zastosowania---krócej-i-czytelniej">>></a>Funkcje strzałkowe (Arrow Functions) i ich zastosowania - krócej i czytelniej</h2>
<p>Funkcje strzałkowe to zwięzła alternatywa dla tradycyjnych funkcji JavaScript, która została wprowadzona w ES6. Są nie tylko krótsze, ale także rozwiązują pewien problem z kontekstem <code>this</code>, który często mylił początkujących programistów.</p>
<h3 id="składnia-funkcji-strzałkowej" class="scroll-mt-20 lg:scroll-mt-10"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#składnia-funkcji-strzałkowej">>>></a>Składnia funkcji strzałkowej</h3>
<p>Największą zaletą funkcji strzałkowych jest ich zwięzła składnia, zwłaszcza dla prostych funkcji.</p>
<ul>
<li>
<p><strong>Szybszy zapis (szczególnie dla funkcji jedno-liniowych):</strong>
Jeśli funkcja składa się tylko z jednej instrukcji, która zwraca wartość, możesz pominąć nawiasy klamrowe <code>{}</code> i słowo kluczowe <code>return</code>.</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// Tradycyjna funkcja</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">dodajStara</span>(<span class="hljs-params">a, b</span>) {
  <span class="hljs-keyword">return</span> a + b;
}

<span class="hljs-comment">// Funkcja strzałkowa (krótszy zapis)</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">dodaj</span> = (<span class="hljs-params">a, b</span>) => a + b;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">dodaj</span>(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">// Wyświetli: 8</span>

<span class="hljs-comment">// Funkcja z jednym argumentem (można pominąć nawiasy wokół argumentu)</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">powitanie</span> = (<span class="hljs-params">imie</span>) => <span class="hljs-string">`Cześć, <span class="hljs-subst">${imie}</span>!`</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">powitanie</span>(<span class="hljs-string">"Ola"</span>)); <span class="hljs-comment">// Wyświetli: Cześć, Ola!</span>

<span class="hljs-comment">// Funkcja bez argumentów (konieczne puste nawiasy)</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">powiedzHello</span> = (<span class="hljs-params"></span>) => <span class="hljs-string">"Hello!"</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">powiedzHello</span>()); <span class="hljs-comment">// Wyświetli: Hello!</span>
</code></pre>
</li>
<li>
<p><strong>Brak własnego obiektu <code>arguments</code>:</strong> Funkcje strzałkowe nie mają własnego obiektu <code>arguments</code> (który zawiera wszystkie argumenty przekazane do funkcji). Jeśli go potrzebujesz, użyj <strong>rest operatora</strong> (<code>...</code>), o którym powiemy później.</p>
</li>
<li>
<p><strong>Brak możliwości użycia jako konstruktor:</strong> Nie możesz użyć funkcji strzałkowej do tworzenia nowych obiektów za pomocą słowa kluczowego <code>new</code>.</p>
</li>
</ul>
<h3 id="funkcje-strzałkowe-a-kontekst-this" class="scroll-mt-20 lg:scroll-mt-10"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#funkcje-strzałkowe-a-kontekst-this">>>></a>Funkcje strzałkowe a kontekst <code>this</code></h3>
<p>To jest jeden z najważniejszych powodów, dla których wprowadzono funkcje strzałkowe. W tradycyjnych funkcjach, wartość <code>this</code> zależy od tego, jak funkcja jest wywoływana. To prowadziło do częstych błędów, zwłaszcza w callbackach (funkcjach wywoływanych przez inne funkcje, np. w <code>setTimeout</code> czy w obsłudze zdarzeń).</p>
<p>Funkcje strzałkowe rozwiązują ten problem: <strong>nie mają własnego <code>this</code></strong>. Zamiast tego, <strong>dziedziczą <code>this</code> z otoczenia, w którym zostały zadeklarowane</strong> (tzw. leksykalny <code>this</code>).</p>
<p><strong>Przykład problemu ze <code>this</code> w tradycyjnych funkcjach:</strong></p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// Tradycyjna funkcja, która "gubi" kontekst this</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">TimerProblem</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">sekundy</span> = <span class="hljs-number">0</span>;
  <span class="hljs-built_in">setInterval</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-comment">// Tutaj 'this' nie odnosi się do obiektu TimerProblem,</span>
    <span class="hljs-comment">// ale do obiektu globalnego (np. window w przeglądarce) lub jest undefined w trybie 'strict mode'</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">sekundy</span>++; <span class="hljs-comment">// To nie zadziała tak, jak byśmy chcieli!</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">sekundy</span>);
  }, <span class="hljs-number">1000</span>);
}
<span class="hljs-comment">// new TimerProblem(); // W konsoli prawdopodobnie zobaczysz NaN lub błąd</span>
</code></pre>
<p><strong>Rozwiązanie z funkcją strzałkową:</strong></p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">TimerPoprawny</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">sekundy</span> = <span class="hljs-number">0</span>;
  <span class="hljs-comment">// Funkcja strzałkowa dziedziczy 'this' z TimerPoprawny (czyli z obiektu TimerPoprawny)</span>
  <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">sekundy</span>++;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Sekundy: <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.sekundy}</span>`</span>);
  }, <span class="hljs-number">1000</span>);
}
<span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerPoprawny</span>(); <span class="hljs-comment">// Będzie poprawnie liczyć sekundy: Sekundy: 1, Sekundy: 2, itd.</span>
</code></pre>
<p>Dzięki temu funkcje strzałkowe są idealne do użycia w callbackach, metodach obiektów (choć nie jako metody obiektów najwyższego poziomu, bo wtedy <code>this</code> wskazałoby na <code>window</code>), czy w sytuacjach, gdzie chcesz, aby <code>this</code> zachowało kontekst nadrzędny.</p>
<hr>
<h2 id="szablony-stringów-template-literals---łatwiejsza-praca-z-tekstem" class="scroll-mt-20 lg:scroll-mt-10"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#szablony-stringów-template-literals---łatwiejsza-praca-z-tekstem">>></a>Szablony stringów (Template Literals) - łatwiejsza praca z tekstem</h2>
<p>Szablony stringów, wprowadzone w ES6, to potężne narzędzie do tworzenia ciągów znaków (stringów). Zastępują tradycyjne łączenie stringów za pomocą operatora <code>+</code> i oferują znacznie większą elastyczność i czytelność. Używamy ich, otaczając tekst <strong>backtickami</strong> (apostrofami wstecznymi) <code> </code> zamiast pojedynczych lub podwójnych cudzysłowów.</p>
<h3 id="interpolacja-i-wielolinijkowość" class="scroll-mt-20 lg:scroll-mt-10"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#interpolacja-i-wielolinijkowość">>>></a>Interpolacja i wielolinijkowość</h3>
<ul>
<li>
<p><strong>Interpolacja zmiennych i wyrażeń:</strong>
Możesz łatwo osadzać zmienne lub dowolne wyrażenia JavaScript bezpośrednio w stringu, używając składni <code>${...}</code>. To znacznie ułatwia budowanie dynamicznych komunikatów.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> imie = <span class="hljs-string">"Alicja"</span>;
<span class="hljs-keyword">const</span> wiek = <span class="hljs-number">30</span>;

<span class="hljs-comment">// Stary sposób: męczące łączenie stringów</span>
<span class="hljs-keyword">const</span> infoStare = <span class="hljs-string">"Mam na imię "</span> + imie + <span class="hljs-string">" i mam "</span> + wiek + <span class="hljs-string">" lat."</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(infoStare); <span class="hljs-comment">// Wyświetli: Mam na imię Alicja i mam 30 lat.</span>

<span class="hljs-comment">// Nowy sposób z szablonami stringów: czytelniej i prościej!</span>
<span class="hljs-keyword">const</span> infoNowe = <span class="hljs-string">`Mam na imię <span class="hljs-subst">${imie}</span> i mam <span class="hljs-subst">${wiek}</span> lat.`</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(infoNowe); <span class="hljs-comment">// Wyświetli: Mam na imię Alicja i mam 30 lat.</span>

<span class="hljs-comment">// Możesz umieszczać dowolne wyrażenia JavaScript:</span>
<span class="hljs-keyword">const</span> cena = <span class="hljs-number">10.5</span>;
<span class="hljs-keyword">const</span> ilosc = <span class="hljs-number">2</span>;
<span class="hljs-keyword">const</span> rachunek = <span class="hljs-string">`Koszt zakupu: <span class="hljs-subst">${cena * ilosc}</span> zł.`</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(rachunek); <span class="hljs-comment">// Wyświetli: Koszt zakupu: 21 zł.</span>
</code></pre>
</li>
<li>
<p><strong>Łatwe tworzenie tekstów wielolinijkowych:</strong>
Koniec z dodawaniem <code>n</code> do każdej linii! W szablonach stringów możesz po prostu nacisnąć Enter, a tekst zachowa formatowanie z nowymi liniami. Jest to szczególnie przydatne przy generowaniu fragmentów HTML bezpośrednio w JavaScript.</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// Stary sposób: brzydkie i niewygodne</span>
<span class="hljs-keyword">const</span> htmlStare =
  <span class="hljs-string">"&#x3C;div>\n  &#x3C;h1>Witaj!&#x3C;/h1>\n  &#x3C;p>To jest wielolinijkowy tekst.&#x3C;/p>\n&#x3C;/div>"</span>;

<span class="hljs-comment">// Nowy sposób: super czytelne!</span>
<span class="hljs-keyword">const</span> htmlNowe = <span class="hljs-string">`
  &#x3C;div>
    &#x3C;h1>Witaj!&#x3C;/h1>
    &#x3C;p>To jest wielolinijkowy tekst. I kolejna linia w tym samym akapicie.&#x3C;/p>
  &#x3C;/div>
`</span>;

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(htmlNowe);
</code></pre>
</li>
</ul>
<h3 id="dodatkowe-możliwości" class="scroll-mt-20 lg:scroll-mt-10"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#dodatkowe-możliwości">>>></a>Dodatkowe możliwości</h3>
<p>Szablony stringów wspierają także tzw. <strong>tagowane szablony</strong> (<code>tagged templates</code>), które pozwalają na zaawansowaną manipulację tekstem przed jego finalnym utworzeniem. Możesz zdefiniować funkcję ("tag"), która będzie przetwarzać części stringu i wartości zmiennych. Jest to bardziej zaawansowana funkcja, używana np. do tłumaczeń, walidacji, bezpiecznego generowania HTML (zapobieganie XSS) czy formatowania danych.</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// Przykład funkcji "tagującej"</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">upper</span>(<span class="hljs-params">strings, ...values</span>) {
  <span class="hljs-comment">// 'strings' to tablica tekstów, 'values' to tablica zmiennych</span>
  <span class="hljs-keyword">let</span> wynik = strings[<span class="hljs-number">0</span>];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &#x3C; values.<span class="hljs-property">length</span>; i++) {
    wynik += values[i].<span class="hljs-title function_">toUpperCase</span>() + strings[i + <span class="hljs-number">1</span>]; <span class="hljs-comment">// Zamienia zmienne na duże litery</span>
  }
  <span class="hljs-keyword">return</span> wynik;
}

<span class="hljs-keyword">const</span> imie = <span class="hljs-string">"Kasia"</span>;
<span class="hljs-keyword">const</span> wiek = <span class="hljs-number">20</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(upper<span class="hljs-string">`Cześć, <span class="hljs-subst">${imie}</span>! Masz <span class="hljs-subst">${wiek}</span> lat?`</span>); <span class="hljs-comment">// Wyświetli: Cześć, KASIA! Masz 20 lat?</span>
</code></pre>
<p>W tym przykładzie funkcja <code>upper</code> została "przypięta" do szablonu stringu i zmodyfikowała zmienną <code>imie</code> na wielkie litery.</p>
<hr>
<h2 id="destrukturyzacja-tablic-i-obiektów---wyciągnij-to-czego-potrzebujesz" class="scroll-mt-20 lg:scroll-mt-10"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#destrukturyzacja-tablic-i-obiektów---wyciągnij-to-czego-potrzebujesz">>></a>Destrukturyzacja tablic i obiektów - wyciągnij to, czego potrzebujesz</h2>
<p>Destrukturyzacja to potężna i bardzo często używana funkcja w nowoczesnym JavaScript. Pozwala na "rozpakowanie" wartości z tablic lub właściwości z obiektów do oddzielnych zmiennych w bardzo zwięzły i czytelny sposób. Upraszcza kod i czyni go bardziej deklaratywnym.</p>
<h3 id="destrukturyzacja-tablic" class="scroll-mt-20 lg:scroll-mt-10"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#destrukturyzacja-tablic">>>></a>Destrukturyzacja tablic</h3>
<p>Pozwala na szybkie przypisanie wartości z tablicy do zmiennych, bazując na ich pozycji.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> kolory = [<span class="hljs-string">"czerwony"</span>, <span class="hljs-string">"zielony"</span>, <span class="hljs-string">"niebieski"</span>];

<span class="hljs-comment">// Stary sposób:</span>
<span class="hljs-comment">// const kolor1 = kolory[0];</span>
<span class="hljs-comment">// const kolor2 = kolory[1];</span>

<span class="hljs-comment">// Nowy sposób z destrukturyzacją tablic:</span>
<span class="hljs-keyword">const</span> [pierwszyKolor, drugiKolor, trzeciKolor] = kolory;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pierwszyKolor); <span class="hljs-comment">// Wyświetli: czerwony</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(drugiKolor); <span class="hljs-comment">// Wyświetli: zielony</span>

<span class="hljs-comment">// Można pomijać niektóre elementy (używając przecinków):</span>
<span class="hljs-keyword">const</span> [a, , b] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]; <span class="hljs-comment">// Pomijamy drugi element (2)</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a, b); <span class="hljs-comment">// Wyświetli: 1 3</span>

<span class="hljs-comment">// Można przypisać wartości domyślne, jeśli element nie istnieje:</span>
<span class="hljs-keyword">const</span> [x, y, z = <span class="hljs-string">"domyślny"</span>] = [<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x, y, z); <span class="hljs-comment">// Wyświetli: A B domyślny</span>

<span class="hljs-comment">// Można zbierać pozostałe elementy do nowej tablicy (rest operator - patrz dalej):</span>
<span class="hljs-keyword">const</span> [pierwszy, ...resztaKolorow] = kolory;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pierwszy); <span class="hljs-comment">// Wyświetli: czerwony</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(resztaKolorow); <span class="hljs-comment">// Wyświetli: ["zielony", "niebieski"]</span>
</code></pre>
<h3 id="destrukturyzacja-obiektów" class="scroll-mt-20 lg:scroll-mt-10"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#destrukturyzacja-obiektów">>>></a>Destrukturyzacja obiektów</h3>
<p>Pozwala na przypisanie wartości z obiektu do zmiennych na podstawie nazw ich <strong>kluczy (właściwości)</strong>. Kolejność nie ma znaczenia, liczy się nazwa klucza.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> samochod = { <span class="hljs-attr">marka</span>: <span class="hljs-string">"Ford"</span>, <span class="hljs-attr">model</span>: <span class="hljs-string">"Focus"</span>, <span class="hljs-attr">rok</span>: <span class="hljs-number">2018</span> };

<span class="hljs-comment">// Stary sposób:</span>
<span class="hljs-comment">// const markaSamochodu = samochod.marka;</span>
<span class="hljs-comment">// const modelSamochodu = samochod.model;</span>

<span class="hljs-comment">// Nowy sposób z destrukturyzacją obiektów:</span>
<span class="hljs-keyword">const</span> { marka, model } = samochod;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(marka); <span class="hljs-comment">// Wyświetli: Ford</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(model); <span class="hljs-comment">// Wyświetli: Focus</span>

<span class="hljs-comment">// Można przypisać wartości domyślne, jeśli właściwość nie istnieje:</span>
<span class="hljs-keyword">const</span> { <span class="hljs-attr">marka</span>: m, kolor = <span class="hljs-string">"czarny"</span> } = samochod; <span class="hljs-comment">// 'kolor' nie istnieje w obiekcie 'samochod'</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(m, kolor); <span class="hljs-comment">// Wyświetli: Ford czarny</span>

<span class="hljs-comment">// Można zmienić nazwę zmiennej, do której przypisujemy wartość:</span>
<span class="hljs-keyword">const</span> { <span class="hljs-attr">marka</span>: nazwaMarki, <span class="hljs-attr">model</span>: typModelu } = samochod;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(nazwaMarki, typModelu); <span class="hljs-comment">// Wyświetli: Ford Focus</span>

<span class="hljs-comment">// Można też zbierać pozostałe właściwości do nowego obiektu (rest operator - patrz dalej):</span>
<span class="hljs-keyword">const</span> { rok, ...resztaSamochodu } = samochod;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(rok); <span class="hljs-comment">// Wyświetli: 2018</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(resztaSamochodu); <span class="hljs-comment">// Wyświetli: { marka: "Ford", model: "Focus" }</span>
</code></pre>
<p>Destrukturyzacja jest szczególnie przydatna w funkcjach, gdy chcesz łatwo wyciągnąć konkretne dane z obiektów konfiguracyjnych lub z wyników API.</p>
<hr>
<h2 id="spread-i-rest-operator----elastyczność-w-manipulacji-danymi" class="scroll-mt-20 lg:scroll-mt-10"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#spread-i-rest-operator----elastyczność-w-manipulacji-danymi">>></a>Spread i Rest Operator (<code>...</code>) - elastyczność w manipulacji danymi</h2>
<p>Operator <code>...</code> (trzy kropki) jest jednym z najbardziej uniwersalnych i potężnych narzędzi w nowoczesnym JavaScript. Nazywany jest <strong>operatorem spread</strong> lub <strong>operatorem rest</strong>, w zależności od kontekstu, w jakim jest używany.</p>
<h3 id="spread-operator-operator-rozproszenia" class="scroll-mt-20 lg:scroll-mt-10"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#spread-operator-operator-rozproszenia">>>></a>Spread Operator (operator rozproszenia)</h3>
<p>Gdy używasz <code>...</code> do <strong>rozbicia</strong> elementów tablicy lub właściwości obiektu na pojedyncze elementy, mówimy o <strong>operatorze spread</strong>. Jest to jak "rozłożenie" zawartości kolekcji. 🌐</p>
<p><strong>Zastosowania Spread Operatora:</strong></p>
<ul>
<li>
<p><strong>Kopiowanie i łączenie tablic:</strong> Tworzenie płytkich kopii tablic lub łączenie ich bez modyfikowania oryginalnych.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> cyfry = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-keyword">const</span> noweCyfry = [...cyfry, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]; <span class="hljs-comment">// Rozwija [1, 2, 3] do 1, 2, 3, a potem dodaje 4, 5</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(noweCyfry); <span class="hljs-comment">// Wyświetli: [1, 2, 3, 4, 5]</span>

<span class="hljs-keyword">const</span> tablica1 = [<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>];
<span class="hljs-keyword">const</span> tablica2 = [<span class="hljs-string">"c"</span>, <span class="hljs-string">"d"</span>];
<span class="hljs-keyword">const</span> polaczoneTablice = [...tablica1, ...tablica2];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(polaczoneTablice); <span class="hljs-comment">// Wyświetli: ["a", "b", "c", "d"]</span>
</code></pre>
</li>
<li>
<p><strong>Kopiowanie i łączenie obiektów:</strong> Podobnie jak z tablicami, możesz tworzyć kopie obiektów i łączyć ich właściwości.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> osoba = { <span class="hljs-attr">imie</span>: <span class="hljs-string">"Anna"</span>, <span class="hljs-attr">wiek</span>: <span class="hljs-number">28</span> };
<span class="hljs-keyword">const</span> osobaZZawodem = { ...osoba, <span class="hljs-attr">zawod</span>: <span class="hljs-string">"Programista"</span> };
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(osobaZZawodem); <span class="hljs-comment">// Wyświetli: { imie: "Anna", wiek: 28, zawod: "Programista" }</span>

<span class="hljs-keyword">const</span> daneKontaktowe = { <span class="hljs-attr">email</span>: <span class="hljs-string">"a@example.com"</span>, <span class="hljs-attr">telefon</span>: <span class="hljs-string">"123-456-789"</span> };
<span class="hljs-keyword">const</span> pelneDane = { ...osoba, ...daneKontaktowe };
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pelneDane); <span class="hljs-comment">// Wyświetli: { imie: "Anna", wiek: 28, email: "a@example.com", telefon: "123-456-789" }</span>
</code></pre>
<p>Jeśli klucze się powtarzają, ostatnia wartość nadpisuje poprzednią.</p>
</li>
<li>
<p><strong>Przekazywanie argumentów funkcji:</strong> Możesz rozwijać tablicę jako argumenty funkcji.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sumuj</span>(<span class="hljs-params">a, b, c</span>) {
  <span class="hljs-keyword">return</span> a + b + c;
}
<span class="hljs-keyword">const</span> liczby = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sumuj</span>(...liczby)); <span class="hljs-comment">// Rozwija [10, 20, 30] do sumuj(10, 20, 30), wyświetli: 60</span>
</code></pre>
</li>
</ul>
<h3 id="rest-operator-operator-reszty" class="scroll-mt-20 lg:scroll-mt-10"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#rest-operator-operator-reszty">>>></a>Rest Operator (operator reszty)</h3>
<p>Gdy używasz <code>...</code> do <strong>zbierania</strong> wielu elementów w jedną tablicę (lub właściwości w obiekt), mówimy o <strong>operatorze rest</strong>. Jest to jak "zbieranie" luźnych elementów w jedną kolekcję. 🧺</p>
<p><strong>Zastosowania Rest Operatora:</strong></p>
<ul>
<li>
<p><strong>Zbieranie argumentów funkcji:</strong> Pozwala funkcji przyjmować nieokreśloną liczbę argumentów i traktować je jako tablicę.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">suma</span>(<span class="hljs-params">...liczby</span>) {
  <span class="hljs-comment">// 'liczby' zbiera wszystkie przekazane argumenty w tablicę</span>
  <span class="hljs-keyword">return</span> liczby.<span class="hljs-title function_">reduce</span>(
    <span class="hljs-function">(<span class="hljs-params">akumulator, aktualnaLiczba</span>) =></span> akumulator + aktualnaLiczba,
    <span class="hljs-number">0</span>
  );
}
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">suma</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">// Wyświetli: 6</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">suma</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>)); <span class="hljs-comment">// Wyświetli: 100</span>
</code></pre>
</li>
<li>
<p><strong>W destrukturyzacji (jak widzieliśmy wcześniej):</strong> Zbieranie pozostałych elementów do nowej tablicy lub obiektu.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> [pierwszy, drugi, ...resztaTablicy] = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pierwszy); <span class="hljs-comment">// Wyświetli: 10</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(drugi); <span class="hljs-comment">// Wyświetli: 20</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(resztaTablicy); <span class="hljs-comment">// Wyświetli: [30, 40, 50]</span>

<span class="hljs-keyword">const</span> { imie, ...resztaOsoby } = {
  <span class="hljs-attr">imie</span>: <span class="hljs-string">"Ola"</span>,
  <span class="hljs-attr">wiek</span>: <span class="hljs-number">25</span>,
  <span class="hljs-attr">miasto</span>: <span class="hljs-string">"Warszawa"</span>,
};
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(imie); <span class="hljs-comment">// Wyświetli: Ola</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(resztaOsoby); <span class="hljs-comment">// Wyświetli: { wiek: 25, miasto: "Warszawa" }</span>
</code></pre>
</li>
</ul>
<p>Zarówno spread, jak i rest operator są niezwykle przydatne i sprawiają, że kod jest znacznie bardziej zwięzły i czytelny, szczególnie podczas pracy z tablicami i obiektami.</p>
<hr>
<h2 id="promise-api-i-obsługa-asynchroniczności---opowiadaj-historie-o-przyszłości" class="scroll-mt-20 lg:scroll-mt-10"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#promise-api-i-obsługa-asynchroniczności---opowiadaj-historie-o-przyszłości">>></a>Promise API i obsługa asynchroniczności - opowiadaj historie o przyszłości</h2>
<p>JavaScript jest językiem <strong>jednowątkowym</strong>, co oznacza, że może wykonywać tylko jedną operację w danym momencie. Jednak wiele operacji, takich jak pobieranie danych z internetu, odczyt plików, czy operacje na bazie danych, trwa pewien czas. Gdyby JavaScript musiał czekać na ich zakończenie, strona internetowa by się "zawiesiła" (nie reagowałaby na kliknięcia, przewijanie itp.).</p>
<p>Tutaj wkracza <strong>asynchroniczność</strong>. Pozwala ona na rozpoczęcie operacji, a następnie przejście do kolejnych zadań, nie czekając na zakończenie tej pierwszej. Kiedy asynchroniczna operacja się zakończy, JavaScript wróci do niej i wykona dalsze kroki.</p>
<p>Starszym sposobem obsługi asynchroniczności były <strong>callbacki</strong> (funkcje zwrotne), które jednak często prowadziły do tzw. "callback hell" (piekła callbacków) - zagnieżdżonego, trudnego do czytania i utrzymania kodu.</p>
<h3 id="czym-jest-promise" class="scroll-mt-20 lg:scroll-mt-10"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#czym-jest-promise">>>></a>Czym jest Promise?</h3>
<p><strong>Promise (Obietnica)</strong> to obiekt w JavaScript, który reprezentuje ostateczne zakończenie (lub niepowodzenie) operacji asynchronicznej. Możesz myśleć o Promise jako o "przyszłej wartości". Składasz obietnicę, że w przyszłości otrzymasz wynik - albo sukces, albo błąd. 📦</p>
<p>Promise może znajdować się w jednym z trzech stanów:</p>
<ol>
<li><strong><code>pending</code> (oczekujący)</strong>: Początkowy stan; ani spełniony, ani odrzucony. Operacja asynchroniczna nadal trwa.</li>
<li><strong><code>fulfilled</code> (spełniony)</strong>: Operacja asynchroniczna zakończyła się sukcesem i zwróciła wartość.</li>
<li><strong><code>rejected</code> (odrzucony)</strong>: Operacja asynchroniczna zakończyła się błędem.</li>
</ol>
<p>Możesz "podpiąć" funkcje, które zostaną wywołane, gdy Promise zmieni swój stan:</p>
<ul>
<li><strong><code>.then()</code></strong>: Wywoływany, gdy Promise zostanie <code>fulfilled</code> (operacja zakończy się sukcesem). Otrzymuje wartość zwróconą przez Promise.</li>
<li><strong><code>.catch()</code></strong>: Wywoływany, gdy Promise zostanie <code>rejected</code> (wystąpi błąd). Otrzymuje obiekt błędu.</li>
<li><strong><code>.finally()</code></strong>: Wywoływany zawsze, niezależnie od tego, czy Promise zakończył się sukcesem, czy błędem. Idealny do czyszczenia zasobów.</li>
</ul>
<p><strong>Przykład tworzenia i używania Promise:</strong></p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> obietnica = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> {
  <span class="hljs-comment">// Symulujemy operację asynchroniczną (np. pobieranie danych)</span>
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-keyword">const</span> sukces = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() > <span class="hljs-number">0.5</span>; <span class="hljs-comment">// Losowo decydujemy o sukcesie lub błędzie</span>

    <span class="hljs-keyword">if</span> (sukces) {
      <span class="hljs-title function_">resolve</span>(<span class="hljs-string">"Dane pobrane pomyślnie!"</span>); <span class="hljs-comment">// Jeśli sukces, wywołujemy resolve z wynikiem</span>
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"Nie udało się pobrać danych."</span>)); <span class="hljs-comment">// Jeśli błąd, wywołujemy reject z błędem</span>
    }
  }, <span class="hljs-number">2000</span>); <span class="hljs-comment">// Operacja trwa 2 sekundy</span>
});

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Rozpoczęto operację..."</span>);

obietnica
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">wiadomosc</span>) =></span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"SUKCES:"</span>, wiadomosc); <span class="hljs-comment">// Wykona się, jeśli obietnica się spełni</span>
  })
  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">blad</span>) =></span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"BŁĄD:"</span>, blad.<span class="hljs-property">message</span>); <span class="hljs-comment">// Wykona się, jeśli obietnica zostanie odrzucona</span>
  })
  .<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Operacja zakończona (niezależnie od wyniku)."</span>); <span class="hljs-comment">// Wykona się zawsze</span>
  });

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Kod po obietnicy nadal się wykonuje..."</span>); <span class="hljs-comment">// Pokazuje asynchroniczność</span>
</code></pre>
<h3 id="łańcuchy-promise-promise-chaining" class="scroll-mt-20 lg:scroll-mt-10"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#łańcuchy-promise-promise-chaining">>>></a>Łańcuchy Promise (<code>Promise Chaining</code>)</h3>
<p>Jedną z największych zalet Promise jest możliwość łączenia wielu operacji asynchronicznych w jeden czytelny "łańcuch". Każdy <code>.then()</code> zwraca nowy Promise, co pozwala na kolejne <code>.then()</code> wywołane po sobie. Jest to idealne, gdy jedna operacja asynchroniczna zależy od wyniku poprzedniej.</p>
<p><strong>Przykład łańcucha Promise (pobieranie danych z API):</strong></p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// fetch() to wbudowana funkcja JS, która zwraca Promise</span>
<span class="hljs-title function_">fetch</span>(<span class="hljs-string">"https://jsonplaceholder.typicode.com/users/1"</span>) <span class="hljs-comment">// Pobierz dane użytkownika o ID 1</span>
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">response</span>) =></span> {
    <span class="hljs-comment">// Pierwsze .then: sprawdź, czy odpowiedź jest OK i sparsuj ją jako JSON</span>
    <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`Błąd HTTP! Status: <span class="hljs-subst">${response.status}</span>`</span>);
    }
    <span class="hljs-keyword">return</span> response.<span class="hljs-title function_">json</span>(); <span class="hljs-comment">// Zwróć kolejny Promise z danymi JSON</span>
  })
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">user</span>) =></span> {
    <span class="hljs-comment">// Drugie .then: otrzymaj sparsowane dane użytkownika</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Pobrany użytkownik:"</span>, user.<span class="hljs-property">name</span>, user.<span class="hljs-property">email</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">fetch</span>(
      <span class="hljs-string">`https://jsonplaceholder.typicode.com/posts?userId=<span class="hljs-subst">${user.id}</span>`</span>
    ); <span class="hljs-comment">// Pobierz posty tego użytkownika</span>
  })
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">response</span>) =></span> {
    <span class="hljs-comment">// Trzecie .then: sprawdź odpowiedź i sparsuj posty</span>
    <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`Błąd HTTP! Status: <span class="hljs-subst">${response.status}</span>`</span>);
    }
    <span class="hljs-keyword">return</span> response.<span class="hljs-title function_">json</span>();
  })
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">posts</span>) =></span> {
    <span class="hljs-comment">// Czwarte .then: otrzymaj posty</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Liczba postów użytkownika:"</span>, posts.<span class="hljs-property">length</span>);
  })
  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =></span> {
    <span class="hljs-comment">// .catch: Obsłuż każdy błąd, który wystąpił na dowolnym etapie łańcucha</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"Wystąpił błąd w łańcuchu Promise:"</span>, error);
  })
  .<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Pobieranie danych zakończone."</span>);
  });
</code></pre>
<p>Promise to podstawa nowoczesnego JS w obsłudze asynchroniczności, a kolejny rozdział pokaże Ci, jak jeszcze bardziej uprościć ich użycie.</p>
<hr>
<h2 id="asyncawait---nowoczesna-obsługa-kodu-asynchronicznego---pisz-asynchronicznie-myśl-synchronicznie" class="scroll-mt-20 lg:scroll-mt-10"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#asyncawait---nowoczesna-obsługa-kodu-asynchronicznego---pisz-asynchronicznie-myśl-synchronicznie">>></a>Async/await - nowoczesna obsługa kodu asynchronicznego - pisz asynchronicznie, myśl synchronicznie</h2>
<p>Mimo że Promise są ogromnym krokiem naprzód w porównaniu do callbacków, kod z długimi łańcuchami <code>.then().then().catch()</code> może wciąż być trudny do czytania. Standard ES2017 wprowadził słowa kluczowe <strong><code>async</code></strong> i <strong><code>await</code></strong>, które pozwalają pisać kod asynchroniczny w sposób, który wygląda i zachowuje się niemal identycznie jak kod synchroniczny, jednocześnie zachowując asynchroniczną naturę. To game changer! 🎮</p>
<h3 id="uproszczenie-pracy-z-promise" class="scroll-mt-20 lg:scroll-mt-10"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#uproszczenie-pracy-z-promise">>>></a>Uproszczenie pracy z Promise</h3>
<ul>
<li><strong><code>async</code></strong>: Musisz oznaczyć funkcję słowem kluczowym <code>async</code>, aby móc używać w niej <code>await</code>. Funkcja <code>async</code> <strong>zawsze zwraca Promise</strong>, nawet jeśli zwrócisz w niej zwykłą wartość - JavaScript automatycznie opakuje ją w Promise.</li>
<li><strong><code>await</code></strong>: Słowo kluczowe <code>await</code> może być użyte <strong>tylko wewnątrz funkcji <code>async</code></strong>. Powoduje ono, że wykonanie funkcji <code>async</code> zostaje <strong>wstrzymane</strong>, dopóki Promise, na który czeka <code>await</code>, nie zostanie <strong>spełniony (fulfilled)</strong>. Kiedy Promise się spełni, <code>await</code> "rozpakowuje" jego wartość i przypisuje ją do zmiennej. Jeśli Promise zostanie odrzucony (rejected), <code>await</code> "wyrzuci" błąd, który możesz obsłużyć za pomocą <code>try...catch</code>.</li>
</ul>
<p><strong>Przykład użycia <code>async/await</code> (porównaj z przykładem z Promise Chaining):</strong></p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">pobierzDaneUzytkownikaIPosty</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Rozpoczynam pobieranie danych..."</span>);

    <span class="hljs-comment">// Krok 1: Pobierz dane użytkownika</span>
    <span class="hljs-keyword">const</span> userResponse = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(
      <span class="hljs-string">"https://jsonplaceholder.typicode.com/users/1"</span>
    );
    <span class="hljs-keyword">if</span> (!userResponse.<span class="hljs-property">ok</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(
        <span class="hljs-string">`Błąd HTTP przy pobieraniu użytkownika! Status: <span class="hljs-subst">${userResponse.status}</span>`</span>
      );
    }
    <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> userResponse.<span class="hljs-title function_">json</span>(); <span class="hljs-comment">// Poczekaj na parsowanie JSON</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Pobrany użytkownik:"</span>, user.<span class="hljs-property">name</span>, user.<span class="hljs-property">email</span>);

    <span class="hljs-comment">// Krok 2: Pobierz posty tego użytkownika</span>
    <span class="hljs-keyword">const</span> postsResponse = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(
      <span class="hljs-string">`https://jsonplaceholder.typicode.com/posts?userId=<span class="hljs-subst">${user.id}</span>`</span>
    );
    <span class="hljs-keyword">if</span> (!postsResponse.<span class="hljs-property">ok</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(
        <span class="hljs-string">`Błąd HTTP przy pobieraniu postów! Status: <span class="hljs-subst">${postsResponse.status}</span>`</span>
      );
    }
    <span class="hljs-keyword">const</span> posts = <span class="hljs-keyword">await</span> postsResponse.<span class="hljs-title function_">json</span>(); <span class="hljs-comment">// Poczekaj na parsowanie JSON</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Liczba postów użytkownika:"</span>, posts.<span class="hljs-property">length</span>);

    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Wszystkie dane zostały pobrane pomyślnie."</span>);
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-comment">// Obsługa każdego błędu, który wystąpił na dowolnym etapie</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"Wystąpił błąd w funkcji async:"</span>, error.<span class="hljs-property">message</span>);
  } <span class="hljs-keyword">finally</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Operacja pobierania danych zakończona."</span>);
  }
}

<span class="hljs-comment">// Wywołanie funkcji async</span>
<span class="hljs-title function_">pobierzDaneUzytkownikaIPosty</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Kod poza funkcją async nadal się wykonuje..."</span>); <span class="hljs-comment">// Pokazuje asynchroniczność</span>
</code></pre>
<p>Widzisz, jak kod stał się znacznie bardziej liniowy i czytelny? Wygląda to prawie jak tradycyjny kod synchroniczny, mimo że w tle nadal działają Promise i cała magia asynchroniczności.</p>
<h3 id="zwracanie-wartości-i-obsługa-błędów" class="scroll-mt-20 lg:scroll-mt-10"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#zwracanie-wartości-i-obsługa-błędów">>>></a>Zwracanie wartości i obsługa błędów</h3>
<ul>
<li>
<p><strong>Zwracanie wartości z funkcji <code>async</code></strong>:
Jeśli funkcja <code>async</code> zwraca jakąś wartość, ta wartość jest automatycznie opakowywana w Promise, który zostanie spełniony z tą wartością.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">zwrocLiczbe</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// Możesz też użyć await, np. await Promise.resolve(42);</span>
  <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;
}
<span class="hljs-title function_">zwrocLiczbe</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">val</span>) =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(val)); <span class="hljs-comment">// Wyświetli: 42</span>
</code></pre>
</li>
<li>
<p><strong>Obsługa błędów z <code>try...catch</code></strong>:
Największą zaletą <code>async/await</code> jest to, że pozwala na używanie standardowych bloków <code>try...catch</code> do obsługi błędów w kodzie asynchronicznym. Jeśli Promise, na który czeka <code>await</code>, zostanie odrzucony (rejected), <code>await</code> "rzuci" błąd, który zostanie przechwycony przez blok <code>catch</code>.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">symulujBlad</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> {
      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"Coś poszło nie tak!"</span>)), <span class="hljs-number">1000</span>);
    });
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result); <span class="hljs-comment">// To się nie wykona</span>
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"Złapano błąd:"</span>, error.<span class="hljs-property">message</span>); <span class="hljs-comment">// Wyświetli: Złapano błąd: Coś poszło nie tak!</span>
  }
}
<span class="hljs-title function_">symulujBlad</span>();
</code></pre>
</li>
</ul>
<p><code>async/await</code> to obecnie <strong>najczęściej rekomendowany</strong> sposób pracy z asynchronicznością w JavaScript, ponieważ znacząco poprawia czytelność i łatwość utrzymania kodu, sprawiając, że złożone operacje asynchroniczne stają się bardziej przejrzyste.</p>
<hr>
<h2 id="zadania-do-wykonania-sprawdź-swoją-wiedzę" class="scroll-mt-20 lg:scroll-mt-10"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#zadania-do-wykonania-sprawdź-swoją-wiedzę">>></a>Zadania do wykonania: Sprawdź swoją wiedzę!</h2>
<p>Czas na praktykę! Rozwiąż te zadania, aby utrwalić to, czego się nauczyłeś/aś. Po każdym zadaniu możesz rozwinąć sekcję <code>Pokaż rozwiązanie</code>, aby sprawdzić swój kod. Powodzenia! 💪</p>
<h3 id="zadanie-1" class="scroll-mt-20 lg:scroll-mt-10"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#zadanie-1">>>></a>Zadanie 1</h3>
<p>Napisz <strong>funkcję strzałkową</strong>, która przyjmuje dowolną liczbę argumentów numerycznych i zwraca ich sumę. Użyj <strong>rest operatora</strong> do zebrania argumentów.</p>
<details>
<summary>
<span>Pokaż rozwiązanie</span>
</summary>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">sumaWszystkichLiczb</span> = (<span class="hljs-params">...liczby</span>) => {
  <span class="hljs-keyword">return</span> liczby.<span class="hljs-title function_">reduce</span>(
    <span class="hljs-function">(<span class="hljs-params">akumulator, aktualnaLiczba</span>) =></span> akumulator + aktualnaLiczba,
    <span class="hljs-number">0</span>
  );
};

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sumaWszystkichLiczb</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">// Oczekiwany wynik: 6</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sumaWszystkichLiczb</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>)); <span class="hljs-comment">// Oczekiwany wynik: 100</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sumaWszystkichLiczb</span>()); <span class="hljs-comment">// Oczekiwany wynik: 0</span>
</code></pre>
</details>
<hr>
<h3 id="zadanie-2" class="scroll-mt-20 lg:scroll-mt-10"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#zadanie-2">>>></a>Zadanie 2</h3>
<p>Utwórz obiekt reprezentujący produkt z kluczami: <code>nazwa</code>, <code>cena</code>, <code>dostepny</code>. Następnie użyj <strong>destrukturyzacji obiektu</strong>, aby wyodrębnić te wartości do osobnych zmiennych i wyświetlić je w konsoli. Dodaj również zmienną <code>producent</code> z wartością domyślną "Nieznany", na wypadek gdyby nie było jej w obiekcie.</p>
<details>
<summary>
<span>Pokaż rozwiązanie</span>
</summary>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> produkt = { <span class="hljs-attr">nazwa</span>: <span class="hljs-string">"Książka JS"</span>, <span class="hljs-attr">cena</span>: <span class="hljs-number">49.99</span>, <span class="hljs-attr">dostepny</span>: <span class="hljs-literal">true</span> };

<span class="hljs-keyword">const</span> { nazwa, cena, dostepny, producent = <span class="hljs-string">"Nieznany"</span> } = produkt;

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Nazwa: <span class="hljs-subst">${nazwa}</span>`</span>); <span class="hljs-comment">// Oczekiwany wynik: Nazwa: Książka JS</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Cena: <span class="hljs-subst">${cena}</span> zł`</span>); <span class="hljs-comment">// Oczekiwany wynik: Cena: 49.99 zł</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Dostępny: <span class="hljs-subst">${dostepny}</span>`</span>); <span class="hljs-comment">// Oczekiwany wynik: Dostępny: true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Producent: <span class="hljs-subst">${producent}</span>`</span>); <span class="hljs-comment">// Oczekiwany wynik: Producent: Nieznany</span>
</code></pre>
</details>
<hr>
<h3 id="zadanie-3" class="scroll-mt-20 lg:scroll-mt-10"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#zadanie-3">>>></a>Zadanie 3</h3>
<p>Stwórz tablicę ulubionych filmów. Następnie użyj <strong>operatora spread</strong> do utworzenia nowej tablicy, która będzie zawierać wszystkie te filmy plus dwa dodatkowe filmy na końcu. Wyświetl nową tablicę w konsoli.</p>
<details>
<summary>
<span>Pokaż rozwiązanie</span>
</summary>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> ulubioneFilmy = [<span class="hljs-string">"Incepcja"</span>, <span class="hljs-string">"Matrix"</span>, <span class="hljs-string">"Interstellar"</span>];

<span class="hljs-keyword">const</span> nowaListaFilmow = [...ulubioneFilmy, <span class="hljs-string">"Pulp Fiction"</span>, <span class="hljs-string">"Forrest Gump"</span>];

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(nowaListaFilmow);
<span class="hljs-comment">// Oczekiwany wynik: ["Incepcja", "Matrix", "Interstellar", "Pulp Fiction", "Forrest Gump"]</span>
</code></pre>
</details>
<hr>
<h3 id="zadanie-4" class="scroll-mt-20 lg:scroll-mt-10"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#zadanie-4">>>></a>Zadanie 4</h3>
<p>Napisz <strong>funkcję asynchroniczną</strong> o nazwie <code>pobierzWiadomosc</code>, która symuluje pobieranie wiadomości z serwera. Funkcja powinna używać <code>setTimeout</code>, aby po 3 sekundach zwrócić tekst "Wiadomość pobrana!". Użyj <code>async/await</code> do wywołania tej funkcji i wyświetlenia jej wyniku w konsoli. Dodaj również blok <code>try...catch</code> do obsługi potencjalnych błędów.</p>
<details>
<summary>
<span>Pokaż rozwiązanie</span>
</summary>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// Funkcja symulująca pobieranie danych (zwraca Promise)</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">pobierzWiadomoscAPI</span> = (<span class="hljs-params"></span>) => {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> {
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> {
      <span class="hljs-comment">// Możesz zmienić to na reject, aby przetestować obsługę błędów</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() > <span class="hljs-number">0.1</span>) {
        <span class="hljs-comment">// 90% szans na sukces, 10% na błąd</span>
        <span class="hljs-title function_">resolve</span>(<span class="hljs-string">"Wiadomość pobrana pomyślnie!"</span>);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"Błąd podczas pobierania wiadomości!"</span>));
      }
    }, <span class="hljs-number">3000</span>); <span class="hljs-comment">// Symulujemy 3 sekundy oczekiwania</span>
  });
};

<span class="hljs-comment">// Funkcja asynchroniczna używająca async/await</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">pobierzWiadomosc</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Rozpoczynam pobieranie wiadomości..."</span>);
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> wiadomosc = <span class="hljs-keyword">await</span> <span class="hljs-title function_">pobierzWiadomoscAPI</span>(); <span class="hljs-comment">// Czekaj, aż Promise się spełni</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Sukces:"</span>, wiadomosc);
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"Wystąpił błąd:"</span>, error.<span class="hljs-property">message</span>); <span class="hljs-comment">// Złap i wyświetl błąd</span>
  } <span class="hljs-keyword">finally</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Zakończono próbę pobierania wiadomości."</span>);
  }
}

<span class="hljs-comment">// Wywołaj funkcję asynchroniczną</span>
<span class="hljs-title function_">pobierzWiadomosc</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(
  <span class="hljs-string">"Ten tekst wyświetli się natychmiast po uruchomieniu programu, zanim wiadomość zostanie pobrana."</span>
);
</code></pre>
</details>
<hr>
<p>Gratulacje! 🎉 Dotarłeś/aś do końca kursu wprowadzającego w nowoczesny JavaScript. Masz teraz solidne podstawy do dalszego rozwoju. Pamiętaj, że kluczem jest praktyka - im więcej będziesz kodować, tym lepiej zrozumiesz te koncepcje.</p>
<p>Co chciałbyś/chciałabyś zgłębić dalej? Może:</p>
<ul>
<li><strong>Moduły ES6</strong> (import/export)?</li>
<li><strong>Klasy</strong> w JavaScript (obiektowość)?</li>
<li><strong>Metody tablicowe</strong> (map, filter, reduce)?</li>
<li>Głębsze nurkowanie w <strong>asynchroniczność</strong> i Web API?</li>
</ul>
<p>Daj znać! 😊</p></article><div class="container prose"><h2>Quiz: Podstawy nowoczesnego JavaScript</h2><div><p class="font-bold mb-0!">Pytanie <!-- -->1<!-- --> z <!-- -->5</p><div class="prose-p:mt-2"><p>Jaką główną różnicę między <code>let</code> a <code>var</code> podkreśla się w nowoczesnym JavaScript?</p></div><div class="grid grid-flow-row gap-3"><button data-slot="button" class="button button--variant-outline button--size-sm w-full text-left inline-flex justify-start transition-none text-wrap! min-h-min! py-1.5 cursor-pointer">`var` nie istnieje w nowoczesnym JS</button><button data-slot="button" class="button button--variant-outline button--size-sm w-full text-left inline-flex justify-start transition-none text-wrap! min-h-min! py-1.5 cursor-pointer">`let` nie pozwala na przyjmowanie wartości domyślnej</button><button data-slot="button" class="button button--variant-outline button--size-sm w-full text-left inline-flex justify-start transition-none text-wrap! min-h-min! py-1.5 cursor-pointer">Obie są identyczne</button><button data-slot="button" class="button button--variant-outline button--size-sm w-full text-left inline-flex justify-start transition-none text-wrap! min-h-min! py-1.5 cursor-pointer">Zakres blokowy (`block scope`) w `let`</button></div></div></div><div class="container"><p class="button button--variant-secondary button--size-lg w-full p-10 text-wrap flex-wrap h-auto text-center gap-y-4 text-wrap!" data-slot="button">Widzisz jakiś błąd, bądź literówkę? Chcesz coś poprawić?<a href="https://github.com/jakubszpil/jakubszpil.github.io/edit/main/app/content/courses/nowoczesny-javascript.md" target="_blank" rel="noreferrer" data-slot="button" class="button button--variant-link button--size-default">✏️ Przejdź do edycji tego pliku</a></p></div></main><footer class="prose max-w-full border-t"><div class="container flex items-center gap-3 justify-start flex-wrap-reverse lg:justify-between"><p class="xl:text-sm">© <!-- -->2025<a data-slot="button" class="button button--variant-link button--size-sm" href="/" data-discover="true">jakubszpil</a></p><nav class="flex items-center flex-wrap -ml-3"><a data-slot="button" class="button button--variant-link button--size-sm" href="/" data-discover="true">🏠 Strona główna</a><a data-slot="button" class="button button--variant-link button--size-sm" href="/blog" data-discover="true">📝 Blog</a><a data-slot="button" class="button button--variant-link button--size-sm" href="/learning" data-discover="true">🏫 Learning</a><a data-slot="button" class="button button--variant-link button--size-sm" href="/portfolio" data-discover="true">🛠️ Portfolio</a><a data-slot="button" class="button button--variant-link button--size-sm" href="/me" data-discover="true">🙋‍♂️ O mnie</a><a data-slot="button" class="button button--variant-link button--size-sm" href="/search" data-discover="true">🔍 Szukaj</a><a data-slot="button" class="button button--variant-link button--size-sm" href="/handbook" data-discover="true">📋 Handbook</a></nav></div></footer><script>((storageKey2, restoreKey) => {
    if (!window.history.state || !window.history.state.key) {
      let key = Math.random().toString(32).slice(2);
      window.history.replaceState({ key }, "");
    }
    try {
      let positions = JSON.parse(sessionStorage.getItem(storageKey2) || "{}");
      let storedY = positions[restoreKey || window.history.state.key];
      if (typeof storedY === "number") {
        window.scrollTo(0, storedY);
      }
    } catch (error) {
      console.error(error);
      sessionStorage.removeItem(storageKey2);
    }
  })("react-router-scroll-positions", "/learning/nowoczesny-javascript/.default")</script><script>window.__reactRouterContext = {"basename":"/","future":{"v8_middleware":false,"unstable_optimizeDeps":true,"unstable_splitRouteModules":true,"unstable_subResourceIntegrity":false,"unstable_viteEnvironmentApi":true},"routeDiscovery":{"mode":"initial"},"ssr":false,"isSpaMode":false};window.__reactRouterContext.stream = new ReadableStream({start(controller){window.__reactRouterContext.streamController = controller;}}).pipeThrough(new TextEncoderStream());</script><script type="module" async="">import "/assets/manifest-1770ae74.js";
import * as route0 from "/assets/root-B4SihuEH.js";
import * as route1 from "/assets/layout-DYpV2se7.js";
import * as route2 from "/assets/course-details-DLJ6fZBl.js";
  
  window.__reactRouterRouteModules = {"root":route0,"routes/layout":route1,"course-details":route2};

import("/assets/entry.client-D07Jc1yP.js");</script><!--$?--><template id="B:0"></template><!--/$--><script id="_R_">requestAnimationFrame(function(){$RT=performance.now()});</script><div hidden id="S:0"><script>window.__reactRouterContext.streamController.enqueue("[{\"_1\":2,\"_7\":-5,\"_8\":-5},\"loaderData\",{\"_3\":4},\"course-details\",{\"_5\":6},\"v\",\"㞂⁆⁜⁊੠㬸ᧀ蘎䀈໩腈ಠദ̘נ➀㘂婠胶\\uda31䨊循ƺꁩ栀瀂衒偁큈톘ŘꙒ뀦―Ö든ִ찠挀倞準ꨒ㭄ٸ᧍牥쎛✧ᒀ଄経ཆ搛์\\u0013䙌儖ş⃔棊Ы娊฀챺娄儸䭇䩬泿ბ匄岂ꊤ兦䨀耺䰀甲婀偀㌀坌パ呑ₜ깞縡ㅌ牴고렖樾魀⅀ቬጛ⣲吕滒٦㡌3㺄ᵒ㕜ፔ氻⎓\\uda0f₸石茿缭鲀撡딺ꉊᆇ䟐ጡ芌̓闢ࡢᶰꡀྠ㟅䏧㧁ꢆ䐄㓢썣ₐ晘鲚梣፬찀ᑀ考恹ㆰ뢖蒄Ԓ老둀⩹㈖鸤鍃憼鶩鴟둃♟ଊ␑탊䤅\\udaa8偃Ӕ₃むº鉋搈刭曢ᭈฃ 　᤽\\u0016-㞵逘̳稀⫞ᨻỴ떣\\ude80ᚯ╅Ԁ䆠E㺭ᲉӀ\\u0015ᡑ་펉쵢柳灊品䋭樌考찠Ǳ존\\udd4cᦃ撈䀎юⱦ卉耲턴פֿݴ詛荶ঢເẙ甕幠剋闷瞀⋜帨躀䜄ͪL䉳鰉㪾쑧匛䨀㼖챢ਠ\\u0000批Čぉ悔쮁噤蜄成벐ẹ臟⏎䎢ྺ䱢⒔ઍ探•㒷ꤏ䃄₽Ꚓ\\u000f☃ӈë䋮Գ䂰窒㉪荞⠦؃傌ຄ퉠\\u0005န⚰㨈䲻ࡰတɓ㸨尊℁횤聡䂡ꒀ胈橆飱슨ᑂ逜ﱖദ觘│䉞ᐪց顑✂ښ恁腥阅烜ꐾᇀ⾑ۚ瘽而⬒懣蔘ᢏ观襑࿩룶\\u000e舅񇦡逓㈌耀볙䠏㢦İ婽⨆懀ƣ곧評慜茈峤啕䵓蠆㨜੒。ᑅ휮᠆㝯레Ȧ๖怂蝨듔ꐩ堷喵爀ᠠ紁蘁ᑝ䀈언褍뛵뭾\\ud956ᴣ槞癝‷槪\\udd4f緙舽絞퀶뷃燑ȗ娙﵋喠Ͳ഍䝨\\ude34ⓓ矛㑸烂಴૶☂䆀嚺튴ࡈ\\ude53럵敘ㆌ鹶႞瀵ﴳ圀ú㍣Ƃ〄脽\\ud8b4⣽ぷ茁ꢋ䊈ҥ쵲遒\\udf33콽쉙萯褤\\ud804ꓓ枑ᗿꀙꆯ╴鮼뗋로卵Ԑ宒㦹‎餁巺䲀ࡽᦏ䏢蒁䪣ꢏⳢ⢅ᴚ䭂즍☎濐ꆘ儔胭됅\\udb76녦੡ㆃʙ戴歏卹餒党뢴问뮻癊晗煮}ꬂ゘洂⩠臿쇅쒨႙鉰欘΀沨㤛䂰쓅삎Ὃ쨀芀윕ౚ颳눇\\u0000⼥ጯ뽳˺Ȋ㩔꠆췒艂빲鰑暾簞鮦黴@顰⥴⌤턈ᬏꁢ七ᆳꭵ砑컀ⵑⰡ栄䎰鷀鍷朋膆㽲૵侣ཆ̼璊⥐⌎㤧⏦鰁因眏࢐⾭酈ꖞ懙ᴁ끾ᲴਪẂ帜เ찵ޜ蘐ᮞ滊⇼⟆꺫麻癃泜\\u0018뗁ꄩຄᰍ裃삟셈\\ud814竖竄ׄ柄튒ᅅ炕ᕐ푆辈鍎黎儧側ބ쀆≇⁣ሁ䱍༸ꨡ薜䴝ᇈᶅṇ᧱ⅉ\\u0000㞖츓豠\\udf882퀓엜漑捼瘇㣨䯂饳−瑳邤넅씘찀᠂纇\\ud899ᲀ๺칁أ䍠줐蚧⢫\\ud8f8胡≤倃舀낄ꏂ玲Ŋ⯝⣈ﴊ맣ᚌ캫댦ꋔ\\udaa8ꓪ\\udf54境ٮ豆飐驓䮫㤴詀薠㎦ᬼ塣ᶝ貺聐嘈⼨⵿ꉲ麬쫙읊壋玃猕舆噢㵃ꭵ鋵幀旪阀쌠⺤ⱔ뀂秀정뵣ꥳ⚎㛬㞔䃂算畡樴\\ud908ꓩ鴨旔+Ⴐ䚘ᐫ⍓鼊▻춖弮슏谞勗ቊ䑙労枋楧쾖\\udf31韸䐀ହ渨雌쾺쬅駍繞〖瀈塲狦燕\\ud8f9숑畕攊疶奀\\uda37䀤䭹⏰䓏팃\\u000e앱ꠍ뚠Ҋ⍶䋄䭂ꖴ㑰ۙ‣䈀\\u0010ꗷ㘰缏ᒢ䀹ࠄ⹋樅\u2029ᓗ꼸Ɂ倬녱蠌৙砛衰⦣࢕蔫且䀪Ɛ灆끰斔⼠렝㶣䭃賹漫쏰섛楔㹦憻կ恵誓젙蒠鶴틭᚛뀀䉌ࠁ砷\\u0000廾μ琓\\u0000ई쀁搀ಜ䖈㸏䈇攇䋹붗\\udc98ᨨဂκ䎊臀鐀䝴⢂䃣蟦ᵳ᷂Ả詁葽фﰿ䄘䪜属ᶁ‘茧否ᨃ턉ܬፎ粈冊У⠩኉ꐌ薑倘⋨봀愌ᆆ〪ӆ倯뱒쯠ꈆ엂⼆ꗙ䰅呯ሃ䀘઩됯栓㐞臀묞儤娀㇋↥㑑b盪菚夫⌝鉹殉♍ᗗ䀄ᕽ쨇텝≒ꗨ⢐␪Უ满๓玎鐆⸄⃧썢산예⪟ਘ汋裉鰇⃰⿂릟莛ԓ脣螺\\ud9e2蚐ࢲ쫝鉧瘈좀⣊씬᪞懷紈野㑒粸ዳ郇誈吺⒜䅪胤⫎㳣羀烎۰츾蜈簼읈봥㖀不魐㽈鏝랷し칉㠙ᥴ뉿궴䢕ꍈ긇茤ൃ\\ude7a໺삠\\udd14䍂瞉䄷੄꧑늀硑⭺䔭⢚⊱瞡ऄ槮涅餌胱퀪漰瘖熓䨋硧ᎂᲛ髁ฦὭⰹ\\u0018ܔ⎄瑏팹㝎ꧤᩳ㳐䚊͜䆶셎փ\\udc33괅㐨쑠瘀ੲ忏ᛲ뾆㙬嗨褬漸⼤̺ŭ䀃ƅခ蟓픳ऀ망귧ﳪ䡒醕啐。^鰀앬訝ɀ頟숰渄儠સၪ뀦뀙렧얠곗嶺ﵻ求⁰嘧侙쁶翠漅앺\\u0018覝볖煄몷搪㭻녿侇ၽ\\udc74瘁攞先⻽푻肐g封輛\\u0019ⲟ钠Ɔ즜Âଘ\\u0005⚊䒬뽺姒㟅켦畤쬹叜Ь玩⤐಻홽༼ꁎџ뉅䱸恬쏗튻짥唀޸ﲌ恏껣\\udf50᡼䕺꼀Γ틙嚪棥gꕼ\\ud8e8迡珳鑨郶슠ዽ砫꾡说ꠀ쎞⠥Ȕ㔃戗冤鰚撺觸뢓⦪팰☂颭쭟뚚䎃鏺₮\\uda60㗡㠏\\u0005vⅮ㋹渪痢㫺澒祕➸ᰴ酖鴋聿韻怤눘む醫凐ሚꚱ퀆ǹ鞱᭨삂ꖃ욣稔⎊ᐁ腵Ā큰鉄㴄娒⁉ቘᠻҌ㧂溴돿㔃 鉔ꣳ쐴ჸ੃㰼毌᱂켇舘ᄄ꾭ˇꎄ澆륯锆৴ᳲ렁슆꒰䪦䇿聡舸ጇ窨悰䁡\\ud905ၗ龠ࡑ⭏뭲䬣ɧ꾂利硘뚡莐ᝑ蝸攂灠鴀簴娈侌䓴ቄ\\udea3䂐ᬃ혗腤堀ΐ㶄遣薯뎄偛륐煰４䄄従ⓐ鞀揢⏺焓ϰ䀂獺鱄ࡀγ䑯㫘め쇜๻餂ዐᲇ缩珐㰁㢽Ꮷ\\t괸酷ꕲ얨記爋챖䆓뽊鄄⻇ୄ㨂䈸稇轅㡼窸攄耻뫬ቨتπ遅ϰ燹שׂﮆ聃吭䨬敹鞊쑑ॹ㰳ǘňث託㺃ј蕐ྀꉧꎗ긧읽≫骲餖\\u0002䠼ሧ膆눂᲋묌믅伥䤒毂㶍擓숅᠝뤀㦸曢遇掐䐦౔③䯂ꀴ낗齫鈫濫崥ꉨ튖ὁ쉀ꑆ邥谗ၤ䠪簹ɚ悥扒습ࠣⱷꣳ閦扰ꘅ靓⦏ꓭ먣䬄丐╠禧ꓚ瘤ຄﭦꍈ扼斺䤃儵஥勺쌪檧ꩢ穪箸ᰑ엘`쐴䙐㶈뾞לּ㘁䐿ݺ늙㦬懹ኴ䗃髅ⱒ쒷ꏛ␴䋄⬉猪៲堃昀ហࡀᎬ㧛㰺亾更緈잲セ鑹펮䅄⯐ꞩ窒枵ﭧ菹夁福ꭐ鞗腏賺딓꒞㬺쮧㨈㜻讀뭺Ⴘ讋鼸ؤ뭋蜻쮢뤰㊹宁롫隸뮁䗁᮱튛鰠宴ᓛ蛰ሽ뤰ሃ㮛蕂廥Ꞇ祧遇ྀꘗ낒龌읞嵺妣砾矓﮽蚷觱‧窈뫢튈胺焏꾐辠銑徊咅ᝏꖙ塼漢⋸䞧ꅇ轢琹拂՘吶䫂ࢠ\\ud88e볁랾㻲騍臐ⷠꈝ鉟ᮤ斘犰ã 鮢ᘅ갅Ɯ㵣襩䕱麼㪄⸑䠹闫肗肂㬊줽Ŕὃꨳ䁔㠊낫聑ੁ耆쏎ሢ䶖㩖裙ູ᫊បꐔ䃙朣碞䧠頊ꂿꚖㅸ噷釨亗窱䮔ޥ哶菁呱燦\\ud84e鵘령쌹ꦕ砽於à崟鯨ᬂ\\bꀇ肰πꨊ솱⥂ꚓ˞㽋妬壥ⴺ蘶漗ᴘﮞ炒逎臯벑㮈sꢸ딃ங햾翥게믂逗ᬈᜡ窺殶레►뮫갖週렡禸ሗ횫訕\\udbbf㡡燔橲祭䤔褓䇃绖ᵟ鴖ޯᅙ㼗썃ᯜ梋䤾헉ῲ遇ꡠ쥢嫄ກ\\ud979Øొ丼歎茗랆嫮ᔵ፵禄∅针釠함訵䭕촠ﭹࡉ㕏椑嘶\\ud925ε佪ꎬ䇇ཕ倗㴑⭡썴⠛畖铡␓戹쁂㔁ᶮǠ肂栌뽲貢枋睠\\ud900썙겴̀ܮ뻚ᶣĴ屓ꐊ膉鰙㸬ᣈ䰼뤴Ⳣꈄꖠᡵ瞌⨼礪힓䥢晠쀲ᆀ訬鋮芒蚰ӼΒ렺⊌܋䵪訪ᭁ⸔Ḩ蠀ޠ﮾謵ᕄ䍨諂踅襋碚袭\\\\ᬖठ眄ీ砦茈ฒ᭱뚧䝵됣⡘推ࣅ痨愊䆝衁砚ꁴ悑瀞䁆ⱂ祖䆞鏣䵽뎹꽑帨皢ᑃ疷섘⸗蕊瘔෪䝇த᭳鰮Ϥⴑ逼㥏㋗厂嫛揲␁㭟ᓋ震㮃㵓ꀇㄬ뭓㨒艂被鲶쥣㈩男眜뷆ꃊꮧ꺆堵ŵࡗ쪋⨓㐪͢됌岆෬誰༭൶匠⥲蒲䌗퍶फベ⮰挲⨉甦☂냞띁ƴ퀱뚷竚␵蟖㶶眰플탓ረヷ扱嘪瀆퀈\\uda0c䌁⭰銖轒邌∨载㢎性Ύ᥃⋤ៀ죃ℛ烤⣻瘔઎酨쵃壇ള⦠댤꧀猯㏳₳モ꧂롌贏⩰ꈄﲦꮘ㪰흶놄贰还㣻䅽魨쬭ĺ蒒ཨ茏刁錬䌭ꆖ瀮ϛ䤴蓅⫓ከ\\ud8d1䷘턡裄車脠됪뎉ṍ銙䰀⚻䏑˳⦦ͺ苲\\b‗덎밀少䈠៩㈬ٽ撌磩쌨㖲\\udb14䄋┪伝ㅎೃ輌쪘쾘㢒倾䳌\\udcccⳒ캬龜怦콬쑩쀞캘ǎ瀈礰৏몙챜﷊袾늮ə笃஌쾉ㄹ䢴ḽ坶⒴僋䋓躃垉ᗸ퐘ꇿኒ筠쎫嚶镪磹⬴ἳ眾໻ﱃ痔썏梙_܊닭¦겱码쉰贈฻ⴌ✮ะ銅뀇ⰷ哧踵ᬈ魩갧隳∣怇ᡰ絢섲喾ᐢ阸墜鄬ుᄰ䍜౱堢苺핓됧竧굃㤱걊搻ꗎˣꞡ乸텩흾秗흝䡮\\udd54믝怔⮳횤毗鰻핁堔\\udb9f퐃妹Ⅺ澫ꨕ㘻阖䉻뮐飃章琗븗Ṑ䓑羹ꍲ➭續쫳啓ຈ묕ḧᐋ紀拓깮㾁鍲㇬堧ｶⶶﳑ싡ⷉꠍ얰ᠦ\\udb5e懳正᝴Ꮆ畍轈籌᠚थ˵똭莤Ꮇ㸥갋ȓ灑਺艟䝶㫩择깋仗㫓掅䶾ੁꠍ✣ꄩ攷吻㸄℘⑶㈪辉ȃࠛ䁎洑⦒뫢ꇼ獺Ȳྜ燅䏪勾㖀ǝⴄ㽉Ǯ檑Ữ웒䮮ổ笫绚꘸䀂ꥁ덨仯皹᭏苒⵹ṿ堃褹隕\\ud83f䠡툟픶Ⓡ㏣ࠉ㧐⬜ꩊ࣯⌦麎쐏甩꿷ꭗ⻎瘎鳾⻁涷阥혇햇ࢉｈ᠓墅뇬髜颟䖘䙰㪠⠺廯潢晴釹쉵뽉黋\\uda5e㠔ⱘᙣ蚾嶑绞鼾略⶜Ꜧ杅๯㓗㝭ḥ䕅똋༙䕎ऀ䗁ﾝꀿ䮀똢̡耍뙊刖핝켦큐૟섵쭚\\udb75膹඲れ峪䴞ⵥ葔姴ნі௉\\udb40쐹鉁탰掲Ǵ␝眑↼୳⠋妀鄺΢骂틫렂䤗⃨⨁◌炩㠊규ě\\udc30쎽졁堉㊦蹋Е倜㲺截γ鏷혯\\udfa2詝槜祱\\udcd4\\udeb1鼋浔逿ὑ﹪넦鼊證짲짶儗\\udb00孎倘¸㏣虻ᤃ㲤⇮둶宴湅闪几ꏔ穮ᖝ뇪ꓶⶵ姂ꗮⲆ븮廸逝삉풞苛⺃甊쩂닷䁩牞ℚ嘛ꚺ䄃٫〮⎡⌮騩髐ᄟ⸵⸬ǂ틇뾈䝲Ꮝ啓䵫볓穃뎎ᅸ᫙䡆奙ὁ勤幹缚彼∙叩鷶뮢⣖诳臬面褩腁㧁ߍ苴ꗯꂣ⋁췵浜궐ⱃᡤ헱馒ҩ岟妓䭥妙㝘韤뼸瘬燆ꌶ蠉쵠鈚쵉쀒ｙ뇸봫﷊꩞ﾓ䀍\\udbdbᘽ工帴鈾᠆\\ude60띂컸쐌ᔔཨ퇒샣剳㕨甋ꂠ헎ᓑᓴㅅƍṌ㜔聭୨砶ԗඡ跴ᮣチ௅Ⰲ몋Д퓆靖λଌ昚⌗⣠้踨뀞鍒嫼面젇ꠀᖀ퐇紏탚꓀縍湠倡驠௘䰜촷佄炑㈑騲玵虙\\udceb\\udc4c႞霤硆촇䑑கڊ淔ူ넱븍않챏﯀츦룄禢䳮艀\\uda19ꓚ塴ꏥ̩뉦걦ᮉᰁ櫓偰⣘ᨠง铕듺ʩꅠԁɺҀ穄쀟ꂭ̋䮘ꓐŇ鄑鷍䩡⍰ٓP䒡‫ℑ覀ྛ쳑曋㍙듨⌉䀅⌂퉨薄ಜ↧쪂⯑枎͐棍鐜肉懘⎁폗嶤ᅦᢹ䠛݂హ쐞兩쎀野ᰢ箳᠎⬖㮢↤࿁꺌䀒本冄᝞铁蔍英䈰⪁惍뱂삪鴃ꄳŵન쩥➕傅蒀햇ʞ憸୭ກ阒삘ޘ휁麄㼱쥂荌䦆薟䇯᪨訁ꩯꂜ㣤옷⡆〘Ᏼ▉壖愕࠙묃샮۰㾁舌쀓㖒ѥ凣輒磽≇詽ﱂ흙ٖǊ⭷섲㳊ၰ뱐鐭頱㚕㱍숋ꃿꄼ⾦漢は⠣俊㌇ꬁڰ促謁ა䖄⨸丏初ċ̊威랐끛৘䒀瀊ᅂ쉺ॢ燑ঐ숌፳၇\\ud82cᅌ躘樠\\udb8c聑ℊ␀뀎臙읰䣝ꂳ㑈矌刜ꃾ\\ud94c鵲Ȅ\\udcbd㡷╔噚딇쒐ᛉᰥ怢셒壟迼Ā缄㠰⌱氈ﾈ⋸ោࠄ交亂ꡝ䏲坒ﲩ聿℮棛艉剗≬₡棽僜ｗ芦涁ꪘ\\udcdbꅀ똧刬뛸䍆ꀽ䲊急ᵾ₉\\udf87퇨ኵ꯸\\udfc0鐟脆⪀Ж航㗬☁瀲墊Ȱ᎔㰄聤য়茬뺉汄ᇂ稃ض嘿ʒ뤵﬙偺ጺ⃚煅砶腇豇␳ꐅౙ偼ᕀ첌큼壤ྖඃ化聆㷄敟貣陼㒘\\uda00䀁쎡౺铗ᰨ膼챇ͩͮ㝁䇂ህ↶蚠묀햕藬䔡嬉᠋벆♀⽵ᰂPፀṑНh켟㪐涇⋇ξ껀Ⰱ透ȥ䅞莰\\uda95凕ᰃ撂혫萹槸合兩偆ⰶ冈趬捃柹ӄ롉ㅱ녌癬鍩Տꪦ㴶㦌䊞捄魮㐫ૅ軂Ꞹ쿠쒾塖⍱걍䚀禗쁀㔥₊䬸ઁ䦮䵰醢๰踣꤆姗8⌦嘩ꀹnꓢ\\udb8b뢕မ⒘顅턹贐摚頃쁷폥讬⼩稙칌枪倲춚ठꉎɜ羒䷦墥뇛Њ櫠䄌䗼Ҥ䟺髗⠅癝⬬㲜̲筎௱嘓债ꇧ᜴彠킟阮煰֑뀎Ⅽᇦ菢ᦗᮝ\\ud8cd䨸桳ƀ劰Ს츍ᵐꈏ麀噔ᬭ铺ཥ燱瞍ᐘꞎ芽⁣㉧蕠੔࠱够ﳖ䫈磊눱农袌▀\\udc87鼜⊕⼑脊쁨쎮䘸ȣᣤଜ濉盨瀂̌ዀ됎멾ു䕠ࡓ紓塐ꂵ⚍ẞ荝邢襩暆㤊䀀ൈ␚捴홑᭎ࡉ䴜昁猑椶髢䛀꿢垀灬퉴쁡㴱並⥮鶠抌᧔裹ٍꚙ㦆铅솾∥蟴飀켪㋐賤敒⦼䈀锑⊿ᥐ虺຦撰椗䳓ҫܦᘍ陳틩᢬㌻ࢸ七襇냳蒠㋡ヂ蔋⋙魣䎤㠢ꛎ෤昀渓⢒擫⼔锋ц㎪馔왂騟ꂨ☑㢑䣧Ἶꝴiᇓ榈邜͆⽥鴈遽Ȧ翑֝獌恃㒑꙾틥魌訅甍積ꏌ댲㚊쳒既莙Îꏴό쬽慝䈂ᨸ홃摋࣮怀倀Ɍ2ɩ찴鴐ᅉ伜ꂆሣ䆱㒖䉍ꖑ䣕柋㌹䫏そ퀋铬驓伥츤냁玟㲪Ƃ鬉=ဦர⤌\\ud985츄斲섘髛⺹譑‾ֿ扦༫Į쳤宲蚢둯攒ᕂ㣎ᤀ姕앀슃蝎쀂閎勑龒ムܧ⇩構噦䴨᱉׈꺟Ⴢ䋸奰펜峈償㵨闋乵玾蕔搕\\uda91肓ꐾ巐疆鳡⭁免陂ꢧ醜闦켻奲轎熃햔걕齠䐭䅅莏鿃㓦뼬ꛖ짤畍坂芒រ⩶隈㾪㲴汛窘ꀣ옩≤儘⽮쉇㔄⡍ꪁ勤쨸긐ห␐ⅉ瑂刁뮢鍅\\uda2a␮訅ꎌ者瀊㑙曑⩑໌ၛᓷᩪ㠺맀䟋癒⺐긭ᑠ᭄㨤✹̮Ꭷᢞ燿衜吂毁셣褁⦤ͧダ嵤䮲尕欹軔훊⯢㿬㱄ꀯ셺ꚱ顜紗뒋識៯툇╣㬤㞧ĵ覲젹篠Ẫᘕ뾔禭㒛⥓乩㓑䂻쒀氀괹ﺻ딓\\udd62\\u0007䙩ぱ⺍缜ቬ⿎搧넫钜佼꟥乗畄옽塉⽓鉲氤霤ꤤ鮗ㄝ破᷄ꓨ楐䭥왍\\ud959ꐜ䇠䥢뢇䥽謬熋㜚穽靈卅졋檀恧ᷨ蜉쐵之⍉붪嘯㈩几檂䐉¢ø㐧䕉䫽ἱ戀쓬ꔜᴅ༙鰔닄햛悝䴓鈓屈㸃耒ᐄ茇똲\\udde6왒튧⊹䁶䅠ہ៭虌Ģ뒕\\ude55蠸र鐔鲁앁⫘ֻᅉኜ⭜φ軔ꅧ\\uda8d堤詔鲂誱胢ꨢओ니툏⯄൰厮»솼儀䘀兰Ѡὁ❩圀ାሲઇ頹醲쨵സ姇끫跹私肚┑㫂偉츊ࠪꩫࢸ歕䕺➙梉慚杓妴ឈ뎄缲谽ꌒ黐濆ꑫ憅䜫檥愰难ᤠ╣⁩꣧朕餂໨ږ榬⒊⁌↴踦겞볋夢ᘺ蔣㠧ꥱꂒ舰熍㴵ᚺॎ鹸ﳺ帩锁ɩ啔噖뒕쇊⑹\\udff4䆪즺蹬뙅ꌢ䘧侥灐튖扛옱萀ﴂ戻㢡哢೗ጶ姤컬⤬恘窚枰븅嵆畿쀄੪൘낥ᦘ⭙㘋耊ೊᙄ푙㮨陉෋匬谖頝咔˪۱ꄈ栂奢鯡龮쁡⦾跨Ǧ蓖姭ᖠ㔁䐅챼膡뵈Დꠀ腸ീ怵ଵ깦䋳塚ں꯽ኆꄶꆬ뎄剺㚓磈䳞㾈틆ဩꔾ߮㢈᠟ࠆ鐑ဆᛔ㏣傊ᔑ샰窕썅㫱閥讶썁쁑ᳩᚠϩ䴅凞”솺⫠날୪漞舊쟝껡㞂ꛕ㛋⪅쒋荷킟夼ꐶ䱝蝃喰냟曃ぅ롨ፔꭢ؇ǹ҅⁀沑㫊팎砾캀迋蹯ᬛ鄓ᅧ꠺蕣쬤䓲隉䢄뺙殆噦푖謦蔁梫河帚䑔㝽భ顮픦跂聖ᬾŉ菫䈁멯욍㖂ㅥ助畀᫣塠㙑䳐퇑遉載✣။쇠谎뫰堬鸒᪺潁⯕Ⲋ䝝謘ɀ螠縭鼈곮॥䜧态﹠ポ毽횕䣘㚵ཱུ뭈㵩撜놵㦸溫䚳ڧ艎䎀䱨乧ᮁ鄆㖪♢쳐䂩ݘ蛜㑵ꐭ㵫爚୥韰숵න檛寲饕䪬酥尬▩师魜䘦욐䎤냵针㢐嶩崫ᗉ깭ⳮ蝛촼퉆볃醲贈ڣ梁棔蘆㛃ꠡ꒲⡰屲䑶ꦰ淰嚃煛糒횄㘅꬝졫硗孂\\udb3c炵ଊⴴ왗瞚헔횴皒⹔腲喓昔꬯כ좴൲ࠈ滌㒬㿭⍆湫玾臜㖵ᶣ쾃䘺⤛車÷⻨﷊㹩믉侰齵飏夣溌ᣚ⛖鳗혬ꏵ䧫慹샎䯲晵䎥䱛珗ᛯ剉퇠곮࠹䒨ގ併뤜牍Ⅱ\\udc11㜷ꏁ␆阔䇺ព롗鶧난抲灕ఀお喆ꐠ걅\\udc3c퐛檕₋喩ꚠ⺫\\udee0ဌ쮩ᒰ睊᥮Ǚ\\ud9ae桳Жꔳ蛟宐걚ꄌ噐᫚ꄬं⅑ᘀ懊ᐜ﷬객峫픜ᜋ唐騭砑骖嚒꿩듛㋨ꔳ㌫܁뼬뙴䎬㰆樅ꡟ䶁풠ᗊ݈ᑁሏ㠐ꅑ㫑둣㠔ⱺ䴤ぉႬა蜄࡭셽࣌垾ꘕႅ蕟쓩砤졘ꔹ硬挚寧쩜끉휮ʂ泮帤賄셎૏⦒毊壅╃䒱䌐⃝՝홠ሌ졓䊅 \\ude85砠᠚ྕ闼邁쬌௘샳졂哇Ꝝ焇ꄕཨ傆㰑碖虄⹡皥塉荶ဝ뒔ዌ懚ੰᵡ碭哉庮尃䦉ըꚀ넃鉓䏃鈃紭븢ꁥ응冗ꐇ䀿짰艛쐡䐤Ꞌ㩰凎ɥĳ膜썦圙椀܉ㅛ譗䣰냌驠삶桼ǁ⭘衖䧰àꪅ臮셱嶉ే쓚ຏ瑀ꈎﳩ⸘᎑\\ude0d慨四嵽勃핬ↂ頂拤⅀누कⅷ逘ᖮ螈଼ࣀ᪦Მᔇ璼㘀鰄몊菽䅰錬ꉊ쯖坨适ↈꁞϸ꯸珃彬꒨ᛈἑ惁탘㷄踍옿褀划弇䂭⯜ꡃ榱რ㒳椉끨⤣ᥒ珆Њഄ口龜渏윖ꈊ샰䮥쌀쏀焴ၯ踍酮輸刔夔ﺳባᎤ饻귴爏䀻≘ఌꍓ嵏楲蹟〰떗븫獀㻀竆✶惠衲ꬄࣥƹ㼑醈橞ּ෡픀艧쎬㔑௷䐄웨除緩瞃릏ᇮ梈ꧪ혗㎡ྠ㐝誨唐䃟ల츃挹Ԓ➜艡홮뢨ᭊﭏﲐ映翺ਗ਼⹀\\udbc6쌗甈ෝЩ2駊∨㈗ﴂ薸椌Ṃ烈컡꿡⍄୬ᙎ윘紴탞ᯉ೵଀恍ƭ覶蔜吱䙔 枪Ԕ칥ᘩբ찵蜍맯셼塀ૻ⌂㫗긹㰲뮙聸敯㨳ᬍ賃솼葠Ⓧ虾ᦙ骜푦瞗㦒ゴॳ蓁䳮穼\\udcd6튴\\udba9☌⻽䵚땁悎츰ள瀁㹢鱺깅弼䖃駿女꜏᧌職ߴ嘁㘔扆\u003e讱\\ud9ac⮋皢ᣃ퐰胏䫂昕ꂓ\\ud8d2㡘䗄痝浤誁狔֗풶皅铌礕빰ỏ\\ude77\\udd0a᦮毧蜴鿝\\udd80玣힅駂﹪謭쨺䝲丐얰쵮瘽쳁∭툞鉆뙸堻㡔泠瞝ˡ服ᨢ霆怜譨愜廣念Άᘆꈄˡㄆህ鑥얰匥爧❄鲆흁냧围જᲺ铄ࣿ䇷㙰ᴸ孬뽃萢⺰꿡鋡栯൸롥慴㎄었ゐ씅駜㴁Ś싋陂벴焋쒊躇\\ud9a0 ᩌ⃤ِ░ᨗ큯瞥潼푛拰\u003c느\\u0001内氠ꐄ嘕⋐ḯ♯譢ꀒퟚ輾䢶뗛놅໭串钕钬䭆徒폦涞⊜곸Ἣ籄⫄ꏍ蓕펴휞ᙢ녊밡ࠛ丣龈㥪萩㞉ꜧ錴⍄㤽멙鄉ꈥ薥巀价ూ䶠㓨⇽喤翶쵵࣠厬墰侃遴楍Ⓠ鱈膛⫁䁀\\ude44栕궺ꉈ⁊⧎ᆴ̮ꡰꪺ쌥⩁吇㈡瓥⠸䐁ᐑғᦁ偊ꄵ텮遈빥哺Ꚃహ╌먋폯櫝澧ꡟ홍볹鲊暠똀䋁耏ࡗ肂⚈䡚ꕝ⒫榝싘柼ਠ̃倆䄧潧䢻ᦀƓ뮆몡蚊Ȱꈋ䁮υ鍆뫟훡럼մ滂㚘惨墶솶ᆀ㬛潥᳛竚盏悑僝⎭剡豌ᥨ⎷භ㭜ꄇ秛웝㛎͌㚬㹴↎㜂逎妐舴⢠䀘₦ﵥ뫂省륱寊\\udea0Ė튺싌꾻狛䛙㛍㦕혝\\udb69됎\\ud8f6殹ꍪᦇ毛퓲焯랥ꤍ\\udd2e怋銺懸ฑ늕쭨㢃쐐䘃┲ྠ䃮㝹\\udbab啮\\udcf7㜁ᶚ炵楨㇜ૂ爏㕮異颕樈碗ᷛ嚹᱈䫙囁឵讧ᤔᔗ亇宭Ḷ댗钎ᔭ䋳▃毄럋끢䡺霩錛狄䶽偃鉋蓋쩡㎛瞖䍐뛅酾񕞱㱏祼廁\\udf6b첃쪗ɐ盤퓰배ꇃ괳鿸㤜Ɂ뒻塚넓㔂⃞⎐혛\\udb57䜚ೀⵃи⽢ꏁᇈ闧ȕ阑鍓萃胪徘䑀᰷쑄ޱ匲唿䍙⻋㶰퐏堏凫죀\\udaffɥ隳途\\udc83ꬭ꜎␪ꆰ簿ꬬ喫\\udd35碁䑢厘䪞㚧줺쫄ꎲ翀ᣜ絬䅂씴炰\\ude94䝄䙿ג饒䁝䲽膀ੳ়蘵ᙕ퀜젇ᇳフﾘ餖ꄠᢪ莑꛶职햹ࠀÐ봊邽嬍恀ዥͦ\\udfe9泽뤆筍❟㜜栃櫋Þᔱ袓︨簙圢ݽ펙驹\\uda44ﺻ࿎㒺뀙웵蜠Ҁ輐损䁐赬镮ⷎ桐쓗ᰈ蔰矃鯂姊v炭䶸备嫡倗玗ٽ\\ude14稸뉀\\uda1c캠ᶙ瘈鵷䐠刻匽藘泠츫㜹ꪻ枋늌쉵壞聡\\ude28橩陼考鵬픢Ìย灝䖧跊㩙憑됣鼠P됂된⿰摽왒〃軂ߎ㑑鲎囂揋븙켿ꀚ犞″쓖獑佳鸱刣턁ěㄈ愖ꀯ僛Ꙫ槹쮖ꆙ詻鱪ᄙ٘צ൛㝳냌乫쬨쯬핐늼Ň潳狞ૺ曃㦙赝଺⬟㵪螑햒띛꽻싅ᧂ눤뉽䳨ꃓ飜殛뒫걟湧狛샕꧓⥹졳奖荱엣邑诰毘ꆧ⻤볓蔯爩䬷졮噗品쥥㍎闶ⵤ몈섲賺譅\\udf60컠葤㷙聬次啷鷗칐䃽ğ㪄鎎ḧ哨岆蓀ꆁ艗䩮鐁鮦샹窞ǁ瞋릃⪭Ꜥㄨ㻣㠝ꜞڪ臡Ⴉᑄꊯꈤ焒䆒垠钙䢚䐇䦑㹸䒯≡裢摭⌞狫\\udfc6㐓밟趄❁ꘃ䃻ㆢᨆ뢇䁽ᴖ⯥傕巃䩡౑ⱍ滧㱻뻯篦誤垞븁ꡏ脌㺃ǧ쉤鸛뜤睻耽댴ຢ钙\\udd13䗒⨑낕黷∫豅騞밮訌㲽츸愛⎈壂쮽眩윔❁㬱ଽ㙄↥喛얄脪榗ꋛ逃ķꢌ⛸㬸䓪虤࣭䔤䑧厇䐃维藎赘␖㲰蹰ઓֆ癃ᒝ駨౹ꥈ㩐䁽찬큁튊੐Уມ䈃촞䃱믿੠迣賣뷙쮣´蟝æ᧽\\uda62卥ឧ韂癉兼郊⟠燮⼿껬ྛ獁춝ꣾ韺㹭쳉ॡⰦᆄ풡耆眭甒貟㧜㜰ᇅ᭏땥폘ᎎ۹鲁૙ꃜ⊩㦻厍睳短䪻톂垣Ⱔ圂䐳휱鿬\\udb00Ђ쀎Ň焽╚허ǂ쑃樂﫩濟ƞ㪣餤Ⱟ鿴辘ᛪ룥찯ꦵ㟝ࣟ⚎氍ꋩ鉨鐀ᐷꄑ趝巫㳗砐ㆰⰇ붸◯ໍ뱷༑ꑩ綣ỗ⟒ʝｋ횹멑긕먕腃閭澩䇊慣侦쬅ᇱ੠ﷴ澔5랺ờ뵛㳆댆뙽齣娖屛⾕㗄⻸ٯ장篐뉩휬襻嵢德磏嵱惴෻ ᳾䷛\\udf1f㏏넖ᘅ澂ﰇ履Ἰ⦀ɓ\\udf07ࢃ豈焢蓢揓傢ව鄏钡簧㜻ꪽ䟉ド虏춠Ꭽ뿺˟벶굻ￗ㦝\\udbd2뺹ꓫ뜄䅲￶ㆿ⑏䆀ꄟ䇩䝧埭罏ʔ霌袰暱㧰鳮縩盙쁓變覮썔۫⟄屹䐄䇓톦⇄⮩\\udd83躄椘ﰃ뱶行䎿蹀⠚Ӵ责㗂犖ﭏᨡ疷濣罜똖랉뻎羳\\udea2軗켓뭝폶\\udda0罹綾ﴸ훬㧺࡞翓筬ꒅ๓㊥퀿⍲ￌٸ阇귯ឈᐑ鷋㸦䶇쒇ዊ踗ल⌁⣎搞颶젷飂⣹ጆ쾪個㩗ߤṖꠀ鏬쀫뻷窸Տ訲⋹簾⾃깩ﭲ薿댾㯺늍Uℵꪾ䩛䷫㞨급ﬣ꪿蚺嵚꟤懶槑ダ䠇ꑬᾮ绤ߧ肠僳램ꉕ䉭Ẁ啁Y済놭䍄鼠㥹䏫度竑␗鿶䅻灨ή⣀㩅颒澺㲩Θ蛐㫾鰎쩉ᛉྏ鹘風ᭅᵬ\\ud97aᑄꁙ♻ᅞ䈸ﾩ垱ဵÀ룥惥膶誨믴㤂\\udb4d㊗ꫢ䈩⸎䓉暩耖㺃\\ud9ee쒚ꖦⴠ膈ꜗ꫰掄ᕧ딴\\ud862괮춏ꚽ笵꿗荎罪᫯ᖱ꺡婇䫀⚸洃゚片ॵ෤鰧㾮〉겲괇紅㜾⁝Տ镐봇昫㾋䆢,ⷴ⦀꜋ヌ喏뺬롩转阨眊⫭꾍ﺘĝ頾䞍끇⊎ぽ篜Ё堏偌摏㥜တ⥠ⴃ鰚耳ᱍ餴駁⮂ꭧ灃䄃˜ᵠ㷁﷫ఝ䀋셹毭軁⃻ք㺊Әጏ黺蜅舝\\udfb3㈰ꄼᷔ껠妒蔉䰝䄀螠ᰯ궮ఄ꟡뾤빽孋ꬨ伆通待\\ude14ۛ⯐哐鷹怩聍ਣ㄰ᣏ风\\udbfa齡䡧셔萖捈弁薂䰔혿舥鱗Ꭿ蕼ᗻꐯ傾㳊窏㳘ᗒꢤꞨ鲭喝컟ꈡꊅ衖⣍ۡ꠰睠伅鰠怃肿禭п遂䭹㤆核ﻌ쥢៰痁儃瀔羄횛슠ᘦꪡ섀㜃̹귰楠ṩ耗䁺몇餒ቹ묡캻Ὦ䡝⻆虽玲밄鿮⊽⇶셚᥿ꠡ骅鼮⡙ᱧ뀍⦄㓠ꇳ銗哀燔⑷᪀䙒늫툆ꇠ݀ꊈ羮惘ᨔ끞䆯끴ᓔ胁댆࡙숐茈๟ء́\\uda16㶃ꅸ蕯恈桡蘙뾩↜螫˽㨠궅墨䋽蟢̜鎡搇顠ꇈꏀ䜅ࢡퟸ鰛羄ꇖᎸ칀Ͼኛ㿥킒ꇱۊ႖阢峨䤋ﾍ쓿契䠀䐾ꠊk쇁鬣ꡖ゠ⰛK䃰܌॰翁㼇銍衿ꆎ薂᳈持쒄镡龤陧\\ud82cἘ噡㬆툞⊚소蚨⸸件\\ud805눝㡓㸮뭆ᷘ࿾Ѻ묟鼢䱘琚耦ꈩ蕕ຈ縠ⱅ셇ꢊ훕㯪謠䙰ԑ껬\\udc0d퍣梡詒፥㮇仠᧣쀐៨슙ࡌ㤾ḇ뤇⪶뼐蓙᱄趞磌棛࿐㢄ឋᆍ⦣䡘룇ડ㬤Დ맨뮇恛遬갱ᦐ挓ꠌᄋ჌䇑萠⊒넔躿ᅻ셙․뎂ꠜ羅뢅䀎놳艪颴⛯롦쉠寊ﻣ↔⓶䚌䎞㣄칄⒪磮䐬䇱㞑㬐죠焿采Ⴁᧄ届ᰵ쑙䗜䊒鏄밸例鑧量胹ᑔ翄䜑ɉ䞁鰵䕌䚴㵑菢堧萖ӈ槨ʤʹ㕊\\udece誡샞㡯썺ඬ쩑ꀉꞅ䁃⏔얈ᷴ恣刷Ấ肥䟇贠ɸ夥䀙ꫂ꣐ꓐ숢ꔙ笁\\udcb6펝፸ᤈＣ濁픳꧀ֈ㊞찠㺮訽⃩퀊⩴䜞姁ሕ䙥។報뜐؎➠刂恶꜆届\\udee2ᑽ놂擻둑᠑﮼廟믨ἤ鹬쥺堜太儐옗ੌ瓄탆ᆖ帓邌䪭஑眑\\udd11ȟ頰쟄槓㸎ॠ\\u000e⹾ꡎ፳驪銀든⋛䰄錐ㅒ廌\\udfb5䒵砩귡叀梠Ბ옑ꃆ脬䧨骰਩쀼쫘뇝ጚᗑ佅쭈먧躪Ɣ꓆⭰๡膅➉푑ꋸွꍒ洂\\u0003솸\\u0002㻪튌顎覑덢╒팚尯兕ᦝ悯㴦쟳拃閼ࠎ頼୙꟢魱鵥⪦踂㮊ꆶⓢ瀢퀌ᔦ\\udc47榇ᄄኪ빡릨㮌烥㠽㩀쭅痣厵챾鯔ꍎ뾇吙Y릍뮾겺篤됷뺠뫻婲臸ဪ㡗繿蘻⹔텀휔挦킏ᄅި২\\ud813Șࡏ᷃㾖ａ쐨硑튎ㅝꛜݰ済选뀔쎀軠雱\\ude09獃ℵ횇Μߨऀ鷫蚼ᅡ蚉撄縁ꑆဗ䮿熃잡᜝釡鍙ꯩ됞࢐ټ䅨刅忭玲꺮嫷ᬏꨀ띹믦の릷ᮆ鋞态⿥\\udc52㺕쟾Ჴ㠂\\udf7a䂗ɖ뙓筌ᖂ䳦믈ᾒℽ윜覉붔䠀䘉뜡ᛃ왗฀뮂輓ꂜ뾰憖我갫ℚ쁫㺬魇윀┉頢\\ude61롵Kᦴᕐᶸ逅吂ढՈۄ痪㣀㺌臫寈ꀜ榬䇄┽©잜旬▀쐆:ჩ팸晳蟘罘떏튃竑鏹腾믴頂ᑣҠⅱὫ᜗厎툕ۖካ뇈쪉㐐\\ud867憋஗Ⳙ睁놛氣Ἀ°⛧꾨柂愧뜛솏≬ᦘ䀺㜻෤좲悼䆪ఢ⁉輑㈬\\udc50닺蕆詘⣁砥童吩ꡤ䮯రᑶₗ葰竉祈᭼䜉䘘ﱹᅙⓤ銸ƀ꿅ẩ葨觼訊⵺ꑉሥ訫㰄ꊇ苰⥠骋咖ਤၰ욆咮ᤤ퐜됖鄗夃삍딉몆쒜ቷ킆˪䣆艉ᔧ俪娀\\u0002瀀흅总Ш쮂應猅ﲀ䠬ᒲ뤭ರ暮\\ud825唅琧ꂡ耆ߨᄨↃ걈縟擑⛚ᣒ夲␧㌠ꐎ瑞슶ꊨ腉薌Ѷ쥼심韢⩉⯸蘐䑫⇬⒣⧂夑슔耢⥈\\f遷郉\\udb84媎ᦾ肚讌霢䧂팤适牙᪚誠Ͳ巉搚㲐蠜襀Ꮊ蟌⚢Ｆʜ੨⧠ꝱᴠ淶ﱄ咎飔텉촸᫴齈ᰄ瀺䫥腁ǔ苜͊彉刨㝀쎪ᒮ윚襲戀쬼ぜ诲碠‗ʨ䟋⑱㨺㒁᪸绽⌍촸৺師ሂᒑ䇕㡸頀襱\\ude25霙偎皿㬌褡⑇ὤ眧鱌쯕ꖎꞼ鳊̦䰓䒫㭼䷎㊸쌩㦠郹Ꚑ«驉̻㞽窝扏ꓱ阰켘鉪솖뤷ဟ鯎릚眗Ѿᆬ␒锸䱩ᲄပ졝⻌԰ꨖ駐㤓꬈楯ㅒ鸈篱ꯅ䂂逛苯쁸⢺硠㯆㩊胢䉋覼狩\\ude81ᇇ搭⦬舶邟늉槄缫곲ѥ᝴礱ૢ脕횼㇀顨᲌䠦꣆㻢⒔帱䕣᜔埮ꘇ墧쫉䜖쓤痩힥\\ude95鞥쓊ͻ῿뢐䳅\\ude9e챂⨙썳ᧀ⼱珣푷ᑂ욞셸牀ⷱࠐ〄놇墇ຨà庤䤀看覸㭺ꎈ鄜櫄ꈉ걩곚잆ꣴ瘬ḻ⠇ᰉ襐龠㬸欁◇紁ᦸˠऴ䃠㛅\\udc09ꀛ䂀ǰ渀׻볬涴滆䰣㢄᧴웕᳄毚ᙳ﬙떿壉腱鹰⾩产ꔩ᱇脥神⻦Đ䷲梋弒쀎Ś瓠穧\\ud89a碣胦柜ɾ鞩庥씝⯢寪冦㲈㩿器榝Ғ뎺즥节岸≵覚撮ᗨ먑㩣㨗蓠໢鱱Ȼ斋⦾꜀旪嗎驳㈓ꛠᒼ賡᫋ꩧ㒽㸦㯥ꬬ겺\\udf43놢ڊ椥쯍槧घӺᦊưҨè䅀⡘ᗈ쌭ࠫ妷Ꮶ韄❙硽耭\\udb36髋釩嗚怍綸\\udaedꜴ隿鬉\\udda5\\udf16噃ꞑ᠖璾薔驔嘞鉕둖❤같㱑络楎靄漾頀즄ᡕꚋ孉䒤璐㖗䤍攋⧂给팻\\ud945␧Ⅻ맙ⷆ닪\\uda5d타⟰龠獤ࢫ䑢懴䝡윶䷶杫雥㼅ꧽ扴ൠ崞３褂扫쀚竐খ똀\\ud8e3戍櫚暸ꮒ⭰ﾣꦸε짿钱ݰꈮ䆞斔ᷦ偦唄沕屚㹙揭莏벾쁆脚耿৥ቐ૯诎䝤㜔์\\ud993쓺؎禮ⶦ⮛㱮ɰ鈎寎䒡추쉓\\ud92b昒᫒䒾᭦욙\\ud9a4꜋骔ෙ䣥\\udd9b婏孟ᩮ佖쑆뙺낑ﭻ쐢墡㒧⎒깣\\ud9fb鬽門毙曧뒙뙧䥖键䃰盥渜蹀ꃡ苿ᢺ纹訥Ŭ䉊ঠ⒌闟⏄ዧ턊詧C蔫ꐒ毉Ꮋ鲙궾঱鯟⼷髎갩쒚ᄹ䧲酼愰䐁힒貣懻ᨰӞ拞뼤耎퀩ꁦᎢ୞磚킧湄施鏶䟙駹䥦\\ude3c礢⛒齼긑삠뮝㹸积晇饮窰罹ប빿륷擂苊䞂턋㛈︣訏邥຤劦難⩊襢쏘⼐ꢲ杂尣씅䶜⡰䳄넉ꈦვ鈊옭ꄘ䴯픆뒴덙㍆섂촛麻褙觨扆伔䁎䅠š㎊急蝏䀒㰙ř፨벁ん㼇ं␐碷⯉㨤熒멅톸ᎊ䉉⇀撒䄃⤫僰秡Ϡ⊤뻢廢犺膀骅硞兄ࡨ恬廆Ӿ邔䄱ᘄǭओ쉐孾い㐖驊餃ԋ倒䡉㙲銓끚တ聜ᝒ伩ἅ첒훏愫␛쉠Ť瘞噑䙉ꅮ擊禊䞡䅈᫠灔慊瓮拰姽띑ᧃ\\ud961ꀨ灚˨࿺എ鍇『똴됆̹쯯⭰ﻰ錈笚簣遰इᕒ쉧쒬ἂ㠕㨲ൠ㷬㏚⺎ꠙ䪪단鍱Ɏ뷁䩞é鶑樄딀Ḯꐪ⊥菠䱠ᴀ⤚ꪤƆ䖦怊ㆬ鵆澪ḍ鐐䢟׽㎐洁↙婀䖍抙͆ᬀഢ脅䂖䈰ਵ♁즣긬☍˓䥚湁僳Ƃ耭£쎳肇぀◂刎蠨ꓡՍ౰䄁噥遴푳ꚷሜ䆫鍁᠐騻덞˦ᶼﵢ㡛椂퓍ᰬ₞앸㸌ტ策ñ䥅￁鑒➖䙸\\ud8fc฼˺⍺འ弣\\ud8a3倵찐᳅᫐鰂⎟ါᖬ嵡〜㛦ꀛ䁙孔觀%\\ud891り六ࡎ愒媱唀␁䱖풎ҵ難荺✦햓㸬N棗掣泬坦ꥀ쇏锅큆Ɇ䔟鴥⊒┉호ꨴ㭪ꚾ鱨稂毉䪼偡⩒閻㧀鍅钠ꪃỾ᭹䝗鱀퐹唂ꥺ祥ꉱ羘ལ狃ꪚꔶ聰ቄ潅䐁蠣뢔舓▊瘢唽îꧡԣ閞매ﶫ퀀ဘ۔᎑漄ᑀ♈쐣ዺ嗊戗ꌑ⅌幸업겅ﾦꉤ嬴斱阂꼙燔떲鰩ࢧ䕘圀♐᳄ᧂ缙꣖ញࣄ㎂挃㈤뜶≕ኄ过銀害㣇7ϝ쮢暩줹⟌䥑䙤杊淰᫴䚱홢ꐥ䘇዆䎙‥㼃棣풌ಈ꫰䶕䥊璭룒䂩ᮜ㗻놋끙ﰑ륕씄⤀騃ে⤏蕲쑘褈㗥Ꙇ줉刪梏歰਀ʳ繐䜿窳ꈀٳ볬䵥罚婣馹ԉ釬跴ꇢ逰顈莙씞᫤홰쯊∂邆脻셚谙猔캈▅肖㝶쉡銋怪̴❲২呖阈逜틇ꆴ෬䯜犗㦁紪梃ᘔᙪ竸袍樭ꣶꈍᏔക䳘瀈遌朇쿉⫥乚쥥{諤ᑷ⿥ᯁ᠉崧└䀾╘楼ᡔ॔砶뇛࠴挕ꃢ촄䕙鰲喒懅愥ꉁ⥒ꕓꫮ`㺕它ꅑ鰫꧗꩞༂ၲ㨫ꥼ쀄憟౪꣰෹ՙ遜湼Ȁꡗ컈묡锵살ย∀没슭敹䱢ꨯ쉺⑕䨗畂ᕇ梂嗬䰥榕硕⹒Ἃ┹Ծڥ䊑蘁ү䐋ꖿ䕘䃈㠓妒阣䠵鞹必农욊 䀙噦괥癕⚪輹祝唕崺醕⬎啃詶䁸ැ㰈읩䐈핳唛턣즽㳠紂㼿唢─⍕쯊次惣嚚ꠉ⢂羋簊墼ꯦ걇菰Ֆ⥐čᢪ啸何污庨류怛䀜量꽏⥜筪狼౔⇜惽뻼ᝪ髊펙ﱱɨᑊ㎈홛\\uda81ꑹ鰚垉㖠෤ɐ\\ude9bⓞ廙䠮䅘륭麈츑萗ꗔ൥ｧʇ噎\\ud918⤵闔ᾐ˃殂䀱锊쏵銈䝹⇸巠䀤⁻ၢ◑墙⮗婅ꅀ歔华䃴肐Џᾼ\\ud982ꅆ锚\\udd6bꤏ⚛ꪽ읽邜錵꺴\\ud9be服䂐逯ⲭ㗟䊾쪋뫙ᇤ宖쵺T䎫ʤ⸊햧烀頫科\\uda23酷ꛨ੥쪧¾탤ꊝᦵ炁䩬㰋闡悊᙮鄵⢣惆울甘묫꿫꜉倍긃㕸ꄭ䂎ꛑ⊟绺ʐꤊ巐蟧뼟⩏䝬Ĵ〈ᖄ๖䢶롖Ꮎ忺➚﫪諭‛섛徖鱙箜綷㔺훹镍瑩ϕ謋䋎初韞啹ﶙﻊᔗ杖∼ਭ蒦ﴗ룥ᶂ㥋쑰╝怕뗕說⵰ሃ崑䡌쫨䫠麒맜ヺڞ鱺뻖㹦앩䐳碤౬⑺ゲ蔈뙲\\ud949節阞容㶦䘛빘妕鋜ᾘゕ윉啸馕셯冽ꫜ랕쏊ጉ奏䧏鿦ꂨ鼤ຖ鲾뗭檳凰褤\\udcd1訋쵎ꇆ휰頥꡹琫\\udb5d빣딨䚲踒罦Ѐ燅閴倬艀ڷ蒤呁핡嵲壖䥂ʡ蕳샖䵪镍ऄ০Ꟶ騳⃘悎盧䂌\\u0010㙵ዃ惒쵄奝䄉٤ᄍ輠鞟\\udd75㸡ᅃ䳹啪ꃝ\\ud811䀠돈톌ዞ줉笊썙痾直\\udfde뭚ࢸ薯傜쌰⎽䗲ﲔ㘣绋ꈈ\\ud990ᷢ쉣숎膅閣醈풤ҍ뭤햪畵4ܳ宆뺵⩂᭗쵍妤㒴馾翵Ꮤ뀒䩝ൕ䄿古Εꐊ煯飠峂㯥㇋湭捒큜㕛⯃湁冢ፆ꒰鋶庍實쾝⍍඘㑜鸰䠀㥛ὅ\\ud97a遱ⅱ喙కḴ瑈ഏ퓬ቘ⾊ᯑ\\ud951ᄁ갌䠀ꏂ걗㒧㱢Ꮾ厳氤Ă栬ꗱ⓺䩥娆䔑饇안嶌湥ሙﻠي鈛㟽䀐Ÿꖕ䅁춸驍恸\\udb5a泖ꆗਢ㠕텂ȃ苏ᆸῡ晒䴛ᖃ뢵銘陡츅䍴㠹鱶衸斋忱ᶕ矒셞쐱鹠핕˳囍បة喥傀ו埱딧ᨲ䃖啋₎╸\\udc57⨾顳哒\\ude83紭\\udc51蕘嵮犱镺ᬐ㿃쨑ƛ肙䠲弉䝰癔懶쪆뇶쎔퍞醩큁穢案ힴ䇍삷骊䩪\\udc96λ삭勅㘖牉乜頁ꝵ帵幦蚓쇜㙜຤フ⩁윍耻䒖놄ꄀ垫씄쭁괽픇醓僩嬱൓䂰൳횀풭ꯅ젂䀎⌎⁼쉨䗺⚸퐃絊镔ꇧ肴ణ㢼ᯂ숉렕큛퓌\\udefc䥠࿸縞긂ﱘ㧏슝ܤ廃윉赟ꨏ倪Ⴈ톶남ꍸ姿䦳劀ࠜ↷靐꺒䵱햼ᬳ礥ꕞ荡恀捎䛵漪\\ud929䐃㤃瓴䅥惰⋐낀ꀘ겇阐࿀뭵鷗慨鵖⣢䉎蟤㽭辱֢蚗倢䋅骝澙쨃麿㧀▏倖䴵סּ佟댩贤寏各⾨ྡྷ꺁᠄恅荎豙먨ষ귭ᮀ竀ƞ\\udd7eਸ骥㖊ᮢ溵쏇긫褍便噖⢰瑠Ż箹耵甌魆෤䓔혈뉠鲕ⵅ쭤䁑坤嘝⻭蓞ፄ愬ے\\uddfb燐嶶욓堞뭠ꢓ焍줶軞ﱏ냲\\udb4b慠摺邌\\uda3a㠷쒊畭뙁쿏뭋䵤㛨\\ude3cꄩ鴷僕쉭൐⛆湛䦭졦肃孌灖㐛⷇䂀춴筷탩ϼ੧䅭ᙷ掯꺻⥧➗媇䇭튺㑝ವ㗸環ᄛ岍ᘋ䶕ꍏ즿뗆\\udc20ɭ䦷萈蜾쑰Φ\\ud99b潡餀긋魂⁙䄌ಀ០晴荞吋ᘴ塷♧䭀汁⇟뭩ᶜ讖햖⽒䅋ኑ鶝ޟ幊ᡍ䠴䓑겫ᴝ뒣⇇䥖鱨㭷ᩃ럱툻籙᝸鴨蕰䂓똠഻絤讷컘芄\\udd10ᔏ馻幈ႁ⧟ᵖ೪㌞\\uda7b彭灴㧐먷랁ꠗ箝㜸㻜쀓ꙓ劰㇝吷ﭗ僓햱푁ꓞ羵愈ݰᶠ県ง矉䋉ﮮ喧巰皽\\ud887傰졶ⶑ絺ᷙꐕ駧焝뿦䅫蝅鶜┑\\udaed籺㗜읐盏姛壢狨ꍷ탳盨꠻弝ᨷϕ쮅\\ude68訧哭䴠虜򟄱㘓\\udda3擹듞鍃떭럏陽뙍 䶛㴼\\uddaaᏉ\\udcc0᳼♴怣车\\uddc1毫ꁈ֠盖맟횽巔㍃\\ud863惕ﹶꏚ흺㷵晣폛燉徶욘暚㚖틫湭눶鵪괺藮㌽湾뻵쵉跢땨聫唜叾뗬᠎ꐔ᪠ࠋ怠譵ᮓ﵉륩㟯棗䮮옶䴋睒\\udee5㊭异ഘ聗㸇ꭲ囁둷蚷聽Ȃϗ坓ᴾ瞆\\udf90⫺ㄶ⺲봤瓵큏䂝쇧폙\\uda63㶾퐖睍넴胙物巿슚큦㋅겖㮉単\\udae2먭鐾蘹㶃腐있䇃å䏇ꖊ癠魎ꅯꪋ㞏č胶麟㌓刅̽掖ፒ☦쀮鸾㨹ꦀ㢒摒뀮䛊\\uda90虏츾ꑽ亡弤暑覌떹邞⎤埵ꜻꑴ輥室覕࡜饰☗㖣Ỻ帱龦\\udcdd既♸씥怙߶罃뢻䞰੿綅妀ｚ摶銤䝿侀䠍桙䤦撯\\ud809眙\\ud848ᤡ죁鉀㘙৽폃쀶ᥘ頒혿햐≤䉒㩃䃲ϟf䝏㙤렍㿗惫ꀊ⬐⇬^怚댊尢㩀⪁㠂ꭣ삨님\\u0010滴꯫꾫鸐﫲䙜莉껶볘ࠔ瓦髒훊ࣝ璷늏⽿胼뗮ґ䔐\\udd03룍ᜨ碾隚征௸澋꼯뀬聩躱ᾆ幒\\udbd9㊾䄳⧸覅几ᢒ敞\\uda98峇哗Ω㒰脍즄ᕻⴓ΁⴨疞橦妘ý雞轺㦐㱓\\udc1d耆ݟ䷅碭᱂饂扵黴ᛦ侯♒꾀촦䌽㤰㔭樠둻覟ᚠϧꠈ֠䔃亇池uﭔ䩆啔᫽륙걖ℜ栅䩙䟽쾥鳝ｄ冿䷍\\ud997䡜æ承ꕈ抗锄̏捠\\ude2e֍㽠䕥ᒸ쌒䥮ՖᏓ孉ꉕ쫳╚렀䎣埵衘㫨幰떇ᅋ頾焘ᧀ傃华紗砷౶쾸╩袀鰊Ꭷ쐼铘꡿籴蘫⢃抏ꒃ䃓䱨膶塆烶Ⰽ炼຤㞍婖ಂ혬ႎ礀囂㝈浖咅ㅪîꠢ˧ꦔ伃쵢䠱喫涭휏舻烄鍙䥍ៃ୊袆Ⴧꫜ冧애捋担咶䡥Ȩ죒ᗢ㼌숼죾넥莯佰㤪쉰磚┄ꍜ赊㓛갘芎髆놥㵈̹즶鎀㱢닓ﺝ機퍚阈뷐፦ꍲ憉孅榆⒲镖䚽ꡒ呍貐䴥ㇴ꽗棐䂝늄㓈살⛅濾䥖䍪γ貣냤浗궩徾꧔躕쨟ض蕰쵝棯⩌噙哸䋕쿩ᇃꎕ煕׉薕忛鯒棛䫗폧ᣊ\\udcd3鑣ફ耣쐛\\udcb2鰵壤亃ꭩ灋樐큤\\udc8eഒ謈ꇝ詿「숣畑ⶇ㐰䕫仼\\ud8d4㈽몾㖿钷怲劏轒睍컀튟好\\udd82쭔倹y푱엘芝뚰牂堐劷矃ꮷ噩쾵倌䴠쯧\\udcee亍ࡆ僑ꝋ㷥햀鋞ꯇ훉\\ud953谍唵⛠斟嵄斕苁酜步淧˳\\udae3൝쓈脼룙椤햙\\ud971㧭\\udbed薧揞琀\\udbe7宭冷켧띻㶡瞅\\ud9b8ᄝꦴ에Ⱌ巙똥힛妝적ᛗ펾媉텍䷎䞶㲂筚Ꮻ畃\\udf63䢽ힶⰘ㭎뵬䵡㋥ꇝ趙긲ཞ貯떆擫떵\\udd80\\uddd0᝟畞棩\\uddeb뿭꺌ݑ㙛貚\\ud826ᕝޏ뷂쁍掽\\udc3f鐝둛\\u0003쓤㴛살爀蕶헜꺫Ꮴꋓ튌뚡輡駙蓷焮壡㖊㖓쯕퍷悰ꮯ啂꾃뷃稜籃὇䞽׵篕㹟㙈埙畜ጚ耋픎懜䔃௕杯栭ෙ\\ud854３앏㧖㚛錂햁㄄偌囒搱⃋瀙㟏涬ॎ帱j্传ຄ\\udc1d\\ude4fₓ玟鍒䶆톸\\udf9d葍齬䓚鍀䊑㢛礓酶儻ᝡ叱瓦힛丽ᛙ靶工姥큗翝䕵맛፡颞펏罓籎廗꺠鎷딡㻤቏鷞쓋盡ㄽ䊓䩍ᄲꓨ錖蝠郷䀝婍ᘃꓱ궲༵㒈㆓潶䇘᮴ᷧ仱㭤ﶓ蹎℺鵋鎗퓽㐴쨓嗄㓤ા䴲㖊ⰳ㙍蓐俏ⱗ䭎酏㚃ᓬⁱ䰐޻厓ﺸ澒铃㹩从዗䟝﷦珕촅ኸå㭫ṓﻹ௑哵펌㎋\\ud934ᯙ\\udd3f衡絭㖩퓸속셍擖ꓕ僭ʥ錻隑셖㚪뵉극푟갍ﵫ婝捬毇튝娳숤쐥͘ቢஸઌ覂郕봶莄㶽랱㯟却ハ岳喝Ὠ捼絁鈟疽懴浒쬺刴ఋ㓚籽䕌謰桊hµ೟向빥䓓磎뷊皤\\udccc큓驵⬻퍮㓾㍟刈ᯖ絝ἶ᠆캄췓ሲ▧办ﱍ헊資㍰펹쳴ᇝ轴Ꮋ迮㻔ﯜ䞍ఁ齫紩㛿屟䬳쓌渴峥絽㐌풽ݎ΀扊㍊ᙌ퀄캴䔿㍽쀣僾稹능흣判䩅༰裧૵瀕䗀ࣙ䦉ϑꀄ♸ꭎ匚䌩栃恱矹璩㽱䍯બ漃頂Ỏ般끨᭱唿灈΃腐뢅͹࿬Ვᰏ쩒⥽왽༭籨෣嗭뮥΅㒈Ӄ⦕䰷쒏ﵯꗌ㊰쀃謍\\udcdfᑃ춉䔼푛∣呑悽䅎ମ埠뾰ﴔ嗫է䞂쀆⯏꜂㕲掑\\uded4辁୲짢ꣿ荪跪虧ᅒ誅훪꣡좜ꩰ뷾着\\udf63맄喝꧹ꀷ䉈ⱏࠄ鹍đ׋ᆣ⚌㚮벳ဢ㗑峡脣鈬칥\\udddc⹐塩빧뜺㓲፺㊮㜤틹橚䀧㵕暫\\uda9a嚽ᐲ\\ude31泟맯읹塐㮌ᴫ罭ꩭͲ㭈왵\\udae3複縠薊惵㴻깫⻙ⴑꆞꬳ᫉Ҳያ딅첾㘢㨍띵뗑욮෇芦躣羋黷퀜铸⵷㖧崮౫潙볻趴Ꚕ봪䇳俧㻉Ꙅ컐垵呀ꌫ嘺ࠥ灆ౄ㝰ᙈ閊톍銯䝛\\udd08㡌ୀ\\udd23䒀⿧帉䢞襌☓茧奋䪡ሒ㖌겲泠뇘诀㈖㼋쾃ꔌ款⵮圄겺ᆣ㜕㢪棰㳙豚㎏⚳혮፳ᕬ坬ᙣ岌씓᠅辳葘퀫嘮襉澿耱ኘ洵⍈㙂梪닭哎⽎ル䄵玌懒託謝⽉㊊ᾋꅙﯗᩰ땫¨ש᪍쎢틭뚸௝咳扌ஓ퓟遻ጨŭ丳썍펧癉㭊ﯓ坴뉀啣䯙㯴譋᤯걜㵻䬀䝍㮆ꤚ싫ꭐ溓ꨮ꭫努쎺狨ⓑዻ떓콋㹌\\udcebⓣ⯯됍৻䦍ຯ븿\\ude6c僟懤肩ɚ섁ϊ嵩닐⇯꣚燫䶙ﵑ펣콻\\udf9c팫䀵뀔眹᫤첞꣦㓠쑁⨶⍾䬠࢛㱻妳儮ꤹ틞⥅㇓䊳驴蜹싽਼Ꮠ帹慎᳛禝쏬좜䌄Ꜳ㙲▄慠疯쉎耣欏ꈖϪ즐ﺯ᫘趹䎔뭪쵚ʒ떓鄻⯧㆗Ꚏ櫖籆䲿爋奈赨ꇘ툫箂䃑琩è䋛䷭Ύ桚ﾖ\u003e뙟鐡쏀鰲餉䎀陿捈쁅แＪ嘆䅵⋻졪惒쒵ɚ᱒醢猆大惤홠솉Ż살돺맩窸镖輸擧삄讐䈅蹻䵂ꀏօ宁벁ꖒ홉夲䖵郎\\ud8bb此蜛琅\\ud902\\u0010룺炅藣ꁄ廏뮐낰쫃㦗傸鞣촅霖䡆쌒쑭⨰쒙᭓遑둰㔛ﬂ톰䃺㐃遗㲤䵤줃蹎㝌뤲撛寲䞀阚㣎䅸ᒎ຀騀泍皅菖Ⴓ䋾ఆᣡ吅萦簧ⷁ穀㌫⥗砎\\ud8b7腏䥍ᶳ즰〉揌엿ꚤ稚瞇㍦₾泝ꥦ⽴緂陡뚠䡸捺㩐湭ꨋ౴ꈀՓ믐섛뉮딌孀薬᩿혔珩␯ꙗ｛ᮒᙐ됀쉞‌냎ᑙ淾䖗꼐斓鰀肠謽聙ⲙഎ漎ﲡ묈╗ꪙ鋕䲦㞰\\ud99dᙝ駶ꕇⓎ䌀凋䕇ﳇ⚱ꉘ䤸뱩贏ꏉ輶ⳏ蒩饻⁁\\uda81ᨘ\\udb54\\ud96a삯⻠쌁醬耑셧䎴᥀ᇁｃ־ꦠ䮅봠籩쥌偋诶듳飫弹㸯町ɂ毁杹બ촤燄Љ콚੪꼂视鑙뵤쓕櫡殾敡\\ud8f2ㅙ뽯찗氥姪샕㞭檫愯㖘㙌躅삦葦᝙峌첎㭭断༌꣙䵂Ꮍᙔ\\ud977豝駭枚警꒝ﵗ䯾축꺧䕫甯伶㓞\\ud921搃끶ျ︀莽嫮눵ꓫ錎歱疤筛肕\\ud9d5㚦몭᳅Ꮑ\\udd5e率怏摷ㆀ䏣㟇隴᳢댙䰄낺\\udf3b櫍\\udf8c⻢뵪鸮\\ud86bඤ宰๺맖뷃㚹䟋쮿䐢묧䒫늎嫹Ꮵךּ嫻㯲쳫로\\udebbᔬ뫯뙿㬞⬃봖段컮뮼껃캅芣郵蛫⽤\\udb9b鍙ᚳ缛钒稇䛩촌渕댰稆閵饇ᭋ๕늰䥄ꤩ黫僙댦퍛Ḋ싓\\ud807ᳱ¸੘㞁๝Ზ\\ud89e冉裠ⰒԆ츌씑蚅韰ｸ蠃辴砯ꎫ臔젹楺뒨︃䳖늀芶룧䏯⋎牅뭺⌕凊曵廚檢靟䍞䜛榒⺍꜂㯨\\ude8a講豢熎榀扠祣죞䓗Ს柁唅㘳顳窊┻멂춪줏융연ᜩ嵏໬\\ude84콠益篺ኝ눣०靭ⴍ盨孷汯⒢換頞䲂⯯汒뇢ﳣ…邙ﻍḪ衶᫲壻뷤靯\\ude56噰聘㰏℀켤镯ꡥ噌ᾃ餼徠䬐됋\\ud91d뭳ज馬郀௬쓖擐䉜ᇨ䉃⾰㒖뉝⭵蓪ថ卄叭ᘛ愈ꋬ׾턠\\ud8cfʄ랈ߵᆰ攰靖퇬퍬毝ⶖ듏䗝累玼쇯䞢̡ﯣᙌ眦㻢㏜櫻邘䗞⻮ꀛ뮱뱗ꅠ개蠇܄ɻ뻕貳\\ud87a铼ꚇ㯻浸硶낗蜕奏먛변ᬀϟᇯ씄笼ኻ鄃뮹釳ᄾई篙ⅇᖭ뎾㥭溻囥탔І่閷ꔌ칝쀃쾻ꇯ蜒쾅㘈륇ℜ잻铣ﭽḖ੃ፇ⍁㌳틒㯽ⱗ팛緝ꚠᡰ倶䟆Ụ畡ꌝ⛮㇧⊓Ṕ烏ೇ嬞喓뇋䫺ʀ獏䉻뱅➸盩줧浚⦹⨋㗭蘃黯큞搭䉮웰虔Ⳉ卂\\udc85嗯킷囨怍浥뉬㍻䇡랴ꌩᤢ픱౺◢摪櫉㘊ﬣ톯봒귑ೄꢁ呆\\udb8b颩벂忹庡✤خ⯿ৱᆻے粅觗填Šඕᙔ頺龉瀋⟆輒偵䟱㋀鈂䙦\\udc59៘轾⼞ꞹ䨙\\udb44ḻⷘง띮\\uddaf侮鲄Ẹ೶층皶飂᩹ݎ땒뚡䏁\\udc87\u003c袼鷗Წ저둩續\u2028桜Ჸ稃涵䈀흇槰嶠㜲歡ᶨ췢Ľ𗪍츧␪鲃疜뉩꟔ȑऐꏄ梟᩺ᧈ₡곖뼽啉笓ࠏĦ䃟₺燌쉧Ḣ䴇ኧㅧ䌈ࢂ䪇⑺ꝛ䟚瀞햹䆜堌柌㠧䮭朞葳㇀膖鸂썩㈦㩻䀳Ꜳ➺琁ǰ爦♽䀲枦鹤쐹홧ꭂ蜋駆蒒ܬ횵꺜劝ꁾ⥼矨࿇ꅄᬇ䋨᫆敮鞶৲쏠剗띂\\udf1b畬湿廲溉䴼歛\\udd83떸샭둯ෙ取⧓츜啑侐ࣚᦐе᲎૑⨪₲끪䠳ⴚŽ怔‖\\udca5⒪滋未伥쮽抈裪隵䖹婗耦싛藞뺪牙쫗ꠁ燃梜픔髐ﲅ濬넚ः嚩ᔝ甥倿䇓鹀랠鿨ꦕᲪ뛠ษ산࿬惦ﭯ䕋䒲醶ྃ⚛쮏\\u001aඝƘ갯늒ồ଩盛䌈⩲␈孊鿝멛骧ᝯၹꧫ\\udbda鳎〙麧ﵶ㹦ힼ׍൅闏擦ꋍ敊홧這텋ﻭ풷粒ᝀ屙ᨎ혻堩됉祰뛴ퟛ嵃㪳櫂꭮귓岪좻碡㒸홖㶨ꂠǍ嚫ᦏᎸ嫴䭸ꀚ뚭梺᫔骿ꮉ尨\\udaaa햫ﲭ\\udedc㋧⋞囦ᕺᐥᦌ妳掺胦擊崸ኗ﮶ꌡ畱㼤⾰谎Ⳋ䜼ꉫ䮵ﰪ怃ᗽ㮸ࠦࣜ摋≍ᚵ旎셋፺ٞࡀ縩怉핿靡솵츐聕畼뗘ퟥ枥禝桋᚞拾ד︅헫曼뗎ꝑ鳥ߝ픨璵⠷Կ櫩뮂경㜪쮫紱꽯ힿ书熤堗ꎋ꓉哬㝳乎ᛵ⹍ꇟ隀\\uda9aĚ✝᙮׃畸幇꠰㑻㡦헝᫬ᰶ燀鮲શ岿旍Ό廷ụ㒮ͺꇐ츎繙큏嵷喩꾞㧵틇髮뮚㗧玙㘇댼龏嘍㝐屑煄ᓍ\\ude9e⟛쫶珨놌콓烟堁ᖸꬰꛣ㘊틣踜뀓ේ\\ude90࿥\\ud853붮㣇岔匩ꎸ쀠똬בּ껱枏辴牋ꆍ츞멹牁»尦훃榷鰷쏓髌赒庛㾳㦳賍୳忻툍\\udb3d坜஺헍갃ᶯ✼猽곕磣⃫증羆헙깧㚟姕啜୺꺫띚糸펇汷퍆㒓鞒ꮄ೴쪦䅼뺠睮┽竤틙쁙孰ꖘ꫍ꆾ粆홀ᾝ㥤ự\\udf41珍\\udaeb纟ⱼ釬瞢\\udd0e鉊缵쏻阍䁌ᥱ糹붛骓袸峂ֳ妨誀ఊ䒘⢨諝ꑠᚷ箲抻乚ķ툓⭽➧\\udc8aꗚ篤퉳ၜ㭑鯲怇池ﮏ⻂ⷠ⹮闏鍕鸰脝컠８♊뼐\\ud891\\u0004嶣뗥\\udc11셸◭劐\\ude84ᩩ悥⑺隸熀ꝅ聤໛誀퀖⪖鴕볺湠䟴仢렐퉾ᘋ壩䄷첸冀҃驪ቦ婘镦ἰ횟ꒉꭖ烲䔄膖뛠︀악煗\\ud8f3Ď๭♼쀄ﰂ괉阉喅⼍录牣榧Ò扫쀨訬ꈂ渋牑轵쉣魭ᙖꕁム抭颽闌̆丢풚揟ᕇ坨꜀썱鰉꼷郂୪መ峔ꎹ暦倖ἕ୲ㆢ鴁큈燶ꭢ쮼ᴃ樁歇②㶞鎺縹떂雠P篔࿠ಀ坂ᾌ\\udb29탢ʅЀ\\u0000\",\"actionData\",\"errors\"]\n");</script><!--$?--><template id="B:1"></template><!--/$--></div><script>$RB=[];$RV=function(a){$RT=performance.now();for(var b=0;b<a.length;b+=2){var c=a[b],e=a[b+1];null!==e.parentNode&&e.parentNode.removeChild(e);var f=c.parentNode;if(f){var g=c.previousSibling,h=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d||"/&"===d)if(0===h)break;else h--;else"$"!==d&&"$?"!==d&&"$~"!==d&&"$!"!==d&&"&"!==d||h++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;e.firstChild;)f.insertBefore(e.firstChild,c);g.data="$";g._reactRetry&&requestAnimationFrame(g._reactRetry)}}a.length=0};
$RC=function(a,b){if(b=document.getElementById(b))(a=document.getElementById(a))?(a.previousSibling.data="$~",$RB.push(a,b),2===$RB.length&&("number"!==typeof $RT?requestAnimationFrame($RV.bind(null,$RB)):(a=performance.now(),setTimeout($RV.bind(null,$RB),2300>a&&2E3<a?2300-a:$RT+300-a)))):b.parentNode.removeChild(b)};$RC("B:0","S:0")</script><div hidden id="S:1"><script>window.__reactRouterContext.streamController.close();</script></div><script>$RC("B:1","S:1")</script></body></html>