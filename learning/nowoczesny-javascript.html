<!DOCTYPE html><html lang="pl"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="modulepreload" href="/fetch.js"/><link rel="icon" href="/favicon.svg" sizes="any" type="image/svg+xml"/><link rel="preload" as="style" href="/assets/styles-CsCoTtlD.css"/><link rel="preload prefetch" href="/fonts/geist.ttf" as="font" type="font/ttf" crossorigin="anonymous"/><title>Renesans w JS, czyli nowoczesny JavaScript - Jakub Szpil</title><meta name="description" content="JavaScript jest językiem programowania, który jest powszechnie stosowany do tworzenia dynamicznych i interaktywnych stron internetowych. W ciągu ostatnich lat JavaScript znacznie ewoluował, wprowadzając nowe funkcje i poprawiając istniejące mechanizmy. W tym kursie omówimy najważniejsze elementy nowoczesnego JavaScript, w tym ES6 i nowsze."/><meta name="keywords" content="javascript,kurs,wprowadzenie,przewodnik,web,frontend,learning"/><meta property="article:published_time" content="2024-06-30T00:00:00.000Z"/><meta property="og:type" content="article"/><meta property="og:url" content="https://jakubszpil.github.io/learning/nowoczesny-javascript/"/><meta property="og:title" content="Renesans w JS, czyli nowoczesny JavaScript - Jakub Szpil"/><meta property="og:description" content="JavaScript jest językiem programowania, który jest powszechnie stosowany do tworzenia dynamicznych i interaktywnych stron internetowych. W ciągu ostatnich lat JavaScript znacznie ewoluował, wprowadzając nowe funkcje i poprawiając istniejące mechanizmy. W tym kursie omówimy najważniejsze elementy nowoczesnego JavaScript, w tym ES6 i nowsze."/><meta property="twitter:card" content="summary_large_image"/><meta property="twitter:url" content="https://jakubszpil.github.io/learning/nowoczesny-javascript/"/><meta property="twitter:title" content="Renesans w JS, czyli nowoczesny JavaScript - Jakub Szpil"/><meta property="twitter:description" content="JavaScript jest językiem programowania, który jest powszechnie stosowany do tworzenia dynamicznych i interaktywnych stron internetowych. W ciągu ostatnich lat JavaScript znacznie ewoluował, wprowadzając nowe funkcje i poprawiając istniejące mechanizmy. W tym kursie omówimy najważniejsze elementy nowoczesnego JavaScript, w tym ES6 i nowsze."/><link rel="modulepreload" href="/assets/manifest-095568ab.js"/><link rel="modulepreload" href="/assets/entry.client-D07Jc1yP.js"/><link rel="modulepreload" href="/assets/jsx-runtime-D_zvdyIk.js"/><link rel="modulepreload" href="/assets/chunk-OIYGIGL5-Rdhby1S0.js"/><link rel="modulepreload" href="/assets/index-DJQXGD61.js"/><link rel="modulepreload" href="/assets/root-CWpT0Luk.js"/><link rel="modulepreload" href="/assets/layout-DTSVQAyN.js"/><link rel="modulepreload" href="/assets/button-BMGgmMxT.js"/><link rel="modulepreload" href="/assets/link-with-prefetch-DYt-PuIQ.js"/><link rel="modulepreload" href="/assets/icons-BBGQWBin.js"/><link rel="modulepreload" href="/assets/socials-DGthjeXP.js"/><link rel="modulepreload" href="/assets/date-NK96Yl5Q.js"/><link rel="modulepreload" href="/assets/not-found-BbFjFHzP.js"/><link rel="modulepreload" href="/assets/seo-Do91G143.js"/><link rel="modulepreload" href="/assets/course-details-Cekl_zRU.js"/><link rel="modulepreload" href="/assets/categories-BnZHVW1j.js"/><link rel="modulepreload" href="/assets/edit-resource-Bp0MeTOm.js"/><link rel="modulepreload" href="/assets/banner-DCe0eTPI.js"/><link rel="modulepreload" href="/assets/compress-rTcoN3WF.js"/><link rel="modulepreload" href="/assets/creation-date-x1jkwlYO.js"/><link rel="stylesheet" href="/assets/styles-CsCoTtlD.css"/><script>globalThis.timestamp=1761401428685</script><script>let k="theme";let t="dark";let s=localStorage;let c=document.documentElement.classList;let v=s.getItem(k);if(v===null||v==="SYSTEM")matchMedia("(prefers-color-scheme:dark)").matches?c.add(t):c.remove(t);else if(v==="DARK")c.add(t);else if(v==="LIGHT")c.remove(t);else s.removeItem(k);</script><script type="module" src="/fetch.js"></script></head><body style="-webkit-tap-highlight-color:transparent"><header class="sticky w-full bg-background top-0 left-0 z-50 border-b"><div class="container pb-3! pt-4! px-3! flex justify-between items-center"><a data-slot="button" class="button button--variant-ghost button--size-sm font-bold" href="/" data-discover="true">jakubszpil</a><div class="flex flex-1 justify-end items-center sm:gap-1"><nav class="hidden items-center lg:flex"><a data-slot="button" class="button button--variant-ghost button--size-sm" href="/" data-discover="true">🏠 Strona główna</a><a data-slot="button" class="button button--variant-ghost button--size-sm" href="/blog" data-discover="true">📝 Blog</a><a data-slot="button" class="button button--variant-ghost button--size-sm" href="/learning" data-discover="true">🏫 Learning</a><a data-slot="button" class="button button--variant-ghost button--size-sm" href="/portfolio" data-discover="true">🛠️ Portfolio</a><a data-slot="button" class="button button--variant-ghost button--size-sm" href="/me" data-discover="true">🙋‍♂️ O mnie</a></nav><a data-slot="button" class="button button--variant-ghost button--size-icon inline-flex items-center justify-center" aria-label="Szukaj" title="Szukaj (CTRL+K)" href="/search" data-discover="true"><span class="sr-only">Szukaj</span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="size-6"><path d="M10 10m-7 0a7 7 0 1 0 14 0a7 7 0 1 0 -14 0"></path><path d="M21 21l-6 -6"></path></svg></a><div class="hidden xs:flex items-center sm:gap-1"><a href="https://www.linkedin.com/in/jakubszpil/" target="_blank" rel="noreferrer" data-slot="button" class="button button--variant-ghost button--size-icon inline-flex items-center gap-1 no-underline" title="LinkedIn" aria-label="LinkedIn"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="size-6"><path d="M8 11v5"></path><path d="M8 8v.01"></path><path d="M12 16v-5"></path><path d="M16 16v-3a2 2 0 1 0 -4 0"></path><path d="M3 7a4 4 0 0 1 4 -4h10a4 4 0 0 1 4 4v10a4 4 0 0 1 -4 4h-10a4 4 0 0 1 -4 -4z"></path></svg><span class="sr-only">LinkedIn</span></a><a href="https://github.com/jakubszpil/" target="_blank" rel="noreferrer" data-slot="button" class="button button--variant-ghost button--size-icon inline-flex items-center gap-1 no-underline" title="GitHub" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="size-6"><path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5"></path></svg><span class="sr-only">GitHub</span></a></div><button data-slot="dropdown-menu-trigger" class="button button--variant-ghost button--size-icon cursor-pointer" title="Zmień motyw" type="button" id="radix-_R_4ej5_" aria-haspopup="menu" aria-expanded="false" data-state="closed"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="size-6"><path d="M9.173 14.83a4 4 0 1 1 5.657 -5.657"></path><path d="M11.294 12.707l.174 .247a7.5 7.5 0 0 0 8.845 2.492a9 9 0 0 1 -14.671 2.914"></path><path d="M3 12h1"></path><path d="M12 3v1"></path><path d="M5.6 5.6l.7 .7"></path><path d="M3 21l18 -18"></path></svg></button><button data-slot="button" class="button button--variant-link button--size-icon inline-flex items-center justify-center relative z-50 lg:hidden" aria-label="Otwórz menu"><span class="sr-only">Otwórz menu</span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="size-6 text-black! dark:text-white!"><path d="M4 6l16 0"></path><path d="M4 12l16 0"></path><path d="M4 18l16 0"></path></svg></button></div></div></header><main><header class="prose container"><h1 class="mb-5">Renesans w JS, czyli nowoczesny JavaScript</h1><div class="text-xs sm:text-sm my-6"><div class="inline-block" title="Data opublikowania"><span class="mr-0.5">📆</span><span class="hidden">Data opublikowania:</span><time>30 czerwca 2024</time></div><span class="ml-2 mr-1">/</span><div class="inline-block sm:inline" title="Czas potrzebny na przeczytanie"><span class="mr-0.5">⌛</span><span class="hidden">Czas potrzebny na przeczytanie:</span>18 minut<!-- --> czytania</div></div><div class="flex items-center gap-3 flex-wrap"><a data-slot="button" class="button button--variant-secondary button--size-sm no-underline!" href="/learning/kategorie/javascript" data-discover="true">JavaScript</a></div></header><article class="prose container pt-0 prose-emerald"><p>Witaj w świecie <strong>nowoczesnego JavaScriptu</strong>! 🚀 Jeśli HTML to szkielet strony, a CSS to jej wygląd, to JavaScript jest sercem i mózgiem - sprawia, że strona ożywa, staje się interaktywna i dynamiczna. W ciągu ostatnich lat JavaScript przeszedł prawdziwy "renesans". Dzięki wprowadzeniu standardu <strong>ES6</strong> (ECMAScript 2015) i kolejnych aktualizacji, pisanie kodu w JS stało się znacznie przyjemniejsze, bezpieczniejsze i bardziej efektywne.</p>
<p>Ten przewodnik zabierze Cię w podróż po najważniejszych nowościach, które musisz znać, aby pisać <strong>nowoczesny JavaScript</strong>. Nie martw się, jeśli jesteś początkujący/a - wszystko wyjaśnimy krok po kroku, z przykładami i analogiami, byś mógł/mogła od razu zastosować nową wiedzę w praktyce. Czas unowocześnić swoje umiejętności! ✨</p>
<h2 id="spis-treści" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#spis-treści">>></a>Spis treści</h2>
<ol>
<li><a href="#zmienne-let-const-i-zakresy-blokowe--po%C5%BCegnanie-z-var">Zmienne: <code>let</code>, <code>const</code> i zakresy blokowe - pożegnanie z <code>var</code>?</a></li>
<li><a href="#funkcje-strza%C5%82kowe-arrow-functions-i-ich-zastosowania--kr%C3%B3cej-i-czytelniej">Funkcje strzałkowe (Arrow Functions) i ich zastosowania - krócej i czytelniej</a></li>
<li><a href="#szablony-string%C3%B3w-template-literals--%C5%82atwiejsza-praca-z-tekstem">Szablony stringów (Template Literals) - łatwiejsza praca z tekstem</a></li>
<li><a href="#destrukturyzacja-tablic-i-obiekt%C3%B3w--wyci%C4%85gnij-to-czego-potrzebujesz">Destrukturyzacja tablic i obiektów - wyciągnij to, czego potrzebujesz</a></li>
<li><a href="#spread-i-rest-operator---elastyczno%C5%9B%C4%87-w-manipulacji-danymi">Spread i Rest Operator (<code>...</code>) - elastyczność w manipulacji danymi</a></li>
<li><a href="#promise-api-i-obs%C5%82uga-asynchroniczno%C5%9Bci--opowiadaj-historie-o-przysz%C5%82o%C5%9Bci">Promise API i obsługa asynchroniczności - opowiadaj historie o przyszłości</a></li>
<li><a href="#asyncawait--nowoczesna-obs%C5%82uga-kodu-asynchronicznego--pisz-asynchronicznie-my%C5%9Bl-synchronicznie">Async/await - nowoczesna obsługa kodu asynchronicznego - pisz asynchronicznie, myśl synchronicznie</a></li>
<li><a href="#zadania-do-wykonania-sprawd%C5%BA-swoj%C4%85-wiedz%C4%99">Zadania do wykonania: Sprawdź swoją wiedzę!</a></li>
</ol>
<hr>
<h2 id="zmienne-let-const-i-zakresy-blokowe---pożegnanie-z-var" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#zmienne-let-const-i-zakresy-blokowe---pożegnanie-z-var">>></a>Zmienne: <code>let</code>, <code>const</code> i zakresy blokowe - pożegnanie z <code>var</code>?</h2>
<p>W starszych wersjach JavaScriptu zmienne deklarowaliśmy wyłącznie za pomocą słowa kluczowego <code>var</code>. Często prowadziło to do pomyłek i trudnych do wykrycia błędów. Nowoczesny JavaScript wprowadza dwa nowe sposoby deklarowania zmiennych: <strong><code>let</code></strong> i <strong><code>const</code></strong>, które znacznie poprawiają bezpieczeństwo i przewidywalność kodu.</p>
<h3 id="zakres-blokowy-block-scope" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#zakres-blokowy-block-scope">>>></a>Zakres blokowy (<code>block scope</code>)</h3>
<p>To kluczowa różnica! Zmienne zadeklarowane za pomocą <code>let</code> i <code>const</code> mają <strong>zakres blokowy</strong>. Co to znaczy? Oznaczają, że zmienna istnieje tylko w obrębie najbliższego <strong>bloku kodu</strong>, czyli wszystko, co znajduje się między klamrowymi nawiasami <code>{ ... }</code>.</p>
<p>Pomyśl o tym jak o specjalnej, prywatnej przestrzeni. Jeśli zmienna <code>x</code> jest zadeklarowana wewnątrz bloku <code>if</code>, będzie dostępna tylko w tym bloku. Próba użycia jej poza nim spowoduje błąd. To chroni Cię przed przypadkowym nadpisaniem zmiennych o tej samej nazwie w innej części kodu.</p>
<p><strong>Przykład:</strong></p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) {
  <span class="hljs-keyword">let</span> x = <span class="hljs-number">5</span>; <span class="hljs-comment">// x istnieje tylko wewnątrz tego bloku if</span>
  <span class="hljs-keyword">const</span> y = <span class="hljs-number">10</span>; <span class="hljs-comment">// y również istnieje tylko wewnątrz tego bloku</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x); <span class="hljs-comment">// Wyświetli: 5 (dostępne, bo jesteśmy w bloku)</span>
}
<span class="hljs-comment">// console.log(x); // WYWOŁA BŁĄD! ReferenceError: x is not defined</span>
<span class="hljs-comment">// console.log(y); // WYWOŁA BŁĄD! ReferenceError: y is not defined</span>
</code></pre>
<p>Dla porównania, <code>var</code> ma <strong>zakres funkcyjny</strong> (function scope), co oznacza, że zmienna zadeklarowana w funkcji jest dostępna w całej funkcji, ale poza funkcją jest dostępna globalnie, co jest źródłem wielu problemów. Dlatego w nowoczesnym kodzie <strong>zdecydowanie unikamy <code>var</code></strong>.</p>
<h3 id="różnice-między-let-const-i-var" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#różnice-między-let-const-i-var">>>></a>Różnice między <code>let</code>, <code>const</code> i <code>var</code></h3>
<ul>
<li>
<p><strong><code>let</code></strong>:</p>
<ul>
<li><strong>Deklaruje zmienną</strong>, której wartość może być <strong>zmieniana</strong> w dowolnym momencie.</li>
<li>Ma <strong>zakres blokowy</strong>.</li>
<li>Nie można jej ponownie zadeklarować w tym samym bloku (np. <code>let x = 5; let x = 10;</code> to błąd), ale można zmienić jej wartość (<code>x = 10;</code>).</li>
<li>Używaj <code>let</code>, gdy wiesz, że wartość zmiennej będzie się zmieniać (np. licznik w pętli).</li>
</ul>
</li>
<li>
<p><strong><code>const</code></strong>:</p>
<ul>
<li>Deklaruje <strong>stałą</strong>, której wartość musi być <strong>przypisana od razu</strong> i <strong>nie może być zmieniana</strong> później.</li>
<li>Ma <strong>zakres blokowy</strong>.</li>
<li>Jeśli przypiszesz do <code>const</code> obiekt lub tablicę, nie możesz przypisać do niej <em>nowego</em> obiektu/tablicy, ale możesz <strong>modyfikować zawartość</strong> tego obiektu/tablicy (np. dodawać lub usuwać elementy). <code>const</code> gwarantuje, że referencja (wskaźnik) do obiektu pozostaje taka sama, ale nie "zamraża" samego obiektu.</li>
<li>Używaj <code>const</code>, gdy wartość zmiennej nie powinna się zmieniać. To jest domyślny wybór w nowoczesnym JS, chyba że potrzebujesz <code>let</code>.</li>
</ul>
</li>
<li>
<p><strong><code>var</code></strong>:</p>
<ul>
<li><strong>Ma zakres funkcyjny</strong> (lub globalny, jeśli jest poza funkcją).</li>
<li>Jest podatny na <strong>hoisting</strong> (podnoszenie deklaracji), co oznacza, że deklaracja zmiennej jest "przenoszona" na początek zakresu, co może prowadzić do nieintuicyjnych zachowań.</li>
<li>Można go <strong>wielokrotnie deklarować</strong> w tym samym zakresie, co łatwo prowadzi do przypadkowych nadpisań.</li>
<li><strong>Unikaj używania <code>var</code> w nowym kodzie!</strong></li>
</ul>
</li>
</ul>
<p><strong>Przykład <code>const</code> z obiektem/tablicą:</strong></p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> tablica = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
tablica.<span class="hljs-title function_">push</span>(<span class="hljs-number">4</span>); <span class="hljs-comment">// DOZWOLONE! Zmieniamy zawartość tablicy, nie przypisujemy nowej tablicy.</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(tablica); <span class="hljs-comment">// Wyświetli: [1, 2, 3, 4]</span>

<span class="hljs-comment">// tablica = [5, 6]; // WYWOŁA BŁĄD! TypeError: Assignment to constant variable.</span>
<span class="hljs-comment">// Próbujesz przypisać zupełnie nową tablicę do stałej referencji.</span>

<span class="hljs-keyword">const</span> osoba = { <span class="hljs-attr">imie</span>: <span class="hljs-string">"Anna"</span>, <span class="hljs-attr">wiek</span>: <span class="hljs-number">28</span> };
osoba.<span class="hljs-property">wiek</span> = <span class="hljs-number">29</span>; <span class="hljs-comment">// DOZWOLONE! Zmieniamy właściwość obiektu, nie przypisujemy nowego obiektu.</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(osoba); <span class="hljs-comment">// Wyświetli: { imie: "Anna", wiek: 29 }</span>

<span class="hljs-comment">// osoba = { nazwisko: "Nowak" }; // WYWOŁA BŁĄD!</span>
</code></pre>
<hr>
<h2 id="funkcje-strzałkowe-arrow-functions-i-ich-zastosowania---krócej-i-czytelniej" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#funkcje-strzałkowe-arrow-functions-i-ich-zastosowania---krócej-i-czytelniej">>></a>Funkcje strzałkowe (Arrow Functions) i ich zastosowania - krócej i czytelniej</h2>
<p>Funkcje strzałkowe to zwięzła alternatywa dla tradycyjnych funkcji JavaScript, która została wprowadzona w ES6. Są nie tylko krótsze, ale także rozwiązują pewien problem z kontekstem <code>this</code>, który często mylił początkujących programistów.</p>
<h3 id="składnia-funkcji-strzałkowej" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#składnia-funkcji-strzałkowej">>>></a>Składnia funkcji strzałkowej</h3>
<p>Największą zaletą funkcji strzałkowych jest ich zwięzła składnia, zwłaszcza dla prostych funkcji.</p>
<ul>
<li>
<p><strong>Szybszy zapis (szczególnie dla funkcji jedno-liniowych):</strong>
Jeśli funkcja składa się tylko z jednej instrukcji, która zwraca wartość, możesz pominąć nawiasy klamrowe <code>{}</code> i słowo kluczowe <code>return</code>.</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// Tradycyjna funkcja</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">dodajStara</span>(<span class="hljs-params">a, b</span>) {
  <span class="hljs-keyword">return</span> a + b;
}

<span class="hljs-comment">// Funkcja strzałkowa (krótszy zapis)</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">dodaj</span> = (<span class="hljs-params">a, b</span>) => a + b;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">dodaj</span>(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">// Wyświetli: 8</span>

<span class="hljs-comment">// Funkcja z jednym argumentem (można pominąć nawiasy wokół argumentu)</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">powitanie</span> = (<span class="hljs-params">imie</span>) => <span class="hljs-string">`Cześć, <span class="hljs-subst">${imie}</span>!`</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">powitanie</span>(<span class="hljs-string">"Ola"</span>)); <span class="hljs-comment">// Wyświetli: Cześć, Ola!</span>

<span class="hljs-comment">// Funkcja bez argumentów (konieczne puste nawiasy)</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">powiedzHello</span> = (<span class="hljs-params"></span>) => <span class="hljs-string">"Hello!"</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">powiedzHello</span>()); <span class="hljs-comment">// Wyświetli: Hello!</span>
</code></pre>
</li>
<li>
<p><strong>Brak własnego obiektu <code>arguments</code>:</strong> Funkcje strzałkowe nie mają własnego obiektu <code>arguments</code> (który zawiera wszystkie argumenty przekazane do funkcji). Jeśli go potrzebujesz, użyj <strong>rest operatora</strong> (<code>...</code>), o którym powiemy później.</p>
</li>
<li>
<p><strong>Brak możliwości użycia jako konstruktor:</strong> Nie możesz użyć funkcji strzałkowej do tworzenia nowych obiektów za pomocą słowa kluczowego <code>new</code>.</p>
</li>
</ul>
<h3 id="funkcje-strzałkowe-a-kontekst-this" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#funkcje-strzałkowe-a-kontekst-this">>>></a>Funkcje strzałkowe a kontekst <code>this</code></h3>
<p>To jest jeden z najważniejszych powodów, dla których wprowadzono funkcje strzałkowe. W tradycyjnych funkcjach, wartość <code>this</code> zależy od tego, jak funkcja jest wywoływana. To prowadziło do częstych błędów, zwłaszcza w callbackach (funkcjach wywoływanych przez inne funkcje, np. w <code>setTimeout</code> czy w obsłudze zdarzeń).</p>
<p>Funkcje strzałkowe rozwiązują ten problem: <strong>nie mają własnego <code>this</code></strong>. Zamiast tego, <strong>dziedziczą <code>this</code> z otoczenia, w którym zostały zadeklarowane</strong> (tzw. leksykalny <code>this</code>).</p>
<p><strong>Przykład problemu ze <code>this</code> w tradycyjnych funkcjach:</strong></p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// Tradycyjna funkcja, która "gubi" kontekst this</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">TimerProblem</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">sekundy</span> = <span class="hljs-number">0</span>;
  <span class="hljs-built_in">setInterval</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-comment">// Tutaj 'this' nie odnosi się do obiektu TimerProblem,</span>
    <span class="hljs-comment">// ale do obiektu globalnego (np. window w przeglądarce) lub jest undefined w trybie 'strict mode'</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">sekundy</span>++; <span class="hljs-comment">// To nie zadziała tak, jak byśmy chcieli!</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">sekundy</span>);
  }, <span class="hljs-number">1000</span>);
}
<span class="hljs-comment">// new TimerProblem(); // W konsoli prawdopodobnie zobaczysz NaN lub błąd</span>
</code></pre>
<p><strong>Rozwiązanie z funkcją strzałkową:</strong></p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">TimerPoprawny</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">sekundy</span> = <span class="hljs-number">0</span>;
  <span class="hljs-comment">// Funkcja strzałkowa dziedziczy 'this' z TimerPoprawny (czyli z obiektu TimerPoprawny)</span>
  <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">sekundy</span>++;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Sekundy: <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.sekundy}</span>`</span>);
  }, <span class="hljs-number">1000</span>);
}
<span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerPoprawny</span>(); <span class="hljs-comment">// Będzie poprawnie liczyć sekundy: Sekundy: 1, Sekundy: 2, itd.</span>
</code></pre>
<p>Dzięki temu funkcje strzałkowe są idealne do użycia w callbackach, metodach obiektów (choć nie jako metody obiektów najwyższego poziomu, bo wtedy <code>this</code> wskazałoby na <code>window</code>), czy w sytuacjach, gdzie chcesz, aby <code>this</code> zachowało kontekst nadrzędny.</p>
<hr>
<h2 id="szablony-stringów-template-literals---łatwiejsza-praca-z-tekstem" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#szablony-stringów-template-literals---łatwiejsza-praca-z-tekstem">>></a>Szablony stringów (Template Literals) - łatwiejsza praca z tekstem</h2>
<p>Szablony stringów, wprowadzone w ES6, to potężne narzędzie do tworzenia ciągów znaków (stringów). Zastępują tradycyjne łączenie stringów za pomocą operatora <code>+</code> i oferują znacznie większą elastyczność i czytelność. Używamy ich, otaczając tekst <strong>backtickami</strong> (apostrofami wstecznymi) <code> </code> zamiast pojedynczych lub podwójnych cudzysłowów.</p>
<h3 id="interpolacja-i-wielolinijkowość" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#interpolacja-i-wielolinijkowość">>>></a>Interpolacja i wielolinijkowość</h3>
<ul>
<li>
<p><strong>Interpolacja zmiennych i wyrażeń:</strong>
Możesz łatwo osadzać zmienne lub dowolne wyrażenia JavaScript bezpośrednio w stringu, używając składni <code>${...}</code>. To znacznie ułatwia budowanie dynamicznych komunikatów.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> imie = <span class="hljs-string">"Alicja"</span>;
<span class="hljs-keyword">const</span> wiek = <span class="hljs-number">30</span>;

<span class="hljs-comment">// Stary sposób: męczące łączenie stringów</span>
<span class="hljs-keyword">const</span> infoStare = <span class="hljs-string">"Mam na imię "</span> + imie + <span class="hljs-string">" i mam "</span> + wiek + <span class="hljs-string">" lat."</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(infoStare); <span class="hljs-comment">// Wyświetli: Mam na imię Alicja i mam 30 lat.</span>

<span class="hljs-comment">// Nowy sposób z szablonami stringów: czytelniej i prościej!</span>
<span class="hljs-keyword">const</span> infoNowe = <span class="hljs-string">`Mam na imię <span class="hljs-subst">${imie}</span> i mam <span class="hljs-subst">${wiek}</span> lat.`</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(infoNowe); <span class="hljs-comment">// Wyświetli: Mam na imię Alicja i mam 30 lat.</span>

<span class="hljs-comment">// Możesz umieszczać dowolne wyrażenia JavaScript:</span>
<span class="hljs-keyword">const</span> cena = <span class="hljs-number">10.5</span>;
<span class="hljs-keyword">const</span> ilosc = <span class="hljs-number">2</span>;
<span class="hljs-keyword">const</span> rachunek = <span class="hljs-string">`Koszt zakupu: <span class="hljs-subst">${cena * ilosc}</span> zł.`</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(rachunek); <span class="hljs-comment">// Wyświetli: Koszt zakupu: 21 zł.</span>
</code></pre>
</li>
<li>
<p><strong>Łatwe tworzenie tekstów wielolinijkowych:</strong>
Koniec z dodawaniem <code>n</code> do każdej linii! W szablonach stringów możesz po prostu nacisnąć Enter, a tekst zachowa formatowanie z nowymi liniami. Jest to szczególnie przydatne przy generowaniu fragmentów HTML bezpośrednio w JavaScript.</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// Stary sposób: brzydkie i niewygodne</span>
<span class="hljs-keyword">const</span> htmlStare =
  <span class="hljs-string">"&#x3C;div>\n  &#x3C;h1>Witaj!&#x3C;/h1>\n  &#x3C;p>To jest wielolinijkowy tekst.&#x3C;/p>\n&#x3C;/div>"</span>;

<span class="hljs-comment">// Nowy sposób: super czytelne!</span>
<span class="hljs-keyword">const</span> htmlNowe = <span class="hljs-string">`
  &#x3C;div>
    &#x3C;h1>Witaj!&#x3C;/h1>
    &#x3C;p>To jest wielolinijkowy tekst. I kolejna linia w tym samym akapicie.&#x3C;/p>
  &#x3C;/div>
`</span>;

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(htmlNowe);
</code></pre>
</li>
</ul>
<h3 id="dodatkowe-możliwości" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#dodatkowe-możliwości">>>></a>Dodatkowe możliwości</h3>
<p>Szablony stringów wspierają także tzw. <strong>tagowane szablony</strong> (<code>tagged templates</code>), które pozwalają na zaawansowaną manipulację tekstem przed jego finalnym utworzeniem. Możesz zdefiniować funkcję ("tag"), która będzie przetwarzać części stringu i wartości zmiennych. Jest to bardziej zaawansowana funkcja, używana np. do tłumaczeń, walidacji, bezpiecznego generowania HTML (zapobieganie XSS) czy formatowania danych.</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// Przykład funkcji "tagującej"</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">upper</span>(<span class="hljs-params">strings, ...values</span>) {
  <span class="hljs-comment">// 'strings' to tablica tekstów, 'values' to tablica zmiennych</span>
  <span class="hljs-keyword">let</span> wynik = strings[<span class="hljs-number">0</span>];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &#x3C; values.<span class="hljs-property">length</span>; i++) {
    wynik += values[i].<span class="hljs-title function_">toUpperCase</span>() + strings[i + <span class="hljs-number">1</span>]; <span class="hljs-comment">// Zamienia zmienne na duże litery</span>
  }
  <span class="hljs-keyword">return</span> wynik;
}

<span class="hljs-keyword">const</span> imie = <span class="hljs-string">"Kasia"</span>;
<span class="hljs-keyword">const</span> wiek = <span class="hljs-number">20</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(upper<span class="hljs-string">`Cześć, <span class="hljs-subst">${imie}</span>! Masz <span class="hljs-subst">${wiek}</span> lat?`</span>); <span class="hljs-comment">// Wyświetli: Cześć, KASIA! Masz 20 lat?</span>
</code></pre>
<p>W tym przykładzie funkcja <code>upper</code> została "przypięta" do szablonu stringu i zmodyfikowała zmienną <code>imie</code> na wielkie litery.</p>
<hr>
<h2 id="destrukturyzacja-tablic-i-obiektów---wyciągnij-to-czego-potrzebujesz" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#destrukturyzacja-tablic-i-obiektów---wyciągnij-to-czego-potrzebujesz">>></a>Destrukturyzacja tablic i obiektów - wyciągnij to, czego potrzebujesz</h2>
<p>Destrukturyzacja to potężna i bardzo często używana funkcja w nowoczesnym JavaScript. Pozwala na "rozpakowanie" wartości z tablic lub właściwości z obiektów do oddzielnych zmiennych w bardzo zwięzły i czytelny sposób. Upraszcza kod i czyni go bardziej deklaratywnym.</p>
<h3 id="destrukturyzacja-tablic" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#destrukturyzacja-tablic">>>></a>Destrukturyzacja tablic</h3>
<p>Pozwala na szybkie przypisanie wartości z tablicy do zmiennych, bazując na ich pozycji.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> kolory = [<span class="hljs-string">"czerwony"</span>, <span class="hljs-string">"zielony"</span>, <span class="hljs-string">"niebieski"</span>];

<span class="hljs-comment">// Stary sposób:</span>
<span class="hljs-comment">// const kolor1 = kolory[0];</span>
<span class="hljs-comment">// const kolor2 = kolory[1];</span>

<span class="hljs-comment">// Nowy sposób z destrukturyzacją tablic:</span>
<span class="hljs-keyword">const</span> [pierwszyKolor, drugiKolor, trzeciKolor] = kolory;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pierwszyKolor); <span class="hljs-comment">// Wyświetli: czerwony</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(drugiKolor); <span class="hljs-comment">// Wyświetli: zielony</span>

<span class="hljs-comment">// Można pomijać niektóre elementy (używając przecinków):</span>
<span class="hljs-keyword">const</span> [a, , b] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]; <span class="hljs-comment">// Pomijamy drugi element (2)</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a, b); <span class="hljs-comment">// Wyświetli: 1 3</span>

<span class="hljs-comment">// Można przypisać wartości domyślne, jeśli element nie istnieje:</span>
<span class="hljs-keyword">const</span> [x, y, z = <span class="hljs-string">"domyślny"</span>] = [<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x, y, z); <span class="hljs-comment">// Wyświetli: A B domyślny</span>

<span class="hljs-comment">// Można zbierać pozostałe elementy do nowej tablicy (rest operator - patrz dalej):</span>
<span class="hljs-keyword">const</span> [pierwszy, ...resztaKolorow] = kolory;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pierwszy); <span class="hljs-comment">// Wyświetli: czerwony</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(resztaKolorow); <span class="hljs-comment">// Wyświetli: ["zielony", "niebieski"]</span>
</code></pre>
<h3 id="destrukturyzacja-obiektów" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#destrukturyzacja-obiektów">>>></a>Destrukturyzacja obiektów</h3>
<p>Pozwala na przypisanie wartości z obiektu do zmiennych na podstawie nazw ich <strong>kluczy (właściwości)</strong>. Kolejność nie ma znaczenia, liczy się nazwa klucza.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> samochod = { <span class="hljs-attr">marka</span>: <span class="hljs-string">"Ford"</span>, <span class="hljs-attr">model</span>: <span class="hljs-string">"Focus"</span>, <span class="hljs-attr">rok</span>: <span class="hljs-number">2018</span> };

<span class="hljs-comment">// Stary sposób:</span>
<span class="hljs-comment">// const markaSamochodu = samochod.marka;</span>
<span class="hljs-comment">// const modelSamochodu = samochod.model;</span>

<span class="hljs-comment">// Nowy sposób z destrukturyzacją obiektów:</span>
<span class="hljs-keyword">const</span> { marka, model } = samochod;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(marka); <span class="hljs-comment">// Wyświetli: Ford</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(model); <span class="hljs-comment">// Wyświetli: Focus</span>

<span class="hljs-comment">// Można przypisać wartości domyślne, jeśli właściwość nie istnieje:</span>
<span class="hljs-keyword">const</span> { <span class="hljs-attr">marka</span>: m, kolor = <span class="hljs-string">"czarny"</span> } = samochod; <span class="hljs-comment">// 'kolor' nie istnieje w obiekcie 'samochod'</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(m, kolor); <span class="hljs-comment">// Wyświetli: Ford czarny</span>

<span class="hljs-comment">// Można zmienić nazwę zmiennej, do której przypisujemy wartość:</span>
<span class="hljs-keyword">const</span> { <span class="hljs-attr">marka</span>: nazwaMarki, <span class="hljs-attr">model</span>: typModelu } = samochod;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(nazwaMarki, typModelu); <span class="hljs-comment">// Wyświetli: Ford Focus</span>

<span class="hljs-comment">// Można też zbierać pozostałe właściwości do nowego obiektu (rest operator - patrz dalej):</span>
<span class="hljs-keyword">const</span> { rok, ...resztaSamochodu } = samochod;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(rok); <span class="hljs-comment">// Wyświetli: 2018</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(resztaSamochodu); <span class="hljs-comment">// Wyświetli: { marka: "Ford", model: "Focus" }</span>
</code></pre>
<p>Destrukturyzacja jest szczególnie przydatna w funkcjach, gdy chcesz łatwo wyciągnąć konkretne dane z obiektów konfiguracyjnych lub z wyników API.</p>
<hr>
<h2 id="spread-i-rest-operator----elastyczność-w-manipulacji-danymi" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#spread-i-rest-operator----elastyczność-w-manipulacji-danymi">>></a>Spread i Rest Operator (<code>...</code>) - elastyczność w manipulacji danymi</h2>
<p>Operator <code>...</code> (trzy kropki) jest jednym z najbardziej uniwersalnych i potężnych narzędzi w nowoczesnym JavaScript. Nazywany jest <strong>operatorem spread</strong> lub <strong>operatorem rest</strong>, w zależności od kontekstu, w jakim jest używany.</p>
<h3 id="spread-operator-operator-rozproszenia" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#spread-operator-operator-rozproszenia">>>></a>Spread Operator (operator rozproszenia)</h3>
<p>Gdy używasz <code>...</code> do <strong>rozbicia</strong> elementów tablicy lub właściwości obiektu na pojedyncze elementy, mówimy o <strong>operatorze spread</strong>. Jest to jak "rozłożenie" zawartości kolekcji. 🌐</p>
<p><strong>Zastosowania Spread Operatora:</strong></p>
<ul>
<li>
<p><strong>Kopiowanie i łączenie tablic:</strong> Tworzenie płytkich kopii tablic lub łączenie ich bez modyfikowania oryginalnych.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> cyfry = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-keyword">const</span> noweCyfry = [...cyfry, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]; <span class="hljs-comment">// Rozwija [1, 2, 3] do 1, 2, 3, a potem dodaje 4, 5</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(noweCyfry); <span class="hljs-comment">// Wyświetli: [1, 2, 3, 4, 5]</span>

<span class="hljs-keyword">const</span> tablica1 = [<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>];
<span class="hljs-keyword">const</span> tablica2 = [<span class="hljs-string">"c"</span>, <span class="hljs-string">"d"</span>];
<span class="hljs-keyword">const</span> polaczoneTablice = [...tablica1, ...tablica2];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(polaczoneTablice); <span class="hljs-comment">// Wyświetli: ["a", "b", "c", "d"]</span>
</code></pre>
</li>
<li>
<p><strong>Kopiowanie i łączenie obiektów:</strong> Podobnie jak z tablicami, możesz tworzyć kopie obiektów i łączyć ich właściwości.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> osoba = { <span class="hljs-attr">imie</span>: <span class="hljs-string">"Anna"</span>, <span class="hljs-attr">wiek</span>: <span class="hljs-number">28</span> };
<span class="hljs-keyword">const</span> osobaZZawodem = { ...osoba, <span class="hljs-attr">zawod</span>: <span class="hljs-string">"Programista"</span> };
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(osobaZZawodem); <span class="hljs-comment">// Wyświetli: { imie: "Anna", wiek: 28, zawod: "Programista" }</span>

<span class="hljs-keyword">const</span> daneKontaktowe = { <span class="hljs-attr">email</span>: <span class="hljs-string">"a@example.com"</span>, <span class="hljs-attr">telefon</span>: <span class="hljs-string">"123-456-789"</span> };
<span class="hljs-keyword">const</span> pelneDane = { ...osoba, ...daneKontaktowe };
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pelneDane); <span class="hljs-comment">// Wyświetli: { imie: "Anna", wiek: 28, email: "a@example.com", telefon: "123-456-789" }</span>
</code></pre>
<p>Jeśli klucze się powtarzają, ostatnia wartość nadpisuje poprzednią.</p>
</li>
<li>
<p><strong>Przekazywanie argumentów funkcji:</strong> Możesz rozwijać tablicę jako argumenty funkcji.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sumuj</span>(<span class="hljs-params">a, b, c</span>) {
  <span class="hljs-keyword">return</span> a + b + c;
}
<span class="hljs-keyword">const</span> liczby = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sumuj</span>(...liczby)); <span class="hljs-comment">// Rozwija [10, 20, 30] do sumuj(10, 20, 30), wyświetli: 60</span>
</code></pre>
</li>
</ul>
<h3 id="rest-operator-operator-reszty" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#rest-operator-operator-reszty">>>></a>Rest Operator (operator reszty)</h3>
<p>Gdy używasz <code>...</code> do <strong>zbierania</strong> wielu elementów w jedną tablicę (lub właściwości w obiekt), mówimy o <strong>operatorze rest</strong>. Jest to jak "zbieranie" luźnych elementów w jedną kolekcję. 🧺</p>
<p><strong>Zastosowania Rest Operatora:</strong></p>
<ul>
<li>
<p><strong>Zbieranie argumentów funkcji:</strong> Pozwala funkcji przyjmować nieokreśloną liczbę argumentów i traktować je jako tablicę.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">suma</span>(<span class="hljs-params">...liczby</span>) {
  <span class="hljs-comment">// 'liczby' zbiera wszystkie przekazane argumenty w tablicę</span>
  <span class="hljs-keyword">return</span> liczby.<span class="hljs-title function_">reduce</span>(
    <span class="hljs-function">(<span class="hljs-params">akumulator, aktualnaLiczba</span>) =></span> akumulator + aktualnaLiczba,
    <span class="hljs-number">0</span>
  );
}
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">suma</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">// Wyświetli: 6</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">suma</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>)); <span class="hljs-comment">// Wyświetli: 100</span>
</code></pre>
</li>
<li>
<p><strong>W destrukturyzacji (jak widzieliśmy wcześniej):</strong> Zbieranie pozostałych elementów do nowej tablicy lub obiektu.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> [pierwszy, drugi, ...resztaTablicy] = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pierwszy); <span class="hljs-comment">// Wyświetli: 10</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(drugi); <span class="hljs-comment">// Wyświetli: 20</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(resztaTablicy); <span class="hljs-comment">// Wyświetli: [30, 40, 50]</span>

<span class="hljs-keyword">const</span> { imie, ...resztaOsoby } = {
  <span class="hljs-attr">imie</span>: <span class="hljs-string">"Ola"</span>,
  <span class="hljs-attr">wiek</span>: <span class="hljs-number">25</span>,
  <span class="hljs-attr">miasto</span>: <span class="hljs-string">"Warszawa"</span>,
};
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(imie); <span class="hljs-comment">// Wyświetli: Ola</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(resztaOsoby); <span class="hljs-comment">// Wyświetli: { wiek: 25, miasto: "Warszawa" }</span>
</code></pre>
</li>
</ul>
<p>Zarówno spread, jak i rest operator są niezwykle przydatne i sprawiają, że kod jest znacznie bardziej zwięzły i czytelny, szczególnie podczas pracy z tablicami i obiektami.</p>
<hr>
<h2 id="promise-api-i-obsługa-asynchroniczności---opowiadaj-historie-o-przyszłości" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#promise-api-i-obsługa-asynchroniczności---opowiadaj-historie-o-przyszłości">>></a>Promise API i obsługa asynchroniczności - opowiadaj historie o przyszłości</h2>
<p>JavaScript jest językiem <strong>jednowątkowym</strong>, co oznacza, że może wykonywać tylko jedną operację w danym momencie. Jednak wiele operacji, takich jak pobieranie danych z internetu, odczyt plików, czy operacje na bazie danych, trwa pewien czas. Gdyby JavaScript musiał czekać na ich zakończenie, strona internetowa by się "zawiesiła" (nie reagowałaby na kliknięcia, przewijanie itp.).</p>
<p>Tutaj wkracza <strong>asynchroniczność</strong>. Pozwala ona na rozpoczęcie operacji, a następnie przejście do kolejnych zadań, nie czekając na zakończenie tej pierwszej. Kiedy asynchroniczna operacja się zakończy, JavaScript wróci do niej i wykona dalsze kroki.</p>
<p>Starszym sposobem obsługi asynchroniczności były <strong>callbacki</strong> (funkcje zwrotne), które jednak często prowadziły do tzw. "callback hell" (piekła callbacków) - zagnieżdżonego, trudnego do czytania i utrzymania kodu.</p>
<h3 id="czym-jest-promise" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#czym-jest-promise">>>></a>Czym jest Promise?</h3>
<p><strong>Promise (Obietnica)</strong> to obiekt w JavaScript, który reprezentuje ostateczne zakończenie (lub niepowodzenie) operacji asynchronicznej. Możesz myśleć o Promise jako o "przyszłej wartości". Składasz obietnicę, że w przyszłości otrzymasz wynik - albo sukces, albo błąd. 📦</p>
<p>Promise może znajdować się w jednym z trzech stanów:</p>
<ol>
<li><strong><code>pending</code> (oczekujący)</strong>: Początkowy stan; ani spełniony, ani odrzucony. Operacja asynchroniczna nadal trwa.</li>
<li><strong><code>fulfilled</code> (spełniony)</strong>: Operacja asynchroniczna zakończyła się sukcesem i zwróciła wartość.</li>
<li><strong><code>rejected</code> (odrzucony)</strong>: Operacja asynchroniczna zakończyła się błędem.</li>
</ol>
<p>Możesz "podpiąć" funkcje, które zostaną wywołane, gdy Promise zmieni swój stan:</p>
<ul>
<li><strong><code>.then()</code></strong>: Wywoływany, gdy Promise zostanie <code>fulfilled</code> (operacja zakończy się sukcesem). Otrzymuje wartość zwróconą przez Promise.</li>
<li><strong><code>.catch()</code></strong>: Wywoływany, gdy Promise zostanie <code>rejected</code> (wystąpi błąd). Otrzymuje obiekt błędu.</li>
<li><strong><code>.finally()</code></strong>: Wywoływany zawsze, niezależnie od tego, czy Promise zakończył się sukcesem, czy błędem. Idealny do czyszczenia zasobów.</li>
</ul>
<p><strong>Przykład tworzenia i używania Promise:</strong></p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> obietnica = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> {
  <span class="hljs-comment">// Symulujemy operację asynchroniczną (np. pobieranie danych)</span>
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-keyword">const</span> sukces = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() > <span class="hljs-number">0.5</span>; <span class="hljs-comment">// Losowo decydujemy o sukcesie lub błędzie</span>

    <span class="hljs-keyword">if</span> (sukces) {
      <span class="hljs-title function_">resolve</span>(<span class="hljs-string">"Dane pobrane pomyślnie!"</span>); <span class="hljs-comment">// Jeśli sukces, wywołujemy resolve z wynikiem</span>
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"Nie udało się pobrać danych."</span>)); <span class="hljs-comment">// Jeśli błąd, wywołujemy reject z błędem</span>
    }
  }, <span class="hljs-number">2000</span>); <span class="hljs-comment">// Operacja trwa 2 sekundy</span>
});

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Rozpoczęto operację..."</span>);

obietnica
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">wiadomosc</span>) =></span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"SUKCES:"</span>, wiadomosc); <span class="hljs-comment">// Wykona się, jeśli obietnica się spełni</span>
  })
  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">blad</span>) =></span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"BŁĄD:"</span>, blad.<span class="hljs-property">message</span>); <span class="hljs-comment">// Wykona się, jeśli obietnica zostanie odrzucona</span>
  })
  .<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Operacja zakończona (niezależnie od wyniku)."</span>); <span class="hljs-comment">// Wykona się zawsze</span>
  });

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Kod po obietnicy nadal się wykonuje..."</span>); <span class="hljs-comment">// Pokazuje asynchroniczność</span>
</code></pre>
<h3 id="łańcuchy-promise-promise-chaining" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#łańcuchy-promise-promise-chaining">>>></a>Łańcuchy Promise (<code>Promise Chaining</code>)</h3>
<p>Jedną z największych zalet Promise jest możliwość łączenia wielu operacji asynchronicznych w jeden czytelny "łańcuch". Każdy <code>.then()</code> zwraca nowy Promise, co pozwala na kolejne <code>.then()</code> wywołane po sobie. Jest to idealne, gdy jedna operacja asynchroniczna zależy od wyniku poprzedniej.</p>
<p><strong>Przykład łańcucha Promise (pobieranie danych z API):</strong></p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// fetch() to wbudowana funkcja JS, która zwraca Promise</span>
<span class="hljs-title function_">fetch</span>(<span class="hljs-string">"https://jsonplaceholder.typicode.com/users/1"</span>) <span class="hljs-comment">// Pobierz dane użytkownika o ID 1</span>
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">response</span>) =></span> {
    <span class="hljs-comment">// Pierwsze .then: sprawdź, czy odpowiedź jest OK i sparsuj ją jako JSON</span>
    <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`Błąd HTTP! Status: <span class="hljs-subst">${response.status}</span>`</span>);
    }
    <span class="hljs-keyword">return</span> response.<span class="hljs-title function_">json</span>(); <span class="hljs-comment">// Zwróć kolejny Promise z danymi JSON</span>
  })
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">user</span>) =></span> {
    <span class="hljs-comment">// Drugie .then: otrzymaj sparsowane dane użytkownika</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Pobrany użytkownik:"</span>, user.<span class="hljs-property">name</span>, user.<span class="hljs-property">email</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">fetch</span>(
      <span class="hljs-string">`https://jsonplaceholder.typicode.com/posts?userId=<span class="hljs-subst">${user.id}</span>`</span>
    ); <span class="hljs-comment">// Pobierz posty tego użytkownika</span>
  })
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">response</span>) =></span> {
    <span class="hljs-comment">// Trzecie .then: sprawdź odpowiedź i sparsuj posty</span>
    <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`Błąd HTTP! Status: <span class="hljs-subst">${response.status}</span>`</span>);
    }
    <span class="hljs-keyword">return</span> response.<span class="hljs-title function_">json</span>();
  })
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">posts</span>) =></span> {
    <span class="hljs-comment">// Czwarte .then: otrzymaj posty</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Liczba postów użytkownika:"</span>, posts.<span class="hljs-property">length</span>);
  })
  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =></span> {
    <span class="hljs-comment">// .catch: Obsłuż każdy błąd, który wystąpił na dowolnym etapie łańcucha</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"Wystąpił błąd w łańcuchu Promise:"</span>, error);
  })
  .<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Pobieranie danych zakończone."</span>);
  });
</code></pre>
<p>Promise to podstawa nowoczesnego JS w obsłudze asynchroniczności, a kolejny rozdział pokaże Ci, jak jeszcze bardziej uprościć ich użycie.</p>
<hr>
<h2 id="asyncawait---nowoczesna-obsługa-kodu-asynchronicznego---pisz-asynchronicznie-myśl-synchronicznie" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#asyncawait---nowoczesna-obsługa-kodu-asynchronicznego---pisz-asynchronicznie-myśl-synchronicznie">>></a>Async/await - nowoczesna obsługa kodu asynchronicznego - pisz asynchronicznie, myśl synchronicznie</h2>
<p>Mimo że Promise są ogromnym krokiem naprzód w porównaniu do callbacków, kod z długimi łańcuchami <code>.then().then().catch()</code> może wciąż być trudny do czytania. Standard ES2017 wprowadził słowa kluczowe <strong><code>async</code></strong> i <strong><code>await</code></strong>, które pozwalają pisać kod asynchroniczny w sposób, który wygląda i zachowuje się niemal identycznie jak kod synchroniczny, jednocześnie zachowując asynchroniczną naturę. To game changer! 🎮</p>
<h3 id="uproszczenie-pracy-z-promise" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#uproszczenie-pracy-z-promise">>>></a>Uproszczenie pracy z Promise</h3>
<ul>
<li><strong><code>async</code></strong>: Musisz oznaczyć funkcję słowem kluczowym <code>async</code>, aby móc używać w niej <code>await</code>. Funkcja <code>async</code> <strong>zawsze zwraca Promise</strong>, nawet jeśli zwrócisz w niej zwykłą wartość - JavaScript automatycznie opakuje ją w Promise.</li>
<li><strong><code>await</code></strong>: Słowo kluczowe <code>await</code> może być użyte <strong>tylko wewnątrz funkcji <code>async</code></strong>. Powoduje ono, że wykonanie funkcji <code>async</code> zostaje <strong>wstrzymane</strong>, dopóki Promise, na który czeka <code>await</code>, nie zostanie <strong>spełniony (fulfilled)</strong>. Kiedy Promise się spełni, <code>await</code> "rozpakowuje" jego wartość i przypisuje ją do zmiennej. Jeśli Promise zostanie odrzucony (rejected), <code>await</code> "wyrzuci" błąd, który możesz obsłużyć za pomocą <code>try...catch</code>.</li>
</ul>
<p><strong>Przykład użycia <code>async/await</code> (porównaj z przykładem z Promise Chaining):</strong></p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">pobierzDaneUzytkownikaIPosty</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Rozpoczynam pobieranie danych..."</span>);

    <span class="hljs-comment">// Krok 1: Pobierz dane użytkownika</span>
    <span class="hljs-keyword">const</span> userResponse = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(
      <span class="hljs-string">"https://jsonplaceholder.typicode.com/users/1"</span>
    );
    <span class="hljs-keyword">if</span> (!userResponse.<span class="hljs-property">ok</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(
        <span class="hljs-string">`Błąd HTTP przy pobieraniu użytkownika! Status: <span class="hljs-subst">${userResponse.status}</span>`</span>
      );
    }
    <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> userResponse.<span class="hljs-title function_">json</span>(); <span class="hljs-comment">// Poczekaj na parsowanie JSON</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Pobrany użytkownik:"</span>, user.<span class="hljs-property">name</span>, user.<span class="hljs-property">email</span>);

    <span class="hljs-comment">// Krok 2: Pobierz posty tego użytkownika</span>
    <span class="hljs-keyword">const</span> postsResponse = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(
      <span class="hljs-string">`https://jsonplaceholder.typicode.com/posts?userId=<span class="hljs-subst">${user.id}</span>`</span>
    );
    <span class="hljs-keyword">if</span> (!postsResponse.<span class="hljs-property">ok</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(
        <span class="hljs-string">`Błąd HTTP przy pobieraniu postów! Status: <span class="hljs-subst">${postsResponse.status}</span>`</span>
      );
    }
    <span class="hljs-keyword">const</span> posts = <span class="hljs-keyword">await</span> postsResponse.<span class="hljs-title function_">json</span>(); <span class="hljs-comment">// Poczekaj na parsowanie JSON</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Liczba postów użytkownika:"</span>, posts.<span class="hljs-property">length</span>);

    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Wszystkie dane zostały pobrane pomyślnie."</span>);
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-comment">// Obsługa każdego błędu, który wystąpił na dowolnym etapie</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"Wystąpił błąd w funkcji async:"</span>, error.<span class="hljs-property">message</span>);
  } <span class="hljs-keyword">finally</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Operacja pobierania danych zakończona."</span>);
  }
}

<span class="hljs-comment">// Wywołanie funkcji async</span>
<span class="hljs-title function_">pobierzDaneUzytkownikaIPosty</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Kod poza funkcją async nadal się wykonuje..."</span>); <span class="hljs-comment">// Pokazuje asynchroniczność</span>
</code></pre>
<p>Widzisz, jak kod stał się znacznie bardziej liniowy i czytelny? Wygląda to prawie jak tradycyjny kod synchroniczny, mimo że w tle nadal działają Promise i cała magia asynchroniczności.</p>
<h3 id="zwracanie-wartości-i-obsługa-błędów" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#zwracanie-wartości-i-obsługa-błędów">>>></a>Zwracanie wartości i obsługa błędów</h3>
<ul>
<li>
<p><strong>Zwracanie wartości z funkcji <code>async</code></strong>:
Jeśli funkcja <code>async</code> zwraca jakąś wartość, ta wartość jest automatycznie opakowywana w Promise, który zostanie spełniony z tą wartością.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">zwrocLiczbe</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// Możesz też użyć await, np. await Promise.resolve(42);</span>
  <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;
}
<span class="hljs-title function_">zwrocLiczbe</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">val</span>) =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(val)); <span class="hljs-comment">// Wyświetli: 42</span>
</code></pre>
</li>
<li>
<p><strong>Obsługa błędów z <code>try...catch</code></strong>:
Największą zaletą <code>async/await</code> jest to, że pozwala na używanie standardowych bloków <code>try...catch</code> do obsługi błędów w kodzie asynchronicznym. Jeśli Promise, na który czeka <code>await</code>, zostanie odrzucony (rejected), <code>await</code> "rzuci" błąd, który zostanie przechwycony przez blok <code>catch</code>.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">symulujBlad</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> {
      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"Coś poszło nie tak!"</span>)), <span class="hljs-number">1000</span>);
    });
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result); <span class="hljs-comment">// To się nie wykona</span>
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"Złapano błąd:"</span>, error.<span class="hljs-property">message</span>); <span class="hljs-comment">// Wyświetli: Złapano błąd: Coś poszło nie tak!</span>
  }
}
<span class="hljs-title function_">symulujBlad</span>();
</code></pre>
</li>
</ul>
<p><code>async/await</code> to obecnie <strong>najczęściej rekomendowany</strong> sposób pracy z asynchronicznością w JavaScript, ponieważ znacząco poprawia czytelność i łatwość utrzymania kodu, sprawiając, że złożone operacje asynchroniczne stają się bardziej przejrzyste.</p>
<hr>
<h2 id="zadania-do-wykonania-sprawdź-swoją-wiedzę" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#zadania-do-wykonania-sprawdź-swoją-wiedzę">>></a>Zadania do wykonania: Sprawdź swoją wiedzę!</h2>
<p>Czas na praktykę! Rozwiąż te zadania, aby utrwalić to, czego się nauczyłeś/aś. Po każdym zadaniu możesz rozwinąć sekcję <code>Pokaż rozwiązanie</code>, aby sprawdzić swój kod. Powodzenia! 💪</p>
<h3 id="zadanie-1" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#zadanie-1">>>></a>Zadanie 1</h3>
<p>Napisz <strong>funkcję strzałkową</strong>, która przyjmuje dowolną liczbę argumentów numerycznych i zwraca ich sumę. Użyj <strong>rest operatora</strong> do zebrania argumentów.</p>
<details>
<summary>
<span>Pokaż rozwiązanie</span>
</summary>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">sumaWszystkichLiczb</span> = (<span class="hljs-params">...liczby</span>) => {
  <span class="hljs-keyword">return</span> liczby.<span class="hljs-title function_">reduce</span>(
    <span class="hljs-function">(<span class="hljs-params">akumulator, aktualnaLiczba</span>) =></span> akumulator + aktualnaLiczba,
    <span class="hljs-number">0</span>
  );
};

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sumaWszystkichLiczb</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">// Oczekiwany wynik: 6</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sumaWszystkichLiczb</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>)); <span class="hljs-comment">// Oczekiwany wynik: 100</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sumaWszystkichLiczb</span>()); <span class="hljs-comment">// Oczekiwany wynik: 0</span>
</code></pre>
</details>
<hr>
<h3 id="zadanie-2" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#zadanie-2">>>></a>Zadanie 2</h3>
<p>Utwórz obiekt reprezentujący produkt z kluczami: <code>nazwa</code>, <code>cena</code>, <code>dostepny</code>. Następnie użyj <strong>destrukturyzacji obiektu</strong>, aby wyodrębnić te wartości do osobnych zmiennych i wyświetlić je w konsoli. Dodaj również zmienną <code>producent</code> z wartością domyślną "Nieznany", na wypadek gdyby nie było jej w obiekcie.</p>
<details>
<summary>
<span>Pokaż rozwiązanie</span>
</summary>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> produkt = { <span class="hljs-attr">nazwa</span>: <span class="hljs-string">"Książka JS"</span>, <span class="hljs-attr">cena</span>: <span class="hljs-number">49.99</span>, <span class="hljs-attr">dostepny</span>: <span class="hljs-literal">true</span> };

<span class="hljs-keyword">const</span> { nazwa, cena, dostepny, producent = <span class="hljs-string">"Nieznany"</span> } = produkt;

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Nazwa: <span class="hljs-subst">${nazwa}</span>`</span>); <span class="hljs-comment">// Oczekiwany wynik: Nazwa: Książka JS</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Cena: <span class="hljs-subst">${cena}</span> zł`</span>); <span class="hljs-comment">// Oczekiwany wynik: Cena: 49.99 zł</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Dostępny: <span class="hljs-subst">${dostepny}</span>`</span>); <span class="hljs-comment">// Oczekiwany wynik: Dostępny: true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Producent: <span class="hljs-subst">${producent}</span>`</span>); <span class="hljs-comment">// Oczekiwany wynik: Producent: Nieznany</span>
</code></pre>
</details>
<hr>
<h3 id="zadanie-3" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#zadanie-3">>>></a>Zadanie 3</h3>
<p>Stwórz tablicę ulubionych filmów. Następnie użyj <strong>operatora spread</strong> do utworzenia nowej tablicy, która będzie zawierać wszystkie te filmy plus dwa dodatkowe filmy na końcu. Wyświetl nową tablicę w konsoli.</p>
<details>
<summary>
<span>Pokaż rozwiązanie</span>
</summary>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> ulubioneFilmy = [<span class="hljs-string">"Incepcja"</span>, <span class="hljs-string">"Matrix"</span>, <span class="hljs-string">"Interstellar"</span>];

<span class="hljs-keyword">const</span> nowaListaFilmow = [...ulubioneFilmy, <span class="hljs-string">"Pulp Fiction"</span>, <span class="hljs-string">"Forrest Gump"</span>];

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(nowaListaFilmow);
<span class="hljs-comment">// Oczekiwany wynik: ["Incepcja", "Matrix", "Interstellar", "Pulp Fiction", "Forrest Gump"]</span>
</code></pre>
</details>
<hr>
<h3 id="zadanie-4" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#zadanie-4">>>></a>Zadanie 4</h3>
<p>Napisz <strong>funkcję asynchroniczną</strong> o nazwie <code>pobierzWiadomosc</code>, która symuluje pobieranie wiadomości z serwera. Funkcja powinna używać <code>setTimeout</code>, aby po 3 sekundach zwrócić tekst "Wiadomość pobrana!". Użyj <code>async/await</code> do wywołania tej funkcji i wyświetlenia jej wyniku w konsoli. Dodaj również blok <code>try...catch</code> do obsługi potencjalnych błędów.</p>
<details>
<summary>
<span>Pokaż rozwiązanie</span>
</summary>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// Funkcja symulująca pobieranie danych (zwraca Promise)</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">pobierzWiadomoscAPI</span> = (<span class="hljs-params"></span>) => {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> {
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> {
      <span class="hljs-comment">// Możesz zmienić to na reject, aby przetestować obsługę błędów</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() > <span class="hljs-number">0.1</span>) {
        <span class="hljs-comment">// 90% szans na sukces, 10% na błąd</span>
        <span class="hljs-title function_">resolve</span>(<span class="hljs-string">"Wiadomość pobrana pomyślnie!"</span>);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"Błąd podczas pobierania wiadomości!"</span>));
      }
    }, <span class="hljs-number">3000</span>); <span class="hljs-comment">// Symulujemy 3 sekundy oczekiwania</span>
  });
};

<span class="hljs-comment">// Funkcja asynchroniczna używająca async/await</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">pobierzWiadomosc</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Rozpoczynam pobieranie wiadomości..."</span>);
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> wiadomosc = <span class="hljs-keyword">await</span> <span class="hljs-title function_">pobierzWiadomoscAPI</span>(); <span class="hljs-comment">// Czekaj, aż Promise się spełni</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Sukces:"</span>, wiadomosc);
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"Wystąpił błąd:"</span>, error.<span class="hljs-property">message</span>); <span class="hljs-comment">// Złap i wyświetl błąd</span>
  } <span class="hljs-keyword">finally</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Zakończono próbę pobierania wiadomości."</span>);
  }
}

<span class="hljs-comment">// Wywołaj funkcję asynchroniczną</span>
<span class="hljs-title function_">pobierzWiadomosc</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(
  <span class="hljs-string">"Ten tekst wyświetli się natychmiast po uruchomieniu programu, zanim wiadomość zostanie pobrana."</span>
);
</code></pre>
</details>
<hr>
<p>Gratulacje! 🎉 Dotarłeś/aś do końca kursu wprowadzającego w nowoczesny JavaScript. Masz teraz solidne podstawy do dalszego rozwoju. Pamiętaj, że kluczem jest praktyka - im więcej będziesz kodować, tym lepiej zrozumiesz te koncepcje.</p>
<p>Co chciałbyś/chciałabyś zgłębić dalej? Może:</p>
<ul>
<li><strong>Moduły ES6</strong> (import/export)?</li>
<li><strong>Klasy</strong> w JavaScript (obiektowość)?</li>
<li><strong>Metody tablicowe</strong> (map, filter, reduce)?</li>
<li>Głębsze nurkowanie w <strong>asynchroniczność</strong> i Web API?</li>
</ul>
<p>Daj znać! 😊</p></article><div class="container prose"><h2>Quiz: Podstawy nowoczesnego JavaScript</h2><div><p class="font-bold mb-0!">Pytanie <!-- -->1<!-- --> z <!-- -->5</p><div class="prose-p:mt-2"><p>Jaką główną różnicę między <code>let</code> a <code>var</code> podkreśla się w nowoczesnym JavaScript?</p></div><div class="grid grid-flow-row gap-3"><button data-slot="button" class="button button--variant-outline button--size-sm w-full text-left inline-flex justify-start transition-none text-wrap! min-h-min! py-1.5 cursor-pointer">Obie są identyczne</button><button data-slot="button" class="button button--variant-outline button--size-sm w-full text-left inline-flex justify-start transition-none text-wrap! min-h-min! py-1.5 cursor-pointer">`var` nie istnieje w nowoczesnym JS</button><button data-slot="button" class="button button--variant-outline button--size-sm w-full text-left inline-flex justify-start transition-none text-wrap! min-h-min! py-1.5 cursor-pointer">Zakres blokowy (`block scope`) w `let`</button><button data-slot="button" class="button button--variant-outline button--size-sm w-full text-left inline-flex justify-start transition-none text-wrap! min-h-min! py-1.5 cursor-pointer">`let` nie pozwala na przyjmowanie wartości domyślnej</button></div></div></div><div class="container"><p class="button button--variant-secondary button--size-lg w-full p-10 text-wrap flex-wrap h-auto text-center gap-y-4 text-wrap!" data-slot="button">Widzisz jakiś błąd, bądź literówkę? Chcesz coś poprawić?<a href="https://github.com/jakubszpil/jakubszpil.github.io/edit/main/app/content/courses/nowoczesny-javascript.md" target="_blank" rel="noreferrer" data-slot="button" class="button button--variant-link button--size-default">✏️ Przejdź do edycji tego pliku</a></p></div></main><footer class="prose max-w-full border-t"><div class="container flex items-center gap-3 justify-start flex-wrap-reverse lg:justify-between"><p class="xl:text-sm">© <!-- -->2025<a data-slot="button" class="button button--variant-link button--size-sm" href="/" data-discover="true">jakubszpil</a></p><nav class="flex items-center flex-wrap -ml-3"><a data-slot="button" class="button button--variant-link button--size-sm" href="/" data-discover="true">🏠 Strona główna</a><a data-slot="button" class="button button--variant-link button--size-sm" href="/blog" data-discover="true">📝 Blog</a><a data-slot="button" class="button button--variant-link button--size-sm" href="/learning" data-discover="true">🏫 Learning</a><a data-slot="button" class="button button--variant-link button--size-sm" href="/portfolio" data-discover="true">🛠️ Portfolio</a><a data-slot="button" class="button button--variant-link button--size-sm" href="/me" data-discover="true">🙋‍♂️ O mnie</a><a data-slot="button" class="button button--variant-link button--size-sm" href="/search" data-discover="true">🔍 Szukaj</a><a data-slot="button" class="button button--variant-link button--size-sm" href="/handbook" data-discover="true">📋 Handbook</a></nav></div></footer><script>((storageKey2, restoreKey) => {
    if (!window.history.state || !window.history.state.key) {
      let key = Math.random().toString(32).slice(2);
      window.history.replaceState({ key }, "");
    }
    try {
      let positions = JSON.parse(sessionStorage.getItem(storageKey2) || "{}");
      let storedY = positions[restoreKey || window.history.state.key];
      if (typeof storedY === "number") {
        window.scrollTo(0, storedY);
      }
    } catch (error) {
      console.error(error);
      sessionStorage.removeItem(storageKey2);
    }
  })("react-router-scroll-positions", "/learning/nowoczesny-javascript/.default")</script><script>window.__reactRouterContext = {"basename":"/","future":{"v8_middleware":false,"unstable_optimizeDeps":true,"unstable_splitRouteModules":true,"unstable_subResourceIntegrity":false,"unstable_viteEnvironmentApi":true},"routeDiscovery":{"mode":"initial"},"ssr":false,"isSpaMode":false};window.__reactRouterContext.stream = new ReadableStream({start(controller){window.__reactRouterContext.streamController = controller;}}).pipeThrough(new TextEncoderStream());</script><script type="module" async="">import "/assets/manifest-095568ab.js";
import * as route0 from "/assets/root-CWpT0Luk.js";
import * as route1 from "/assets/layout-DTSVQAyN.js";
import * as route2 from "/assets/course-details-Cekl_zRU.js";
  
  window.__reactRouterRouteModules = {"root":route0,"routes/layout":route1,"course-details":route2};

import("/assets/entry.client-D07Jc1yP.js");</script><!--$?--><template id="B:0"></template><!--/$--><script id="_R_">requestAnimationFrame(function(){$RT=performance.now()});</script><div hidden id="S:0"><script>window.__reactRouterContext.streamController.enqueue("[{\"_1\":2,\"_7\":-5,\"_8\":-5},\"loaderData\",{\"_3\":4},\"course-details\",{\"_5\":6},\"v\",\"㞂⁆⁜⁊੠㬸ᧀ蘎䀈໩腈ಠദ̘נ➀㘂婠胶\\uda31䨊循ƺꁩ栀瀂衒偁큈톘ŘꙒ뀦―Ö든ִ찠挀倞準ꨒ㭄ٸ᧍牥쎛✧ᒀ଄経ཆ搛์\\u0013䙌儖ş⃔棊Ы娊฀챺娄儸䭇䩬泿ბ匄岂ꊤ兦䨀耺䰀甲婀偀㌀坌パ呑ₜ깞縡ㅌ牴고렖樾魀⅀ቬጛ⣲吕滒٦㡌3㺄ᵒ㕜ፔ氻⎓\\uda0f₸石茿缭鲀撡딺ꉊᆇ䟐ጡ芌̓闢ࡢᶰꡀྠ㟅䏧㧁ꢆ䐄㓢썣ₐ晘鲚梣፬찀ᑀ考恹ㆰ뢖蒄Ԓ老둀⩹㈖鸤鍃憼鶩鴟둃♟ଊ␑탊䤅\\udaa8偃Ӕ₃むº鉋搈刭曢ᭈฃ 　᤽\\u0016-㞵逘̳稀⫞ᨻỴ떣\\ude80ᚯ╅Ԁ䆠E㺭ᲉӀ\\u0015ᡑ་펉쵢柳灊品䋭樌考찠Ǳ존\\udd4cᦃ撈䀎юⱦ卉耲턴פֿݴ詛荶ঢເẙ甕幠剋闷瞀⋜帨躀䜄ͪL䉳鰉㪾쑧匛䨀㼖챢ਠ\\u000f☃ӈë䋮Գ䂰窒\\u0000扻섌ぉ悔쮁噤蜄成벲檃帨☆͐谎蓒怀Լᙆ뀺ࡌ묈瀼ဂ匾尊⌡\\udf23칃ꈏ멌戤鐊赣ꉂ稠∴랩ཀ쐠뷤莦溁蔂窒ȃ⇱ɣ윊ꁑੀ猑堽᥇悔उ硐ꠖ١䒜√次ع鑄\\ude58ᗃ犐則ψ¾䐛様ガ䈧車揄ၢ㸧ॅ䐿ꛣ\\ud800㨈ᝣ筶螮䳈㈀˱攠㾍䃢頄셩ᦇ\\u0006躓鸪唅爌⎠앓鹖嗕丠ᣨ瀩䣀ࡑ❜론ᮦꃝ뻠 頙妀ਝ苓劐╀핔허`致ؘђ甀⌖瘤ᛓ퓭筅偷ധ姑璀\\udda7ꍶ㵷昀뭿勵േ篞琈鵨毶ⵖ耍쎖͏䠸㘝⍘킑䵟䳑ࠒ퀫\\ud898आŚ歲퀢⎹盗횕ꃺ㉹\\ud864秏埴䵜\\u0003谆ࣀዸ팣瓾혌ڢⴊ‒霵쩂䮼映뵇፠ᬝ䶞䞯ﺀ旙芆벵쮸峹ᰅጛ벑맪趵ꕀ\\ude9e錠\\\"ȟ䙣탸ꄠ动쬸諁䝆鋐豣䦁᯴⡪ច※洁盝豙芘ꁠ싆墍⫝퓞ꙍᡖ긭ᥳ껮\\udd9bᆕﺒ\\u001f梀耠ꀱ앃ᚦⳬ臀9┋쮻瀎脱篷〯ꀠꎥ䪀泝⼡ᠤ귧⧁᛭ۀ谈魀誘᾿焪ن撜᫆àᬪҦ퀬ᗸ㊁Ϩ蟓媒㚙ʆ滴@顰ᅴ⌄턈ᬏꁢ七ဳ蛵碡컃쵊Ⱑ栄䎰㯀釯朋膆ᇴੵ価齆ཽᰟ䁎ᅅ㭅⨄懇ⓤ糓鿊\\udc6dሔ⤔돌嬣ꀶ࿅阁䕃큋쎁젙蚠쀃珍\\ud944㾄핰흮쁬ᮀ̖뢴┣킃膰顜䞞閊詑㪃ꀼ☇舒㏠\\u0000ថ츓豢ң롪誨䔉欝耯굧곆㉇″ሁᱭ༸樱薜ᐮ燶ᶀ빇᧳椁璈ߒ퀈◜႒瘇㡂䯀餳⬓㱓邤넗욘찀ᦢ㤇큑⊀๺칁أ䍠줈蔧䢫\\ud888胧銊倃舂냸ꯃ禭ي귍⫈ꑭﰊ맥ᘌ횩덆곕媨ꃪ彄嬃穦趆꣗᪓厩㤴詁ր㖦ᬬ宣ᶕ贺뾗阈㜫촿ꉳẬ쫙䝒孋玃爕舂团㵁ꭵ鳵幀懪阀쌠亨ⰸ뀂祀젖봣ꥲ⚶㛬㞑連掘୑舮㪧刚甀ૈⷡꘁੈ퓧싱滲斗쮹뼰ꇣޘ떨鬖ᘔ묕助捊쾥︑\\u0002뉱匴㸲셤獟鮍列Ж油릔當๰蒝䕙䋭涹疦埖痐ࠀⅩ䀁ⷤ쯁ኯ䰌;ᗆꀖ\\uda80ረ跙ଁ⤊ꛐ퇀୤臹Ɍ먟퀧⢻芐โĸ܋鋸ƚ腈ੀ딝츀達̭籢ق뙞ۢᰊ棺昀□䫑蔐઀搶ᆬᰙ攺煋젮ݏ桒탣㹛쫰ﰰ䋚唗馘滆寘ᵢꓲ١⠾荴㭅ꛬ\\u0010錂^ව\\u0017뾀Ӏ\\u0002䈰Y\\u0003✑戏菐给䏐\\ude67旷☂訄滀瀥Б\\udd0aₐ棡龜峇烻ꢢ逑ὁᄀ运䘒ꐗជ恈ؠ징ᦆ胴䉁쬽쎄펟∔抁࣊ੁ剩̡摔؈먯䀘䌄憌ઁ㆔Ꮿᐒ䚲膰⒋슉뙓ɕᯄ胐؄ꩭᷛ响ޠ瀮잔䤖而狈楍ᑀᣭ몡皖䫈䝸驚푉酅嗐ą齲致靀鑱稉䐉ઇ⣻肇⛼쌚硽铸똜Ƌ脈⓰\\ud8db꧰Ⱈ킱舊ꊒ蘛ዢ剧ǈ㰋柡曺؁蓵䳡庡杖␌ⴲ띤駝舲′㊱䬆Ꞙ蟟䈤玅ᒟ⸄바㇢ꈕຉ✀媠㤊녟ᣟ㎁밳辡숟༱툯䩍怓艦퐏틄ᗳ鉎Ɇ崴鷫洒염᳛腠줃僷麂뺻죰蚄艮ᒉ匣攀嫴詛쐐儵մለ퍜﬍㈙ǣꁤ\\ude60鐖✄㤷㖂᳌㫚塲0ศ䜈꙲溓又㓥쮈禡쀶蔔䇦ڸﵭ脝\\uda0f펐ଇ뢧䌊桑裀꾤ᓤ뾖⻥缈诖ɘ\\ude2b幈ٴﳚ耆̊ ྤ蔩ᅖ唃!秩쀌曈ꇐ␉臼⌆ሀ䮁ԯ㹫kƛ艼娂촕垖쐡ﭹ汵禜ŧ︆ហƉ쩧쩓ꭶʩ랻៴Ǟ퀭쵏⧇柦绮耕ᒁ溽䶽Ẉऀٵ쀙熏㶠Ƃ쫹䨀᦬駀ఠ놀R⢠䪳솪詵鴣籄䴧噌뎒㷀䋂峗㼖釿亽쟆鏊Ӡ槻⑔잂یㅾࢍ⺼鹆個먏䣈㱶ჹ湭촏䤁鐤㤽එ檦蹐ٚ富躂糈︑㴹䚆ཬ⨀쿗蜾虼礼㽊而ৢ艐䊍䆱❓䤰猤棰鵅ᓊ팰☂㢭쯯Ꚛ䂃駺ₖ\\uda60㗡㠃௹뾶Ⅾ㣹渤﫥㓺쾘穕ⶸ᰽ၖ봋胟鷻怄눘めᆋ凐ț⚑퀆ૹ枺୨삂ꖂ용稔Ɗᐁ艵Āၹቄ㄄娒⃑ɘᠵҌ㧃꺔돿㔃 ቔ藳쐆ჸ੃㰬毌᱀༇舘ᨄ侭ȇꦄ쾌맏鸆৴Ċ렁쌆蒱誦䄿聡舸ᤄ᪨恐䁢\\ud932郧龠끁⯷雰䬣ˇ꾂刦碸뚡莐❓蟘攂㡶鴀簝娈䓴ᡅ庣䂐ᬃ혗臄堀⑊ΐㆄ恩蕏름맠䅰４䆸澐Ӑ枀揢⧸섓̰䀂瀚遄끀γ㫘め쇜ɹ餮ዐႇ缑珐㰂ᢐყ\\n괵ᇗ饳䖘誨爋ౖ䌓뽊鄄⋇ⱏୄ㨂䈷못荅顰穘渄耵뫬ɨتπ鮅̰竻笥惘聃否䀬㙺硌犐枓쌰ᶀᒀ懸鹳蕰唀♺∥⑬埓욕ꨩ酠$菁艰ঘ࡫‡졛냋屭먦밝\\ud95e踤䴼↑껛逝饟㵆渦Ѷ㘄ﱫ䗼䰤밪ŋٸ≟頧ቔ⒍⥡⚲填뉘싁ౄ芧쎐ấ뉜┬୐舸쐚ꜻ⑲羚產騺曛ꈔ냷ꪧ褣╂射憧쉉䣷Ꙫ㒌⒆疤通鍐ࡂ婳ꝼҥ䩌ꚇ鲧宁솬嶀،䏸攁勞돃怔䌰䆪⦒﫣铆꾁⯸琹䱘얌䕹\\uddb2䍄ⱁ낯たꅡ缥芖态稀萮㥃閰쎸捇\\udc80礣ֹ﮵㫤ᑀ봄箏ⴇ篯뱸龥邧靸딆祸ὸྋ厚䧠뎠릳ꂀ玗㣳鼹검믂낺讓΋麸ꮌ맋芹⮛᪹ᴦ맂ູ繁멷ģᮓĠ㦹塟윮呸잜禸筺뉪箑⛸ు릚鞩㎻ᡥ福ሂ힘议⍻\\udd18袷뚪圛磹ݺ鄊ងꕋꅿ箙麇ྩꊏ辺稟룶❃阬↕蕃撬₊ใඐᕸ깴䀏ჰ\\ud81d˞ਢ\\ud934婛ܫ\\u000e㈁\\ud9ba⇀嫀候쏖ᬖ鸥ᚗ২쎨䁉ể咝類렉砈⁰ꌓ퀕䇴㪣㐅䎀鬊렲邤᠀氼㣛ꎹ植胪醬ꉙ䩁䐶陲ࡉঀ貖騌щ䄕륭砞飩힉᜙䮸敗格ཚ敹ᑮ捺趘讃鰣颩垀陛쀎㧐料膰 言砋\u003cઠ갤ኔ㉩〭ꖛ䖶兓ꡠ⹒凑瞎⤀בּᦸ耫㮳ꎫ幯㭺㼺뎣㏥Ŵ뫋벸࠮뫮㺻䮏㪻ﹶ렒৖䮰ᔛ輻腒훊硺䵲ᑑፀ絜퐭忱㮮ᚻꄒ夝ᙽ崛᱘译᳕ㄟ鬐ﮨ捱籚쐠ẗ楅ঌ⨂亾᝗驚沑啶萢㪖袑墈ᕱ囍⭹礬䨕坪ⅈ㓙━镗椣걃䜵啐២怐ჳ懃琰ᥕ撗褚።㧀䈵ϭ긁艨㷲ᖑ齨鲨떐థ鮳翐뾢黚〙䛅㩀ꠈ飁鏢츼蓃ஓ䋎⨢Ȼ嵸슩욒ꍻൢ㒖ᱦః℘ࢢㄶに뾏쏙⮃ꈨ쉰靕ꢢꆴḀ⺽Á䇡袀z랫払쨣\\ud8e0ૂ踋袳梙袭\\\\⤖鄍뜄ీ砦茈㢓䭬됇䥵됲ずꎨ୹旫ऊ䌝衁砚ꃔ椓᪛䁆ⱁ㩐䂞鏡畵늹轑布뚢ᑂ疷섘క륿똔ᗨ뭧த⛳鰮Ϥڑ逌㫟ე厜娳督⼮聟ᑂ䀮땟湑䲉犳頱픺γዉ딳ꄨ␩હ쭬꘳⊧厗燋᱐പ둺⡥荐❓㥬ꤲ脳䊎剠Ⱘꌰꮋሩ뀷訍ⴺ瑓ᘫ惺ぃ⟓瘑⨐줪郰ഝ㋠ᠪੵ⛢渦̐쒴愔듐Ⲷ᝷䌗慃혖뛤նჺ๠쟴岨෠六퉠✃괝ೀ씍䌗퉝㞣ኄ辞碲ンൽ⬌⣍覔㺀戮䅼ᜌ㈌둶弌ࣚ땫悳裲輂ꢨ댗⒨》ℏ쪜⡲먳劧죲鴫ꪹ膫㩵欶蹒먱₰\\udb0f됻\\ud8b6뒲퀫꣑⵶蠽甠⤲쐢\\ud829朂뗃墌’⣓ʨ쓰퇄셀ⓙϯ貨됊덑⑌銡辴\\u0002殴ဒ㜢驠ƪ㜠λ⓫쀅섔∀纓∀燗냹躜㊃鬥년⎌哿趐∾轶↏䪁ℴ旅儥ńכֿ瓏䷴샏೨쾅ꌙ䳌츖✀箓Ȭ힫⳪캕溪긜宻ϡ砸뉁酑蹔츁督㍂串ᬷ촆뛉黸퐘ꇿᬐ魠숋䢴ꕤ筹㸶쥬邤⸀⾳읧晏擁ⶐᓲ炑⻐ቨ쬗耜ᜊ킀탁鋠せ뾾膢袈뚚쁙䬲∶Ʊ贇혖ᄅ寡䈩抅몴즹ˮ⁐쐬錄㗂䜕舮ᢈ苘諫瞴치훓茚\\ud8a6䃚峠⸴禮簔➶ᒭ日굷㡭囗鹎햋뻗鰡홾毤ᮅ핝嚺ů꽋蠕횛ꐖﱵ롣禭玥교㖬궗骏㮀㞏谁髇㱬㐐\\ud889˥灑唷퀡鑼ﾀ⍒ㄬ埇彄ⵥ䅬ⴿ䱛囵ż䷷㜏⢴ᅷ䋫䕔\\ude15跄츣ꤒ倷塂\\ud83a䋫珡꫿㋡ᣭ鈣Ʂ㑷抮렯싳㝍䆮滖ژ䓙軖₤᪁店色႑普瓘ⷄ띋똲わ儂̈ᭀ㛲茐𢡄኉⮮᳏괆迃⭻䜯闞ꨯ던㧭拐䏴ꗯ暂銎ḏ㞠臎嚲釯䩩萀⪄ᨶ韮坋鈔ﺀⲎ샕쇩㕴蒃驉嶃\\udd52虤猾も᎝á乖툰৭溿坓싳碕乖沍䝣ৱ᝭༈祣伀浚炵ῴ膀㖐奎꾤Ϊă苭雄⾸룯鰻寴곮㶂ᎃ⍅ꩦ顎\\ud8ebᛙ⇮觖糛੄曔筧鍱潉픴硃駱摔㶜膓妙\\uda03ୢ2᠟孤ꔡ渡廤䏱틟쀹퍘\\udf75芹ֱコ鸪爜ൂ◁ॕ쮅悛ᶴు餸㬥‟䆍ሱ칾촶㊕㖘㲓ꀣ☮宄춆뛳儗⃨⨂秤灱㠊ḛ\\udc30쏭졁報㌦蹋Х倜ズ截³黷혩\\ude10긝ޡỵ嗩䧭㓥䤁釒Ủ谗顢磲ꢓᶏଟ轞䴇⪓붻﨔耋茾ྦྷ븱Ɛ㾀揊䁎斵䘤汞긥㔞㞞০쿞৏惟祬짜ⳉ鲝﮽㽏萭倫ⴆ谬⻵ኟ㬭唞鳚⺶矒쩁ዷ䏱쾞牞㸚嘮겹ꄉ؋〮℉⸮騱髐␟⸺⸬ǂ拁뽰盰䏕救畮뾐ᝤ뎸酸૘༚婙ὁꋌᾜ༚餵䫥簼᧦⁒治ꈋ哓ퟆ꺸Ɣ䋐걑⦃ꄤ䯞⻺ਲ㏬潤흲﵎怺葵䁽䒌尯榒덹媙❙쟃㱉첛ꈶ蠊撳픷䫭释푉쀸㾶좝䩘︣䷵\\udf41搿䔾주崞Ẇ鷡菵琋濖뽾县于ᴻ賿䭑ｪ쥵╌ӈ໬訩죣쭕쩃괦퍀꣕툋㷓㿎⪿ퟐﴡ౿염泜ᡸ꒡谱ࡠ谜ꏟ쿆堷ꆄ낹䰓ヒꢋᙀ㾁Հݿ\\udbb0纄픴䴯⶛쓀왬㝶ထ錍퍵턁᳄䲆욳ᶵ暖㴸ἓчꗉ⒑㍃儔䃅䒢͵л촿圛誛懲⋦ឍ숃ꅀ㉆썂গी⏲゚꬐蛔䞿鑍鱣訚骈຦䤶派腒桘Ń望º䘶ऀﴅ桕鮒鴁〰큝䷯ŀኄ肬聆☁乭퍞鯴졦⌴쀄愨˄榚頖普鎄㽹偁稸팀Ȉ\\udda9䳔ᮣȆ퓈腭샮资닪삳㌹쾠ⱀ\\ud810鄡죀东К瓡⛝湣쉨닝ܨ阏妌Ͱ捿椻죌₢న谑腔ᰆ嗤ᘺ咬ᰊ焉頓ꢕ䑓ఽ⪎｜؀⠒ꈄ큛䎠Ẅ䰣ǀ്ꞡ埌爐ꍓড셤遁ﶆ芪⊁ꪖ憞ᘹኌ䍥虵Ꮠ挒톛䌶擃䈄膤༠攃ꠙ耜欤ᅊែ븍䗷璸릝↓獐܃흼ሿʡ罆꡴ɠ洐ꏻࠪ名㜐忐瘕匷釀㙁蠎嘸䲔ᖰ퐂꠬໙뭍鉫ꂺȖؔ됂꼡憆ᨰ褀슅芸枵䩣ࢩߠ㻡褌硠쇂ঢ়疠슀絛ـ┑椒sი݀Ⳡ\\ud86b茒晳༆峄曯㕧铈朠‹죓酲镂▋兂䯾沑ɐȔᑅ臸鿀ဓ蘂̗肃ⲁ籀羙櫧镚ꜹ鵫祯覺쑜뭔袧귟⑵㮩鵕岗叼ꁭ溫\\ud981䈶쭗䲼䚠◰ﾕ૛⻸䉯븷ट苑퀗喥켔ᾁ\\uda2a耨Ⴢ㿕谥﹐㊸迼\\u0013鐰ӓᆀ瀉ᾍⲖ觌佸洙쉺Ϛ⮖㼄㗋ᥐؓ媱䕸㚀⾅܄㎤ऌ酐簕䅌賐ᡘ阍腓⃭첇蘱입垌嶖簤飚@ǁउ뫈휜⢁㳅ܩ椑ɶꘄ\\ude37䂁쬒ᘠ뚆ꂻԕ麄셃घຼ☦䀥甜ˠ一倓䃦億ᴀ꣎ϰ쵬윂\\udeae쀬ƐༀՅ精蒭룕⪂⢇ᔱ\\udc20伞ꌷ슠㏋슅퇫坴䖅㴔蘭䜆쯖ᾖ㪯ꏽ战耩蘲覆롬₭ᢨ⫛雬첵Ⱃး밧﵅\\udce3ᜒ\\udb24룜▜Հ䚹裑ܸ̐䄭Ⳬ耜㢓ጔ퀜荧冱鯅ᱪ襄鐆嘑碜肎䚈⿍䰁탖륂㶛愈揅⡩操ഐ簎儧ŶⓉ㋳豂\\ud8ad賹⥰₀⋾͢᛽鑰먮袖멈纬㶧Ѹ봉ꠝ僭趚ឱ桃䭭㢸᳈\\ud806ⱳ䍱壋헚ꔜйÀ爝⥘๐皈兛콀䴫䪨홷띸記䏜豄噋쨪葄猒듭䅴‌羽ꂄ虨⤡ᆄ뀫連⢦椸㚑訩ᅩ訢䑢⏤墍গ큆ȃఒ쁨ন䰍䅅怈兽͘傦딓谶醌毺甝ꤘꐡ뇨\\r䩄橣铝醻೤䤢\\ud865﹧Ᏹ⛀㑇肩聰䳐铒ꅫ㖄瀨₹ꏈ훡魎ɶ鷘㶥䤥䊁鋓톆瓰召钘흋⨒큒໴뀃欎袕㍐鄝ᡈ㤙뀊\\uda62⵾䆪┇㌦䅬쳪☳躛ಯ⯨퐵먿ﱎ鋿Ⅷ瘔Ʒ䍢™䢇蚒❁ﱀꑦÖᛈ顤爽牜貚伢Ɛ钿☲ᓐﴅ䄈覨茇㝻ᔻꂥ乶ꅌ⢄㌛㓨䒃㎡᦬龧\\udd2a쁨揈릙袞敽ࡺඦ䲶㎋蝴艤崻냔运ल隌첁虵Ḉ죣밫外ጃ䦹考삝䀀रc需媦ნ瓰䘥㟓턒魦戈⏆瓍၌꣥俬홥혽馸趺⸳얓詮朷⤁ᢖᠨ狛邜ꪀ遈懀䂘ᣃ࡫Ⳛ᧝⛁䤎큊䵕銜膨逈ࠓȟ됳쮗胭旽㚱严∷首艬ꉂ䡚衺♪갑谀홂脻什겓癢퀷餰ﬨṈ쮺坲톘갞齠䮧쐹၎Ḝ不⪐\\ude84쭙Ӳ횏᲻꘧⯨镅﹣ꤘฺ燦\\udd0a饀Ⲯ墩妄⃏ᬿⱁ賍䑣獑霠雦⠠祯젎睲莑襑지뿹䨌鹺玁䌼鹅켼酩㙝ῲၜꣽ婼쿜ꅲ厝淡恪抃鼘ꑪ틻苼鶚舟쓥吩㉡\\ude70䧻ᥘ뢈嫂⻱㠢崣쁈ꢐ刪ꚉ지࣐斀阩䏛ぁ둟밮꯭샠틧ĵⵙ伺ࢸ呑聕ᕈ礀䠁\\udf00硂\\udba2\\ud9c7︞煐࠯ᎋ霛ฤن膊谌᳃u菎干䉯૰࡚ࢨ衧뎠෰ኁ\\udf1e多ᮕ䩞灤寖䰂黏\\ude4d惯뽉咔೬酞鰄騟᧻꺤誂鷒䈌뎲餴᪝ꔔ榣䵚痢䀶½꜒짻폅द넀ຢꊭ彄Ḁ队蠈鶊∥먳橷雚鞢㵤쓯壑⦉瑈휨扫츘잨鮍覯叀룊⒐棋⃂㳦ﱠ鋋᜘諅撜ڹ缄៭񥡎Ꮤม褒颖䚑魘갞怒ꏀ프蠒ńǰ羊鐫☂㋝␊⹹嘙望㒅쑔਩Ć\\ud81e剨뼒란蔁⃁궍흙낤ꨩ缮倭遘ư仺憇솱E洁겮ɀ➙✠빗®쑒㜤㋗±ꑵじ嘚⃢끊敬遠首䚐齞ǁ❋묝瀇幎Ȱ풋耣úܴ⩨뾙達㳀첉阖꯱\\ude4e㶃쯎൸힂\\ude21∃耴ࢬ偎镸嬨낤帣ಡ⪤䫏࡙됐袳蔿㺅⤁ｸ堏횤詏讗᜖븐ᛏ薅挡鷡ꝃᚙᬾ晼ⱨ訠ᄡ됀逆‬颼㹔䫬㭵⦞Ⴕ龗Ꮭ塠恳唬䒟ⴅ먈暟㣈郞⸱啠⥦呷긃鄃䷾諈䚖뉩⺦퍋鱜펼铢嗇톄ýԂସ\\ude58扖흃㦙俎퉞龂Ⴓ꠺꿸ⵊ⭾敫㈹邧ŰŮ骂驦悶륟䋝帊⎚恕剐Ꭸ鷆萡ꅡ漣历ꂳƚㆡ菪㮞ⱪ諐᪀ꈄ䁿忄婉퐀䂼ڠᗫ㶛뫽퟈\\uddb9ˏᘍ匬鮤퐃۴⼚亲材櫆텷ᯱ巀褹⭵Ꟁ鷂ᄃԽ兀⽒舢ʬ쒍ꑯ衹᪒ίᢹ袰䒢뵠蛨죃䄀东턖ꀝǺร௛㨒ᖱ鼅倌笄ஸ쐗阘ל渴醹饏ꦮ䢃彙媦摾랢蜎耆뾢봵쵁挋౫\\uda07\\uda24⤂뮕⬘軖ʛ癴͞箲磒曓䅗⌅景Ꙏਛ驂ꛤ缾䄸踡忐烕곓㜟쾔ƪ덪௶Ⴄ濕紞췿곕㢌슋웳葽ᔶᨶ谙嫊惼頇릭虽⧰溫콙鰔Ⴒ趦褰ಷ赸䟙ᢂ帏ҷ딗诸髋⓳ᎍ\\udc0e⬵衊ꏲ迂餰쀒нƱ惹酛ላ陯\\ud9faΫ續졾騺鏻躠ړ굁昚듔ឿ㣵彃捹ߙฃꆢ맸淊鿐크䛈딈ᴅ蝩쭔諲턆ﱦ纠殳䃰᳐˦撁겹齪鵿᫵鏚푗⪡憍朁꣗㘴軭▁Ⲥ䆨辭ᓫ闀葭欽渻Ờ猣㜳⨍に荂\\u0010\\uda20␴↕ා泞戭㪂쨈᜜黵쑨솗\\udba2\\udbf6쐚妽渇慚თ𧻓∋᧍퓀譵㊢폶\\uda67馱縌졋嗚졜隢ᚳ뉡퀮ဈฎￖ᷃䓎癲뺇鳾瘫맵쫫絢큚ɖ휡᜶좞治䥆Ⳝ㕕뼔䰽寊掺閦甏ꖗ椷䨳츆牟郣ꇭ⼂筭ଡ଼혞귦⬭蘆ꁣꏀၬ襐ᬜ蛭爏敳\\ud940䋂ᠠ\\udd92冂䠅Ⱘ腂㻹鵉픪ꏄ礥㥑딛橹惢䈁ѝ쇵判넄쥒ࡅ岚樃調溸ꦜ㼑䬉⫦雠닠蜰䆲嘾욂뤘鷹ᘅ攁喬逢ߞꑀ䆗휚훱칓잊ꨠ៪㟴ꐥ柔⦂攟豦⪰菀绁涨魘屖핓娾鬁쥌쮔ຐ⢂␞烁䉂泤朩ꢺ炈僴籉ₒℨ⌡ᨊ샞苊ဘ饽㐩석੟鳒ႂ쮅䒲鯈겣턏静廕㙝䒀읾埲笨扁쪘鄘혤뵆ㅭ 턄螑ℊࠈ噂蔆䃒蔘‘琎閒ﱘᷠ跋ఊ壗猈䱔螧ާ\\udd21ḏ졎،Ⴘ邆㠭ꄜꗨ圃䘔\\udc2f룢촡숊瀀憐껣ṵ渝얲Ǵ격煦肱Β區쎅ﴵ⾞⊠ׄ儖鞤݀쟉ヶ\\u001c塄㫪ⱖ␘곭璹钧왐㏈畊洭 ⡱㓩ḕ䰘㣍螀㠞槉ṉ㸀ᰐ얹傉ᨸ瘨넎覸魀ﻮ蠔䄟鐥쌄爻쇴⻲鯫ྲ堒궜₽脤こ\\\\Ử岄⠖䃞⇄㫰̔ᛏ熾极᠈铃醂롞鞆쀓肻児䮨⸃ꖈ䠝䣊딒xㄔீ伔뼂磓销\\ud906Ὶ℆嵪늲❺◲ꝓ粖쪨㟫ᨏ嵈㚷᡺謓蹜솎╬恀㬜罛萎㾐ⷣᱠ櫷⵷ጻ똿챇\\u0013䄂㣿夺⧜繼⼓践섳伆階寗ꀭ鄬Ȇᚩ됹䑏ꙝᩆ弞릠ὠ嵥ꎫば仙喃䮟᎘蝰䣈픯˞۰\\udc48蘚臢ꈻ푽দ䚞鵸焢▕쵢猐郺ກ鼨륑ґ⍃ⳡ勉遊’춾栦굞ﷶ\\udfd4ꕵി謁Ԛ扻睛罅ꋤ઼␲腇܆ጂ适⦛∢艁忐偞榠넙輣顭Ꞁ\\ud92c쎱귖ຝ剂ບ档෤莺薀〦胪䶛ࢎ⨊⎜ᱚ枦ẝ鏤߲ᆛ꬐ᬓ\\udbae쪠샢횶닫蹎ᷩ菊စꁇ郰⼡᠍퍖齺徦欷榺찺瘬쭒⌋䁛がཌྷ箸桙汄嵲償滃흭㏹ꥫ嘶朘ங렁쬱㷍漎㊲聢쾟꘹펆瓦䆷藺⬃ᬛ큟픐㕺অ傏摗㕳ኋꌷ僂ǝ㴉桐苷揰㬟霁뜓鵶⨃୍笃톙镶㊞䛳鶼療㦣ꋫ븈宝ⳓ鎂獷瘏㤅칷揉༹ᘡ睙秋顚ᚭ㟙흷₤㌮し完闗᛺쩳臋尫珒\\uda05뎃⹲୉劳싘ⲡ貳箞쓆ត㩹厄譤滞大ꋯ蹚訹ᠾ䲚㺥\\t㛉넩蠋绮젂肳䱾鱈ၚ홦ȴ拐ᅧ멤䯋䰂ঋ遲↊ΐ觬쁯ﶈ땹췤婷\\ud956黠뾁급⹻㨋\\u0006錈㤁鐁搬藴ᣝⱛ㝎កඥ钀\\n鋋愅‾ᘬ먩ᚁᅸ쮎岘棦끔֪Ⰳꖋ흮쑝ᛒ\\udcca㜬祧䃌嫖櫧顒곖ᗹ柀腚∰垙ᑬ撮炮봋澹ʽᛛ홆䩚渜㱍쬤⌉ꁎ㒸鎔썎\\ud951뮙鏱戥꽕ᗀ侷ూ䶠ⓩ碦쇉嗸泶텲鐼0䖂簄꧌虃剨ᨸ戟䟲Ȃ䇕敕ቁ뱃躟ච≴莍ᰡ嗖ωⰊꀙ遣갩䇂 ꂈ‘Ạ骊艉ࢮ荴築㡹㐐㹍⥬䯛烪໔槓볾⮛೏⍳㔙蟍耐끠Ғᗡ傁ቛ≒ऩ榙拳陟飲缂蠀샔ќ\\udad1샖ᗻ䲏 擖ꡠꊏన苐ᮀ녧ᆿ㜅밭＂崛냵ꘘ⿦ꖴⷸ懨湛奄雀뙕돘得杘歰鮣⸆娌귡溶율⛝囨럅뀹匄쮱〦漼䷤Æ搠夊⠭祖⠿穭欱鯀幦꠆֛⽳殳䧌훴뙅똭쩰󼮖써閵귓氧籆ᠰ뛎뚑絮덊鳀㴥듃 㲖ႂ、練찉䲃󚕖죔㎰\\uddcd셛犜꥜娝럒대첬뺻⬓頦ᨣ㞟间摳ⶹⳛ曘ᚵ舧⸗ힴ练⸵蛆뙴촥\\udf98ꒃ굌ӫ∎뫔菤䦸﷔ຩ䇚┼罥༙එ쮞ꤛೋ⽵੫\\udebe۷䄾㹷恏ꕻ\\udde0绺䯞⥛䑪ᡴ䋆ᾴ탗ﰐ蹞⩚䖯榆ै≨萍茀濍樝㿔푦ꁒꪂ㐗赥焠ｺ䂙㐪⼒ǁᔧ챙‎Ợ∂墱飢鸡袖斚\\ud86aެ㞨엤怃埵矴洇ዓ妕櫳摭跈雓蚢║ꁹ呬ổ蟊槪䂜㭉쀦\\udf00愃τ︪኉뵖菎鍵넆ତ텂앺∞줜ﳳ䧭悦饐쁶㣔렄幅檞⫨٤ᖉ禉ꩾ挌덐逇鴶쫃獴푀虢嶙␤\\u0000榞莈욫뫃힒ꚱ㜩꤆鯀懛贶罦暮溵屐躚苪蟰\\udb7e\\udb57혚ﶘ隂ᐕ次㧆흌͞퀰途毨ਁ꺓캾痃뭹㩯듲Ũ\\udd1c㬆썝쒩쨀婵촁뮙ౚ湒ꝝ퍷嶕礚\\ud915Ⳬ䔩폼̽囎ꊁ뛨蝙\\udabd㞺覢䃍䭠㟁Ꚗⲿ䀯ⱗ㨝㐰砅뚢Ლ⪟ 箓ࠫ涚ँ栉ᅨ횀침ﭏᯆ症垧괋ꟈ\\u0014ⴀ괁玘ҏ晳怾ᶄΜ⢡㤗׌ꃢ㯒ꙿ䀎쳌\\udd86먘ȓ틅헌蚾ỽ㠢ꎇꈂɖ懀퇍㗨솹䳪粳쀭㴾㢎ກ㺙禍鳈\\udccb䭂곞켷顙退數졶ƶ탦ﶲ뎆帲㏋镫稤뉽̎ꭷ酦\\udd94堞킰梾䋂궫§䔅곰貜\\udf01⼰坐廂幄걎鍳乂἖ᚳ鄕밯ᲈ豟胮共嗇渤첑한Ⱒ鏥퉑䲓ꇝ鍘紊禌ꍮ빭強ᎸℙͶߨ⫆镵톕뿞뢔耻\\udd21蓣箲풊ᛁ脳\\uda61䜒唬─嫩끌幇聰痠⹫秄萫巐燁఼୘甆›蒾䎨༥ょ䢟잪ࡇ쁣㲅ᗨⰦ∥ᄾ틄咞渭㣝㤝櫨\\uddee屿篗ᷴ緇侼ᣚೝ広꼜뻻잯뻄꣘\\ud859쩩჈ꗸ孰鸩厷씑䔢≏弁鏖ꊒ᥾ﵮ訦\\udf62窮ಓ淮ƶ쳐⊊쉫瑥ᚈ궇屘鄞일\\udaf7鮺蓴焪⽡鄄ⲓ팲둰㯯謍랒윞硅ઋꃛꞃ넡웤×觪ጉ븂칪㬨Ａ餇ᮑ䡾ᆽ闹㻨䵑\\u001f騽†㎜脔숏갣鰨ꔞ旭蝄뭣뫥ṸႫ幒쉢豇ၰᨹଆᆤ귛ᆂ䖒ო佘쯑흰\\udb87ଶ䎻䉈鱁툤代斋몢羢杰ᬺ౟搤埚豩쫾⌧鯞㛫矎ᓁ㏷铠ߛ\\udd6e䜤䓏땐￝唑倌e뻋謔仪릀阨둾ꬸữᱰ淌雍ܨ稷跃䳛꘧룛ꗽ䊙땩䴑䘛䉕ﵧᴶ쀁°΀㛜덙稖翮ᗣ垰ị콧븏簑䑒偘謸짯펓\\ud980≮ང鬪忼﵎嫷Ḁ쮑@䛇娚彜(潀⌗\\udb9e최蛸뿳ᴯ؏ᯆ닢睫ꊕ儞\\udb3e⍉䳸޻芺ꁮ鵸볷癠濭጗챹祊ᾗ﫵ય惻᫯ፀ紦妔胷脃錎濽粠㜯㶛\\udde5痬숗菙闦먔ᚬ஼岛ꪱ맜뿥䝻ᗵ玲\\ude39聿䫷❇꠪\\ud8f7틔ǯ拐ȟ㚺蟼㯘닂싂闰฻쌋囶䧋撇ᚓ\\udf01쇲৽豈樠쇨娧˪느渄蠐ꑍꝾ㤑えੌ瞾旮弘吻蕵⾉縆憯蓾볪\\udf7dꖼ㨆\\ud8cc﬈甑㴇糄翋믭譪㻕\\ud89eﾜꖮ坊ࣖ␾闼俻微留䛆陻늚鉶\\udd66ᣖ龚᪠❙渤ꎕ•ᔞ㤴ค屦™烇펗祲Ⰺᴺ␂㴣䦙玮鹮㩥Ừ䈫䍟韮켌㲯맹ṁꡭ뢳ꑼ얥Ῐ⧊좻䷱꺛둛৸冕\\ud9ad寮쪬㫣猗㝬鱤벪纉斯ỿ頽࿒穛긯ဨ▛豝㠐͑߅छ츸摆࢐ឈ龱น챾勷ᾰ粥Ყ旅坐૷诸潟祷╶迟鳀쳟嫪偞ﺨ˟즅럾\\udfac⮇씿㟸者⼣闹䫧羰⠏釾쌂鿯뺭ףּꪲʁ㷏ꀙ希評͗蔜稂唎悜\\udab3\\udbb5沄ꋶ퉺\\ud9ee枟왓㛶ꎸ屢䆶⣮뎐榧龢㺳퀛늳욌䯐ᣁ蟆㟘\\udb83랝鸤Ծ詄᮸覔㮝䧅艘࢐龥邾撚豜⨸吉沙惃¶誈࢐တ吃紗䪭십췰느忙䌯ଛ䃗碗樻㊊늘뒏꒖竆᤾Шꯊ멐ᰎ᎐䅣漗踶❩춶︁\\ud95a拭⬀닣嬀⢅帝દ엤ﭰⰨ徣ꘊ≬ꨊꄆ甄휾⁑ٶ沫车넇ؠ徝튉ս੠㳂萲蕧ꖰ껞艝ຬ벌ᬊ틭힛ᙬㆵ豦凹뿪랯廡߭쁀ᖀĆى㎇䄁ʖː⭁ꠁ懍몵䅮聆싐䫠၀생ݘௐ啺줇倄び빽隣궼뎶淧ꄷǄ׭鈠蝹ﮅ뾙隱來̊ÁՊᤈ倔쏸ἰ矞ᗋ忬澵ᘘפֿ湯똾철చﾓ婰ѿⱁ鍂㐓\\udd9fﻥ῝귾䃹ퟡユ졌ᷰ桦뛹깡얿솿鉓ꈡ菹秣尉䁧Ⳙ짓ࢢ䞍ᱡ섟ꇁ⻺௢䈹݌☐榠鄆ᐓ㠃胳窭ʟ谂겺㤆栖縯䣜ᬰ杁儀쀔큢⅝쌍ꤡ駲愌人éꔰ楠虨￨麓솀т᫰洖킇瘎沋⇽篂ᵏꈡヺꬠࡵ끜蓷稡扙⟇鮼ᳪݠസⶼ傩蒩唕记⡓㸪봠刚끔谧ӯ䡁璅␐졀䩌蟘Ꮋс㌫遷悋Ь℈む觱尐〟ℷ燌᠐䏁鯈ꨞࡉ빹嫗봖첡蘐졺勱蘦ᾈ⮲䊄ﰐ桼Ƭ⬚ᰁ⨡쭸谗匠ﺅƘ칀ヾ뒙迬傑℆ڑᠢ⯨ఏ㾐炋切装૾󮷂ꀆﻃڒ鼮ィ羋䀐װ༨䢘꒢\\udc1e롆愙墂ᠮꪡ㦅欪lёި罾㔅√侑芥ޔ᪥뺾˨公噇藦ᨽ腡ゆ긞큚愺鎞ᚰ䭞蚆낮灰慢謚ᥔ◁脛老ꊭ婗ެ⁮꧀ࠛ➝썧䏵馀罚Ƞ඾ᣤ덊곾耒︀纄혥⛗ꌩכ떲絫ᄄක쓏奏Ꟗ薰ﴃ灅誸\\udc8d₼글㒒퉉➵湔暄雄鴐➍턻萇ᇧ1⃄╀䈉줯䡳᎐ᆼ릒뱋㠙ǧᢑ⽹ഁ搘儯䁴⦟枧ꇊ쮹᧢솟쓭ኙב㪀≅턀쓹᥉ᡑ貑ᐑ줙䎊쒊䞬䥻鮸Ʉ㰋넲胻ᅙᑱ၊朑ḁ焭鄣኎읱˄칇㱊᎛䙺ᥱ䜖⾑紒관ᑫ磊੉܁⟪稀焍鴢别넂ꡰ⚎ϱ庉꬐鑨͑჈失戅봺䃀ᩗ쯟Ø⮲ꍮ㘕鲝М෴ꎄ\\ude09嶀鄋댋쇔梑ፀ袍턖鲸꜀ᘠꑸ낁몣脇䵈괪巒딙➁Ǽ䘗৑❑陆┐ᠦṦ䯔ꊤ犞쬩ꑁ뢟殤泮Ⰴ⻤綁麆䒜걤涸Ɇ洘焓텢䓭ῥ뮆홺턿㐃䔜䧔䐈㹢䰿\\ud9c5耀㢲﫬엔끊哓肃紵䍹䂻ࡾ螺理䞾膏\\udadfآꖲ錙蚅ᨪㅇꆊ쵈꜀넃梦䛍ꐚ骎쨃䜄ᴲ觙舆พ쭐䚋ⁱ癩䦴ࠀ༆ࣻ\\ud926㨠䛙衟諗ꞑॆ⑦㖒ሶ䨤꼋ᾖꩠ暇蠝ᳰ甫♬怣⪫戶✂ⴀ乐෎㜲놨䃲꾼鍜\\ud9ba䜌锺帾쎤ٔ玁絉䓭趱\\udaa6骝꺙볡꜅逍鮫耹溜몌\\ud963⾟ﰕ穠⓯鰰㮆퐣\\ude24臀Ԕឱ᥸ਊ焠偺脞贯龱堈ܒ얦Ɇ宇ᅗꫦ쭪漍밁舤̘⨘㤰ᠪ履횕ႈ覌맀纀逃鱞뺿陖ｺḙﮥꌕᱱ⧅︐慿ѭड़䤀怀\\udc5e棘۷舲윣\\udfc8㞸뺨⪲꙱앹꟣\\ud998%ቷ鑱௅㞲驯ᥔ⤀\\ud904꼚籟※왒ᾼ䯒뼙耄怃玁憴⧄诇⸟缧ꂥᵮ醾ބ밞꺒婐葾ᖨ䏱袩쀌ﱦࡋ驖ႈ盲聇吒渤ɕ඼樁刃脜몶〳용怛輊鵙ꉡ଼놁䢱佀ㆱ侦㖱悥肍꼾詊责\\udfca홍拔ꤤ⃔伃숎䞙भ쌙죘넞붅式汤亀ୄ䮱帄脖寢⋐聡㌋䜭킓⇑Ӷ戰멀ំ➭ᡜ슩߂⫂ಝ৲⪀㉠葁ꨂ∰䆧Ꮲ⑗Ʝ톄䚊堎褧잇棩薨灈県」뚤ꈘ鈪ỡ侄煯萂甐颒ȏႬꗡࠧ媍榾聢覨鲂缮㨃㈪븕\\ud851☿䲺뮉悡ꄄ鮫⊳윜Ử御⼑ 㖕\\udc8f媿ፈ䉁膅紈怒ꑨ欨隐啞䠤\\u0000✀㩴嘃偈踣చ⒱洘寸庢盩ٕॴ➠ꆀ؇⠡荌䪾㍤ ᢛ籔觑쒱ฝ㮰릩좓扩觋蓑ᕒ儐㔤羿褒묾ᵟ깡쀧喌⅛┠β刀넧㗯ቍ憔褤鍞㋪ꤦ悗ウ䤤Ĵ鴆颢ꠁ璓퉢۽␢ং䣉㾐 ⢴즳⟌颲狉い햂ᄽ聅▦⎁豳丄㴡툇Ĝ਒률휩劫퉼Ƚⵔ琹Ѝ퀷勱⥊䍚밬矐༂푓혇쬻⁐⒄풱備쎣䢎ꪫ㕜펀⾡抱ₖ䭅걞軇렜뉳약ඓ閦還ᕩ㜁鱘좐꾖蠊凈欆儍乜\\uda48麥뤮윣錪䐵晤Ò晎鬸楮殼⓭惻ᮢ䵚ﴇ找츥ޯ᧬ꡱ꺧蜞牫熠螷ᲈ骡䀥쥚蚪麌목ऑꬊ焖竭懐ꅨ䭞ׅ䂂送芮샞Ḽ壞ㅰ욒ꀵယ゗ᦚ硠遲\\ud902㱫₾꘣䓼듰⽫宰鄛䑭ᄀ党寙幈瑸䙎뚞㮾黌䦆쇀櫮ᦐ㚛퇽ጶ鵧랑㽅邏䐿퇍ꒃᒉ轠჆瀅౐옅ᢵ餱㎰瘜逮糈Ќઌ僖臃ꨏ랦ࠂ㬋쿂嘱ु쭁ࢤ᳄쒢κ簬鵅䚌㑰ﱣꉽ溣ꪀ⤩㷇멾耬১ᛴ잦耎儃艳ᝰ⚀洂\\u0007솸\\u0017넷팋ᓐ譢㎤䬟넃꣋ᗕ邱ﾤ베‡ꘒ쏤锉褀몚勂鍉ûш⺋찀Ꝏส撄乒↋䙽쀋鐢䲩∥㬕娢庥⛚鲪䖖冤ˮꩈ慚꘧꫶뱩຤⏥少ᨤ믣戨䉩鐁採\\ud84e¦⣫`♘혪⩝諸ꔌ涩⚤봦꙰Ɲ좄鹯輦꣑ꏨ⎯㨕箳ꗴٚ黊붠햁鱄戽ϺꀀꄅÁ懇⩪琠幦᱁橉즍䏹頖筡Ꝣᱤ늕ꛇ榀㓶൫媗串짿읦᠂䵾뜧蚔厽︶曼褦慙ዋ꜔讨늉枧ὥ鮩핤⋦ᱪಯ⚻蟉頁䦄ꡋᙙ葷ᮖ䷉憦蒚ɛ餕쭷ᩖ朲뻄⋡ꌗꤞꓕ鲖箩鯈歹㙼\\ud992짺ಖ剩䶆켦홭媰䛵ⷂ赩扲꜃紧䀻׉ഐೆ밅䞭A歠Ǝ㘠㎇頾᧧牦ꎐ⠙폺䤫㾸\\udc5f狱髠属晨◩ꥶ꒽\u2028㏾䞣꯮钩쒫蕀鶑─拻䳨᱅妳柕鞢爹槄㖖蹸\\ud994キ颶擂\\ud9c7▓ﱋ熏虜頒痉꾇㙄槔䆃鳖篾좄懄࡜≙摗偉썧ᖖ[爐鯰紹⊺疙隳㥠蓵雎烶᳤鸖\\udcb4㧜ࣳ鰼紹ʃ蘊悦椄ꆍ炙笕䢕磋蚮ᐄἢ鰀ꘛ厼覩넖旱긤벚齢䍉\\udd83梚湢㤈멺Ӝ巐㛤圭ᡨ檡Ό醼禹镃됊栖蓨舕╁ᥥꂨ澋㤢鰒䔹ඐ岌맰▵饮挹ꑘڟ롫㤱霞揾鋦푌〮맱儧逄孙ィﲔ患船늟裀ᢢǧꤪ⧾뫠ႄ籊叱얈䐿챈꥓ῦ菀௺ﴑ\\ude84䠢䀖䝋Զ鰏咝呂퉢요ˑ夛Ѐ呶躌窎⋇蟦䞣ꄙ葮๑ȹրຄ蘨㧯瘽§灤හ䚢떸Ɋ밐␠鋮錤킓م椡䚨醢䰜鼤\\ud891ꄈ⤋倧멉Ϡᢤ軡㨨䒁텣뭐ᰪⴁ婇崐쁶쩌שῚ䆑䎤껬枿쐫쉷վ懸\\udf95ꤔ撏䳾䢑ᢑ뾐⤐聟䈩Όᒑꛌ愕⒝쉠ৄ揮驓海腒撤筲䫾䅈㋠羔䅿뒮拿醽鿮ꍠ둖肺˾褃띠㥇〉҃둚犛솼㦼쓀仇⋵䰪伌䣱麛벰飈㖀殱흯㨺ꀩ⤊셂䇄똸ἇꀆ鈩⥸Ӷ桎递퐁㢿ျಁㆀ球넙ﮩㅦៜฤじ઱\\ud854ផ䃚倾☼᧴乁됊멣꤂ᐙ쉤ᔘ氃咦腞˕ᖁ覣뢷옍̃⣪氘쮩ᢢ耻⩅▾찐ⅰ〹伈簪밺則А㱦爫畆驘红~쵪ꈴᆂ冬㬵憫쯖⌅䚓툁곔⑈ჸ㛢懭堝䖦៿๡殞䄛ﵣ鑼睠땀ࢄ窾ϭ콑ꄎ䑀ꑖ酾著끥褚࿀☄풉쀟䖡錰跡汒줖ꑕ䀉\\u0002ᝥ₁ιᄡ庇要擛覙ಡᑨᝠ絠Ɱ昩䍵ᖰ袈纐毥照␉䎵裊ꢅꊩྣ᨞肂′ஊ⼦໎瀎儩⥲갇릆噓裏င๧옏갾貸翈뎍乧董诂尾꼾㷠ᰆᄸ텑b੮Ѫ黠륆ᤧ⩅誋ὀƪ鉃郣있飋䛖ƀ굀夑繧烻䑐ኧ金ꀖ椘綠抐ᐎ鳀秶瀖䘧瑇ኢ鞊嬲꒥䭑ꛄ⒚灤‭ᕁ尀᥂茘䉋⧈វൄࠐ먊捄恬諑슝윒ሞ䨂້쀍설ڷԉ⒤㣬䴥ဏᙫᐯ̦\\udf01ཏ⬲昜䀤橶搥끀ꠁ쎡刳芣윀ῂ淂媍䅂缾φ⢤멲ﯪ옫幜䨚㨐ꐂ栅䜰ꐼᝣዢ␠▕넓\\ude32桠ͮ蝡ᄑ뒳㙚㴝Ŏ蠀᧎삱ꚕ⦹뒴旤帆憲ᯒ箋䂂怜ᒄ들䩳㏆∋ႆ腫쨋㡉ꓩ亇ꈖɘ૘秚ং䨭肃퇀ΐ鷈䞣Ṛ堢䂨툞蛐ұ\\ud899왞␠ۉꉻ躈㱼宲⹔砝ꠎꄺ芔睐ꞗ⍡쀣ꖽ或ཹ盰辗礄᥋觤夷ⷀ⠂纀㈫씛衺ỹ䋥袄㬘汖삥ᕹ倸㍁湜\\udb2c䢙㽅達᱕䀌ᕏ苲ꮸƀ桕渏㥪烼Ꜯꥸ㰈훈뎃ꢆ◳ǡ脼㴪谀弈ᾨ㰃雎쐹㳆鏁슝ⱊ☉⩾奜ୀሢ 쨇채唤샊ꭑꙐ騏ᖂ憶蘢㟥큪﹖륌收僱涁펁셔䑡耎⤁୙䚩䟐稔蕌퀃腵䣒⦥౗珉✗励ꊈ\\u0010ን膫싈堪锂垩堸㋺≖ꕑ埋΅嫥뙀砍퀼࢝镄ͥ嶕⏐멛䕷\\udc8cꞘ䆅甼䰺㪉䀿镜⢩嬪ꭑ鸭턥排긚놴럪楕樅邔噐ՆⰕ궔⅐性薣팈轅慶巩ꏃ᜸\\uda46䯔ꓘ鸈꬙ಭ╳⤲怤⬉ꍖ䜛撦镡鍪豞뽦쪟褊ꖫ鲗뒉䭂◆奃ﰕ竮ꈞ自꼆䞩퐩ꕥ擢苦摩ᇈü쏋艀ౕ杸焊䲷㫮ᢈ䄀邁ⱆ蕔㤆䙅桤΀䦣慱諺䀐⺾⥧厧頭㫰欕꿄ᬚ睊鷤㙛㩵衳꧵寚嚚ᮜꙷ脛✜襥䤐ᖕ뒥핟䃮읳꽙智ª䆫Ǆ␊캥쳨斍싫擲⺺⨙넀꫉䀅둑⯻䙍尠鼋䕨墔溜ꩦ䲌ူ봭䐘땏㣱ꅗ띱빀뵐覕䌼鮃뤶묥\\ud940ι肈⪬雮鹱ꭹ択ᕥ㭞胊逵᫗倏⸞葬䛾葦鄮❔곯蠧烟唹鑍䌵飻ꌮ햦宩晵毲ꆤ䞧됯적ব妹錧訡꬙郖凤卡䣾㨖됃涚\\ud96e桛塈䳚\\udb02쪯浄繺樴譅溆탈䮇먨⟮馵즦帖կ驹碤࣬⎺੦螖陿꧄鴞擦쫦ቶ뗫쀣栄뎥\\ude14솖尖畝\\uda1d妍㢌噦犋鹐먂ꇇ增鷕壖峨슦䊓䘨࡙풄▖徦祽혃瀾ዧꖬ㵁ø烹攔ଠ逃闫줪郱増黲慤吠ሑᜬǜ忹姥䙨蔆쐼枛䁀쇗ꌎ뵳㊯榑੤㻵ፑ垷姁ꙷ᎞挵뼡ᐈႄඦᢨ菵ꛕ喛͕竐㖋ꭦ뿀ꕀ猃肃疣އ໽䳘䇺⺍ﵮ萙꧷⼈ဆ癀͐හ栯堓㢹箫㺂餛퓀⺽帵㻖쭜ꡐ륁ꚫ꽍汹玙絛䥹ﬁୱ緅迄ꐂ具飷烕勂ᬑ껋䍻\\udab0⟪Პ崍๠밋蠗൝\\ud91f倒噹﷔䝖祊㟇廒嬮Ⱐᵤ썪밿ᕐ蒡漰㔒鱍㵹떈蒖ൢ裴辔\\udc4d뙋롳\\ud949װꤖꍀ众Й钵ީ汸肂ɭ鞫椻\\ud950ᚧꝩ᩸䁓ꑴԗ䖪僁ꆞ骕䛏፥퐁§蚓婍ā⩎样昔ᚻ菕艍㔶㕝䅒ຫ耎唔ٍ䴶썊ⁿվ䩤桖࣢੉걐܀퉿樻ㆱҲẜ൬攏䖽ᣥ偂뇨㕜䶨δ\\udfe0Ⅵ굡ﺩ瀊吠ౕ䉪\\ud948욀튝ᢦ関콋ԙᝫ꘳櫔홳唔ﱖज़莈䂉煾靌汀遀／衘啭䔘咳砕⬷酔꒸톤읛ྣ空뒤愍媠녝ꋍ嵬ᕍ褵욍楍ၐ퟿̍庘财焟癌顒꒸ᤝ曕쟰Ξ≵൵㎌쯥羀鳫䜍耵䑪돧䍊ꄀ䮩씉獧䵨洭꽑㉛贬\\udb34岀␀갰찬萟ꋋ赀⧔逊Ȱ읏❰낂渉琖痁㝯≘ヾ鎇䮁\\udf3b䭉㮰㇁ᦫ썴苼㒜\\udd83凐倴㵖ਔ犾䍞췭砊彔ὔⵉखɱ器੠毶䷕楠鄩䐈㤶瑀䃹惰ː낀⑊ꀳ⳻០@│滔筘ւ뗘殎苫绸᮳妥盛倔䀚鯭晭䢇⠨竄횇劰㕭ﻖ謍ᵌ챶뙕밐䚡\\ude8c먄怑脖ऺѦ迁諑垸囚맦톀∸⒤㖇ꮕ깕쎻ꑋꇵ뭕㵞訅⺏⊎\\ud9dcᖭ㣙퐤귋뙂䗡㐷☂ऺ扄ȥ亅軒ဎ魩䱄뭰톃㫭Ⳉ⣑暊撱惫皩亶甀혢껮럣入ꈍ\\udeb4㻧\\u0006\\ud880Ⅰ⸫\\uda3c淺㩄讲冭㙁럁魭贤\\uda7d掍᪆ග㵞궖Ʉ༇猀᪃゗Ϟ핳꠺ﰄ䝺궤皐\\uda0e逩ⴤ쬫㭹浦攸峴롵祦㻗몿ဂ떷ₖ徵\\ude5a漟Ј귂Ɗ턫础ⱇ,귲럆ᒫ滠⪴∉鐐새žే洤讐Ⅲ殶껄璴ऄᓭᦶ뽓䍞괙愕⹤鵕譇᫕꬗ව㖟坟궭芵欦בֿ饛횢芀⮭棻裙趨몭铥섂臔ᭀ᠃鎒ꄛ惤鏦ޘ魞䠐脡킻埐\\ud9b6㲍䐮浮矦퍇䶚ꃨ雗窟᷌瓈쥛猀憢뎘甹㨸\\udd4d睠㇕᥂ﭯ맩޶\\udc6a᝭㶵　ݹ斫薺쀂껞㭓嶓똋഻婙闗컗ⵊ⣦柈짗緭\\uddc7滚쵻몀㓙\\ude87沮嗙鴬媽괗翚玥騼혘첎཈⁴鳞ݝ閍ꍅ퇝垭뿆䞜⹊൲㖠퀝改ⶶ닫ᙧ瓑癈䞇䦌ﭲᇜᱚ\\udd69甖\\udf83ⷎꠉ뮮嚭΍\\udfc3堍öⷑ岲\\uddd7ꢹ\\ud983汵葨竐荠\\udd2a杯⊫䣀Ă腑腙賋嬯꾝䙒\\udec4╚‒嗬ꮟ꒻ᨼ䘃嶹샨됴\\udb17儹翅䞝睨릓୷ᜏ敝⸴뢐鵒䲉埀蕆೚쾀폞⶟畕雏罝꒣Ϛདྷꘈ\\ud855䭭戶淔轹\\uddf4팣籚㝵讝⽏燌ꅡ\\ud897ฝ㗒썑倳唏᚛衣絚㞵檂\\ude4f둘뜁㥠텐쫆ꊪ洦ꡠ噪葍埂嵨䃗襄蔼⏀쭙斎钃ㆉᆰง階쉹搪怕∶⟞豂聫쑭渊鉺䏎ત軷ꐎ腽׌鍪䈦֤ړ恗\\udbbe鏧픽✜㚒ꏄ븘㗖鍊囚瀅礷쩒瑷榌р媩纑收\\udd19氩䚟䦸ꒃ階꤆Թ詟瑤욒䑌彏聣垉ᱤ嗴។餀ᤸ刚囩⇈Ẓ緌⌏\\ud829䃀辕ꭈ씙꒠혯\\udfd1煼绐䋞彟׌坒⬐ӬΗ脈々耈肮쿱䢈ꨄⶏŷ魠À鲨鉘襩蚳౲ꗰ占₮텵⫳欨瀍ꏗ䭛쵻舨卶佀昱㧎쥫鑃坲嫒⭞緈媭氋⁪捌䙡ꖔ⓴璠勡⋉媸త쩗朗镚⪧타처\\udc55\\udcdf莽ࠆ䵬⏥矫퐖\\u0007ꗗꋞ虤㔔봇怂㴞䗫킾個琐⩐㌛㹥﷽᠒Ẩ⯠飣ፁ⃪丧햐Ǣ⌀숃ٌꛌ鏼ྏ㟴䔂亍챠uﭠ᢭ሀ⑽﹙ꑕ섌栩䞩浽㤵ꤖ늓線䖝᱓彩⼘䁞쁂׷䐸㏵襸篦鞎ﶆ霂懅篥畓鹭끶잕数՞켦焵謡厘왳ș쁐舸Ჽᵸ餎ᛏ렣ꦈ肜໏ꏬ殺吺샎呭ϫ⅐균\\udf41ᨖ梜뛨䲐쐬및쐃ഩ킼岤ፘ塃৬㹻ࣝ∹奒ꠀ᪠蠘鸪儼Õ霙\\udd23狑嗌౤㳐쥕腖뗥ꔲ㑥ີ☢⊤勁퍀ℚ\\udd54萬撆倿ಫ冷⻐氍趍䉰˳ཕ䓬鶑ṁ뚙泧౴㈱藜싋톤ᵈũ쐶鎀屠\\udcd0詧톲鸢뻃䞂汝ꕫඐ賉蟽怕珻냀噾馀ྖ᜗狛⎑螜ㆈ픔ౠ漅螳5Ⴓ胃蝤蹔ඥ⤛నᘭᧅ踪⺁ᕎ锔➰퍹縺鈴嬝ϴ跮॔㸦潧轚櫌☦ꖏ熜괪鍇ᆇ쪮ħẏ䀽嵋콥㕲⶷퉉ཚ齺䤘搾쎆꬯쵎䓐⎂㚍瘙ꌏ킈蛥嘭紶㓒䄑ⴣ꺵夭ﱥ쪘♠㥱睶ঐיִ㖴覑皹핳瞟巘อ褂蜑戈番쭉ॠ뛚淼琋Ꚛሷ淒꽛煽\\ud89f序걣‥厜㵁燠䦪棰ⶅ蛶Ӕ换큝휫튏䭞㹛ᰮ\\ude70ᯝ衷廔壛놶ꗲ滄蝤橭ꤶ谕\\udb77曭䪧燑ེ嫙眏尧條鮃滝⭔鷼색\\ud8ab秠ੴ᠆ꭑ䃈ɪ\\ude93鎙ᾖ涢ユ\\ude38쩝掴﷒ັ洅ؑꢃ嗣迋줵﨑轎㌣ㅝ⪤嵕ᵧ倕疫඗䟣ᲆ৑\\udb75뀫ꃶ\\udc0d艣翴姚飾\\udc8d琘㠻暝䡙磽豎\\udc80㺝䎌磩⣈㺮祉쑵丸坠ᚳ貽ⶄﮝ勶燙㝼稺뒵盅趡믈Ṣ놗래蝏咍᧥\\ud8d6壣፷矇镘⏋懚ᏸ癇ȯ嵙㩴郞靰穖ƣ딝䩎﷝\\ud83d᷵檑㭫ꈡ鶍鶉揺뜙ై㝜㉏뷕♸嫃趑㞵曉쩴丿魕፹賑㳐褻ⷋ輲誸쒓⪻긾⭦睮㴧兀ષ삀磪굫皩\\udeab窝敀愱ᖎ鵺盵큧匝䃤◕榒嵫甹㣸쾍紉靛䴍퐮镭ㆌ踿涕䷵逘䶵惔ꂸፃ땁㝗氓䖃섷꽢ጯ睠઄䎵뗜薰¹䰾㚻帓ь坚굱ፕ푁㞼䤵⧒嫑㼣⣓㡍껒ͯ죌䶷⡧嵌늕稗Ꮀ胱㚛弓葍⃝⍩捌馯朝䏔Գ񴴤퀡⮀ã媳줸됽郊甾㸮鿝昁퍘읥瘋頤쨝쉏洸ꍎ뵏俻鶦奮㑇戵㰇売퀛忯몐痛佞嚎崷㤃ᢽ䩦\\ud93fꓶ䍧\\udaf2꘠뮁ࣇ飂ณ\\udc4f唘鏒묥㶾揱㗖痓罺\\udd30ᵞ乵ۏ䏝埇珔佯㴩圾Ҹ谤彌ገੌ챿䶐튀ᨀ쵃鯙롐㤅坐¦愳獏ꞓ\\udd63㶲㜳ퟳ뼍轎룒ꍓ痵轃咂E⊩蘖㏄殔열롹淸㊢씸덠軎Ꮜ싣飊掲俭캘타숵ꖜ蝯畜춡\\udeec옝ᬲ㲟雳큯ॆ廁ゐ꽂泌ᒝڠ፣吴쌨䵖玄\\udca0﶑儷섘贽桑≑쏺挐䨏ఆ핃飦ࢾ炞ŉ儇잊Ҕǳ䒓⢃빪늧\\ud91d॑쁶Ꜵ꩐Ⱓ쀬撷\\b\\udc40㋃㹟᤯봱‎9䝢ᔕ苃ᖧ䆽낥ꌪ蔏麭릓㪞㔳䢀砹䁗荗᠔풩免귴쁘გꗁങᇄ雳◠繞嘟㌐\\ude14᜶욃⁎ⅹǟٌ콕儁∄㍲⛻杍寖⇭㥋缸ꐾṯຂㇰ홃⁗蔨䡄湰ⶆ豊ꟳឱ璁鰏ꆒ鮚㙴謎㐀쓰茲㽊빴렁∲꣋ബ僒㬡茉댌＿䩉ⴎ옆㖵粩暙\\ud93f눫댥畕㪴둣ṏ츻䖜催Ľ햭掭\\udea2哒컭蹞ዅ歡譇棚ꩭÚ㖰쎵儇뻋ؒᵉ츴뙺燚ⳃꀞ궝՘袺䀘讬풉㇬식ᳶ뻓赫駐㒹틎迭䘮ೈ玺췝㋏䆳荦ꆭ鵬謴㐤驢\\uda29灆햠鱌꒚㩌\\uddf9,뒣꣨⁥쎃\\ud9f0\\ud8e8࿔​⒑堹ᨩ☴儽娻⣒탙튔䘼⌖맨둇⦂成㣒謴鈑縫꣪䭸캂쳆뙽䅠ἶٯ̊돰㟕斵䢏褂꣼䖖賊㯟整㐭इ蕸ꍳ琢㪕璣憏ᒸ챢ꌬ㊈塄Ȁᄬ蚮咳䂿ᩋⴌ낼≽ಢ⑰뫬國靈ә半ꐈ믂\\udd53Ỏ뉅䓶釀탧箙⹴ꋫȖ㦬츨咆跒耒쓊S呢宓픷⠀䶉鐄ｐ뼣鷎⿝廻撋礇㵘䕁푸떷栳黈펫ڊ㕠ꮪ蘵ꊹ캢㷷ⰶ\\udb45긫郴괻橬⯬ힻ㙗栓圪쮌借懤訩ࡼ섁巂浔⢐玣饃ⵚꭥ㇘͆北璖㧌\\udccc㲱᳚낾䂂뾴퓒万␪珖䷨데倹ܯ憠䳿긆鍴슫懍⪻⮿㎜겲牠ែ㴁ꎱꢒ쿽ۏ河ꃫ郐곇鵻럾Ỳ䣱ຯɎ耳ꭷꄺ㆐ﲭ톤⫀ඡ\\udfc3友胔ꠊ㇩椇㵚瑋㰫폄켪தo\\ud970캗鴊䀐逷톛䬣迦ᧀༀ蠢,듷ꂃ푡悉ᤐ\\uda6c㪍迓\\udf03ᖉ恄ኦ陔ꛍ̕⬖섨閐訬斘偡侞⳼겲崮㆕⼩༱鈊詹ៗ㬝♘⨀ﾘ倩蘆멯㫙๤禒ȴ夰嶑땖䄱띀蹉ꀑ鑶食坩브ኰᑷ\\udf01巳冱晄夡깡≺､枭ᰉ竾샗겯힅㻫酐癋﫝耽邖䤛僤ېﳺᮉ첎᎐切쎃ꀦ肣キ귐ᦌ埉纲骥䖨塦ォừ䃍䪵坸⛘란ꇧą㏩꯮뀰ॊʤ궦疯搯쎜\\ud98c芦\\ude2e春琤沞됟ᢕ垡ꔂ螚ꃵ⩎蔺 唻똎훤䛞⑚됀墲逅뤷ꤟ站᧸㥼쥍뀞南紙邩닔᪛ڗ膽餹쁈롚媜Ⲓᆒ衔僖\\uda5a狂ꧯ钐㉬묓ᤎ꒱顆圩꯫㬥삸魆计⍢ᠷ諰돷韤咙嶺肆箾봡ꀅ봍뢬䡊〴᫈Ĝᩴ㡁鐁ᰗᬀ씺ꚶ輭ᒸᖹᦷᓾ貎ꀦ烒↌\\udcbc๠请仳㱖꧐ꠃ됏೑琀ꈣ槒⹵즔ᙂ饸혓㐎䣝輢妕೦⬢恾蘄\\udb63丯□캫謟뙝☖攎私⚀昌夎ꛪ몃⊽輢禙뛠࣯䥅韕Y筭ဇꓷꥉ攙Ꚗ塹\\uddd4㏕睅ꯥ辇㠽昝ᘯ䚙훷宄郫တὛ뚭ⲥ奵斊늰긹䬋ꜘ확烪곲␄㱅ퟃ䤶쑡思斻㻌㫏ꯗ곥㔏乽녘\\udaa9㽬ໃ꤭럩榎䜵㿰厴˔Ჶ櫙烮ᣀ軶안ʎ옜쥥㶺꽹ꯘ뾬횽蛏붷ᣤ馿滭迶ﾀ胭컛బێ屮Ѷ怅컂혻族櫝ꔽ륭칃쑾Ǌ濮닔➠㞯뚒ž큠ᘪ垦폫٬к쁐䌦湰ខ㦛볣姨䐍魆଀돘㸜렆꣞䒕꽺勬뫘ᙐ覈Ѥхᇠ坌\\ude22!蕔㝞♌瀀㝋଴ꚲ䯌冫⠈녬즌癊ᅇꖧछ뙁幘괍ꅗ죹鼢׭঍愈焟䟖颂὚怊ﶛ՝쭇Ů䮖頇㛑⃄ꦃ쫚흾Ǹฉ各\\ud88e怕襮縋暨쐙᲎ꗗ㫕刼쎳䨗嶖定侖파㕬숫紅႘膕몶낛獫ꪘ园寒ꑭ囂씭\\udb56炽ૼ읷덻鲉内\\udb95ợ륂뒨폥鰠巈䀠쥚쭆ᔕ边띬颶ㄋ䁍鉃댃㑡觯➸ǅ牴ᄨ䢃ឰ棹鲟亸禀긼蠨閜遡逋ợꆆጧ뤝຤\\uda5a芺퓟릉흹豞༡ᔄ匋뀰箢Ø\\uda6aꇍ붵櫜捂뒜겒ሄ뗕쫐퍹쯘ᤴ걎㝘軼꫗ꄫ링蘒薀羾胷ﬄƧ韢昻⽭ꫝ⬟湇㧏啞짊잽쇋⺼ṅ欞\\udeae氇흯ꭃ쒓㈡咹㫭ꇤᴶ䑡ﲇﰈ猳羪൭汻㛁騞뽯ㅙ穉佪윀Ȝ똺懜䤴㗋랠⢇ᳯ硵録箅脠죡츝岒ꇧ鏮ΰ놡\\udb6dᚠ倎蜺獁ﶙԁѽ殐蝡᱘绎햇摺‡患硜푋它於퉞孪觎䝠ꆁᮿ彶鮦婴斻䪕럚﫱鮝봅㺻憃㮿껱냮藮⊦ꎊ簹譁ꘫ㍑黨薝䚨菔盥䭃肊쎆녭郏鋪뾠兺疆탩龡◀疆뀖Q剁렍꛸輟倁삏ḉ㖂ༀ䤠ᐪ骲∀鐎곑횻喺宋䊕렦앛쪋᾵뻮ﱧ㒪⧋속勚ᣘẛ肢Ꮗ交摲㲒᨟ꌈచ⿻ɶ遻䵐胩퉒痊헱ᢚᡈ磍谓ࣗꨇ옦㲉젥\\udbe5耒緱퀄迲鱈൨ჸ鴼眶橾ꐝᘄ넰胀ቤෲ㴧皮遰ࡏ詠욝ఠ෱⠟ܵ軕縩ᴈ뚡\\udab0㲜⡇짺쟌ć㖜Ｔ⮷Ⓠ킕䊒璞씧퉻䀝⟨┲盾ჰ頦唍⧵²鰒眠鞧脠䴊ꧺꝘд纮쐧둴欞묶淌鷑횛\\ude0c㺸卾魃ᵟ㍮췳盬躖松荌竮⤏览ﴷ턔㣹罬蜟פּ⢔喕쀦㹀㵨㯗堇뵰㳸耍嫀ℽ醓枤稴身傔첫᲌㳕⻒榪騵᪢⛣꤇妍䣮꒪煂뱜⩍쫋ꨶ糽䴜槖㶂浹䘻ᾼ㘚ṫ뚏溛浀関쓯䰈쵻뉨蜜ⶸǨ裞\\udb18Ꮹ庆\\udef8텻ⴴ늒ʵ쌞ࢇ䮏\\u001a؝ẘ꿎斾৚ﮭ᳓ഉ텛\\udbef쉷蛢❇穾ظ훶✹혢ᾬ艫鶟ᰂ䴃捺恸겖剾핪ퟰ\\udf59﫧믖选쑿宫汢믻抙꓋趺ᣤ\\udbd7ⷰ밞赓굯䵰᎔鍚奊⸬䢺ʫ鵢ઽ奚\\uda80샞臍\\udb15줒띎茺乴໨赔깹풯檵ꔟ㘔饬澟껵篺䥠㊈⛠靎Ѕ왭Ｌ蝛橖化堍눀昢敶퍛ꮪ᷆㎇䬵됪怊쫽㯩쐦਎쭣ᫎꭐݡ豣፺֞ᰎ怎␘딤h섕욢奴䳪䟴굢뼮³ꐞ兽怦췓惼㛎楿ꫨ捞픠绸쩗犯를嵦㕀뙅켗ࢬ脼\\udb4a霙쫠흗䎐⣣癿\\udea6⒤킓薝焓玵㦑嚸㯐쇗壇嚗癴ർ๑\\udd80혶螟䇚៛쯫℅壧꼻髚폷蜵븘푍擧狛ᜬᷗ춞㧨쫦氱犭皧䨞圆麵翐闱㖏嘇壷均퉝纼퓵沜컓堖㾊⵮﩯陠갂늳껗ꝝ륾痯揙必捅쬓⅝냂鲎앉ꆘ샿叠㒍댶೶덏崀ጶゅ彑하궏퓃穀㢽╟㖸櫢巆껉禘則ꓥᘶ곝礄홗팲镫ꯒ츄⇪퉁僟嵅ꞁ껊秱綾⥔Ù෪돪첚뱘\\ud9ab⡲垕蹥炝倴鑕ﰱ␇瑸ꝵ㛙Ᏽ絟⤆潠㶶컆떩얧셔쒁뚋᥃칖纎՘嵻\\ud9cb杻仸铡櫷㵼쇧뜅朵㌢﬇躘▃倮ۗꁿ쫃︁箞ㆪ㡞싴᳇À끉芃뺚\\uda46ɛ玕酕蝵덀\\udce5ښ햽≲䙶ײሺ鮜⑑菲怍챠﯍ꩨ܈란ㆳ᜔ᖯ⣂षᤃ뱠珦괽儸䂅䍈㈞ڸ낟ﰿ柼쉁മ◠ቓ⃵舺ꄱꄈ얀搈鮊耳頝ኼ塮쁏㑈ᅜ稖ፘ楀㻀﨣 苹莣뗢鉘콷횙⟩™\\ude9c@\\ude50氈ᚶ䓹ꠖ변䎂⭅踚︿ǳ严蜼ꤌ繓켎꒰陉蠯㔢缲蠉렷䧈㽗ӟ෴㹘销莬論憺地㡉ႋ쉫툆༹咚㪺㣺쯫嗆瀠뱞䌈ɀΨࡡ뵕氽饤㰫옌徔姉䚂琄䆊쑪ꄋ㮽茕噿䀻䃚胐坉ِ鍖⍃뉎踭應렀ᐞ씸벃’䄹낝ภࡐ䀀\",\"actionData\",\"errors\"]\n");</script><!--$?--><template id="B:1"></template><!--/$--></div><script>$RB=[];$RV=function(a){$RT=performance.now();for(var b=0;b<a.length;b+=2){var c=a[b],e=a[b+1];null!==e.parentNode&&e.parentNode.removeChild(e);var f=c.parentNode;if(f){var g=c.previousSibling,h=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d||"/&"===d)if(0===h)break;else h--;else"$"!==d&&"$?"!==d&&"$~"!==d&&"$!"!==d&&"&"!==d||h++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;e.firstChild;)f.insertBefore(e.firstChild,c);g.data="$";g._reactRetry&&requestAnimationFrame(g._reactRetry)}}a.length=0};
$RC=function(a,b){if(b=document.getElementById(b))(a=document.getElementById(a))?(a.previousSibling.data="$~",$RB.push(a,b),2===$RB.length&&("number"!==typeof $RT?requestAnimationFrame($RV.bind(null,$RB)):(a=performance.now(),setTimeout($RV.bind(null,$RB),2300>a&&2E3<a?2300-a:$RT+300-a)))):b.parentNode.removeChild(b)};$RC("B:0","S:0")</script><div hidden id="S:1"><script>window.__reactRouterContext.streamController.close();</script></div><script>$RC("B:1","S:1")</script></body></html>