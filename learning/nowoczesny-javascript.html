<!DOCTYPE html><html lang="pl"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="modulepreload" href="/fetch.js"/><link rel="icon" href="/favicon.svg" sizes="any" type="image/svg+xml"/><link rel="preload" as="style" href="/assets/styles-CguqvXB_.css"/><link rel="preload prefetch" href="/fonts/geist.ttf" as="font" type="font/ttf" crossorigin="anonymous"/><title>Renesans w JS, czyli nowoczesny JavaScript - Jakub Szpil</title><meta name="description" content="JavaScript jest językiem programowania, który jest powszechnie stosowany do tworzenia dynamicznych i interaktywnych stron internetowych. W ciągu ostatnich lat JavaScript znacznie ewoluował, wprowadzając nowe funkcje i poprawiając istniejące mechanizmy. W tym kursie omówimy najważniejsze elementy nowoczesnego JavaScript, w tym ES6 i nowsze."/><meta name="keywords" content="javascript,kurs,wprowadzenie,przewodnik,web,frontend,learning"/><meta property="article:published_time" content="2024-06-30T00:00:00.000Z"/><meta property="og:type" content="article"/><meta property="og:url" content="https://jakubszpil.github.io/learning/nowoczesny-javascript/"/><meta property="og:title" content="Renesans w JS, czyli nowoczesny JavaScript - Jakub Szpil"/><meta property="og:description" content="JavaScript jest językiem programowania, który jest powszechnie stosowany do tworzenia dynamicznych i interaktywnych stron internetowych. W ciągu ostatnich lat JavaScript znacznie ewoluował, wprowadzając nowe funkcje i poprawiając istniejące mechanizmy. W tym kursie omówimy najważniejsze elementy nowoczesnego JavaScript, w tym ES6 i nowsze."/><meta property="twitter:card" content="summary_large_image"/><meta property="twitter:url" content="https://jakubszpil.github.io/learning/nowoczesny-javascript/"/><meta property="twitter:title" content="Renesans w JS, czyli nowoczesny JavaScript - Jakub Szpil"/><meta property="twitter:description" content="JavaScript jest językiem programowania, który jest powszechnie stosowany do tworzenia dynamicznych i interaktywnych stron internetowych. W ciągu ostatnich lat JavaScript znacznie ewoluował, wprowadzając nowe funkcje i poprawiając istniejące mechanizmy. W tym kursie omówimy najważniejsze elementy nowoczesnego JavaScript, w tym ES6 i nowsze."/><link rel="modulepreload" href="/assets/manifest-af720f14.js"/><link rel="modulepreload" href="/assets/entry.client-D07Jc1yP.js"/><link rel="modulepreload" href="/assets/jsx-runtime-D_zvdyIk.js"/><link rel="modulepreload" href="/assets/chunk-OIYGIGL5-Rdhby1S0.js"/><link rel="modulepreload" href="/assets/index-DJQXGD61.js"/><link rel="modulepreload" href="/assets/root-yHJ3vYDP.js"/><link rel="modulepreload" href="/assets/layout-DYpV2se7.js"/><link rel="modulepreload" href="/assets/button-BMGgmMxT.js"/><link rel="modulepreload" href="/assets/link-with-prefetch-BIs6hVLd.js"/><link rel="modulepreload" href="/assets/icons-BBGQWBin.js"/><link rel="modulepreload" href="/assets/socials-DGthjeXP.js"/><link rel="modulepreload" href="/assets/date-NK96Yl5Q.js"/><link rel="modulepreload" href="/assets/not-found-CGoFJWhv.js"/><link rel="modulepreload" href="/assets/seo-Do91G143.js"/><link rel="modulepreload" href="/assets/course-details-DLJ6fZBl.js"/><link rel="modulepreload" href="/assets/categories-BBucIGjV.js"/><link rel="modulepreload" href="/assets/edit-resource-Bp0MeTOm.js"/><link rel="modulepreload" href="/assets/banner-DCe0eTPI.js"/><link rel="modulepreload" href="/assets/compress-C_V_4BTm.js"/><link rel="modulepreload" href="/assets/creation-date-x1jkwlYO.js"/><link rel="stylesheet" href="/assets/styles-CguqvXB_.css"/><script>globalThis.timestamp=1761067373760</script><script>let k="theme";let t="dark";let s=localStorage;let c=document.documentElement.classList;let v=s.getItem(k);if(v===null||v==="SYSTEM")matchMedia("(prefers-color-scheme:dark)").matches?c.add(t):c.remove(t);else if(v==="DARK")c.add(t);else if(v==="LIGHT")c.remove(t);else s.removeItem(k);</script><script type="module" src="/fetch.js"></script></head><body style="-webkit-tap-highlight-color:transparent"><header class="sticky w-full bg-background top-0 left-0 z-50 border-b"><div class="container pb-3! pt-4! px-3! flex justify-between items-center"><a data-slot="button" class="button button--variant-ghost button--size-sm font-bold" href="/" data-discover="true">jakubszpil</a><div class="flex flex-1 justify-end items-center sm:gap-1"><nav class="hidden items-center lg:flex"><a data-slot="button" class="button button--variant-ghost button--size-sm" href="/" data-discover="true">🏠 Strona główna</a><a data-slot="button" class="button button--variant-ghost button--size-sm" href="/blog" data-discover="true">📝 Blog</a><a data-slot="button" class="button button--variant-ghost button--size-sm" href="/learning" data-discover="true">🏫 Learning</a><a data-slot="button" class="button button--variant-ghost button--size-sm" href="/portfolio" data-discover="true">🛠️ Portfolio</a><a data-slot="button" class="button button--variant-ghost button--size-sm" href="/me" data-discover="true">🙋‍♂️ O mnie</a></nav><a data-slot="button" class="button button--variant-ghost button--size-icon inline-flex items-center justify-center" aria-label="Szukaj" title="Szukaj (CTRL+K)" href="/search" data-discover="true"><span class="sr-only">Szukaj</span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="size-6"><path d="M10 10m-7 0a7 7 0 1 0 14 0a7 7 0 1 0 -14 0"></path><path d="M21 21l-6 -6"></path></svg></a><div class="hidden xs:flex items-center sm:gap-1"><a href="https://www.linkedin.com/in/jakubszpil/" target="_blank" rel="noreferrer" data-slot="button" class="button button--variant-ghost button--size-icon inline-flex items-center gap-1 no-underline" title="LinkedIn" aria-label="LinkedIn"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="size-6"><path d="M8 11v5"></path><path d="M8 8v.01"></path><path d="M12 16v-5"></path><path d="M16 16v-3a2 2 0 1 0 -4 0"></path><path d="M3 7a4 4 0 0 1 4 -4h10a4 4 0 0 1 4 4v10a4 4 0 0 1 -4 4h-10a4 4 0 0 1 -4 -4z"></path></svg><span class="sr-only">LinkedIn</span></a><a href="https://github.com/jakubszpil/" target="_blank" rel="noreferrer" data-slot="button" class="button button--variant-ghost button--size-icon inline-flex items-center gap-1 no-underline" title="GitHub" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="size-6"><path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5"></path></svg><span class="sr-only">GitHub</span></a></div><button data-slot="dropdown-menu-trigger" class="button button--variant-ghost button--size-icon cursor-pointer" title="Zmień motyw" type="button" id="radix-_R_4ej5_" aria-haspopup="menu" aria-expanded="false" data-state="closed"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="size-6"><path d="M9.173 14.83a4 4 0 1 1 5.657 -5.657"></path><path d="M11.294 12.707l.174 .247a7.5 7.5 0 0 0 8.845 2.492a9 9 0 0 1 -14.671 2.914"></path><path d="M3 12h1"></path><path d="M12 3v1"></path><path d="M5.6 5.6l.7 .7"></path><path d="M3 21l18 -18"></path></svg></button><button data-slot="button" class="button button--variant-link button--size-icon inline-flex items-center justify-center relative z-50 lg:hidden" aria-label="Otwórz menu"><span class="sr-only">Otwórz menu</span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="size-6 text-black! dark:text-white!"><path d="M4 6l16 0"></path><path d="M4 12l16 0"></path><path d="M4 18l16 0"></path></svg></button></div></div></header><main><header class="prose container"><h1 class="mb-5">Renesans w JS, czyli nowoczesny JavaScript</h1><div class="text-xs sm:text-sm my-6"><div class="inline-block" title="Data opublikowania"><span class="mr-0.5">📆</span><span class="hidden">Data opublikowania:</span><time>30 czerwca 2024</time></div><span class="ml-2 mr-1">/</span><div class="inline-block sm:inline" title="Czas potrzebny na przeczytanie"><span class="mr-0.5">⌛</span><span class="hidden">Czas potrzebny na przeczytanie:</span>18 minut<!-- --> czytania</div></div><div class="flex items-center gap-3 flex-wrap"><a data-slot="button" class="button button--variant-secondary button--size-sm no-underline!" href="/learning/kategorie/javascript" data-discover="true">JavaScript</a></div></header><article class="prose container pt-0 prose-emerald"><p>Witaj w świecie <strong>nowoczesnego JavaScriptu</strong>! 🚀 Jeśli HTML to szkielet strony, a CSS to jej wygląd, to JavaScript jest sercem i mózgiem - sprawia, że strona ożywa, staje się interaktywna i dynamiczna. W ciągu ostatnich lat JavaScript przeszedł prawdziwy "renesans". Dzięki wprowadzeniu standardu <strong>ES6</strong> (ECMAScript 2015) i kolejnych aktualizacji, pisanie kodu w JS stało się znacznie przyjemniejsze, bezpieczniejsze i bardziej efektywne.</p>
<p>Ten przewodnik zabierze Cię w podróż po najważniejszych nowościach, które musisz znać, aby pisać <strong>nowoczesny JavaScript</strong>. Nie martw się, jeśli jesteś początkujący/a - wszystko wyjaśnimy krok po kroku, z przykładami i analogiami, byś mógł/mogła od razu zastosować nową wiedzę w praktyce. Czas unowocześnić swoje umiejętności! ✨</p>
<h2 id="spis-treści" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#spis-treści">>></a>Spis treści</h2>
<ol>
<li><a href="#zmienne-let-const-i-zakresy-blokowe--po%C5%BCegnanie-z-var">Zmienne: <code>let</code>, <code>const</code> i zakresy blokowe - pożegnanie z <code>var</code>?</a></li>
<li><a href="#funkcje-strza%C5%82kowe-arrow-functions-i-ich-zastosowania--kr%C3%B3cej-i-czytelniej">Funkcje strzałkowe (Arrow Functions) i ich zastosowania - krócej i czytelniej</a></li>
<li><a href="#szablony-string%C3%B3w-template-literals--%C5%82atwiejsza-praca-z-tekstem">Szablony stringów (Template Literals) - łatwiejsza praca z tekstem</a></li>
<li><a href="#destrukturyzacja-tablic-i-obiekt%C3%B3w--wyci%C4%85gnij-to-czego-potrzebujesz">Destrukturyzacja tablic i obiektów - wyciągnij to, czego potrzebujesz</a></li>
<li><a href="#spread-i-rest-operator---elastyczno%C5%9B%C4%87-w-manipulacji-danymi">Spread i Rest Operator (<code>...</code>) - elastyczność w manipulacji danymi</a></li>
<li><a href="#promise-api-i-obs%C5%82uga-asynchroniczno%C5%9Bci--opowiadaj-historie-o-przysz%C5%82o%C5%9Bci">Promise API i obsługa asynchroniczności - opowiadaj historie o przyszłości</a></li>
<li><a href="#asyncawait--nowoczesna-obs%C5%82uga-kodu-asynchronicznego--pisz-asynchronicznie-my%C5%9Bl-synchronicznie">Async/await - nowoczesna obsługa kodu asynchronicznego - pisz asynchronicznie, myśl synchronicznie</a></li>
<li><a href="#zadania-do-wykonania-sprawd%C5%BA-swoj%C4%85-wiedz%C4%99">Zadania do wykonania: Sprawdź swoją wiedzę!</a></li>
</ol>
<hr>
<h2 id="zmienne-let-const-i-zakresy-blokowe---pożegnanie-z-var" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#zmienne-let-const-i-zakresy-blokowe---pożegnanie-z-var">>></a>Zmienne: <code>let</code>, <code>const</code> i zakresy blokowe - pożegnanie z <code>var</code>?</h2>
<p>W starszych wersjach JavaScriptu zmienne deklarowaliśmy wyłącznie za pomocą słowa kluczowego <code>var</code>. Często prowadziło to do pomyłek i trudnych do wykrycia błędów. Nowoczesny JavaScript wprowadza dwa nowe sposoby deklarowania zmiennych: <strong><code>let</code></strong> i <strong><code>const</code></strong>, które znacznie poprawiają bezpieczeństwo i przewidywalność kodu.</p>
<h3 id="zakres-blokowy-block-scope" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#zakres-blokowy-block-scope">>>></a>Zakres blokowy (<code>block scope</code>)</h3>
<p>To kluczowa różnica! Zmienne zadeklarowane za pomocą <code>let</code> i <code>const</code> mają <strong>zakres blokowy</strong>. Co to znaczy? Oznaczają, że zmienna istnieje tylko w obrębie najbliższego <strong>bloku kodu</strong>, czyli wszystko, co znajduje się między klamrowymi nawiasami <code>{ ... }</code>.</p>
<p>Pomyśl o tym jak o specjalnej, prywatnej przestrzeni. Jeśli zmienna <code>x</code> jest zadeklarowana wewnątrz bloku <code>if</code>, będzie dostępna tylko w tym bloku. Próba użycia jej poza nim spowoduje błąd. To chroni Cię przed przypadkowym nadpisaniem zmiennych o tej samej nazwie w innej części kodu.</p>
<p><strong>Przykład:</strong></p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) {
  <span class="hljs-keyword">let</span> x = <span class="hljs-number">5</span>; <span class="hljs-comment">// x istnieje tylko wewnątrz tego bloku if</span>
  <span class="hljs-keyword">const</span> y = <span class="hljs-number">10</span>; <span class="hljs-comment">// y również istnieje tylko wewnątrz tego bloku</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x); <span class="hljs-comment">// Wyświetli: 5 (dostępne, bo jesteśmy w bloku)</span>
}
<span class="hljs-comment">// console.log(x); // WYWOŁA BŁĄD! ReferenceError: x is not defined</span>
<span class="hljs-comment">// console.log(y); // WYWOŁA BŁĄD! ReferenceError: y is not defined</span>
</code></pre>
<p>Dla porównania, <code>var</code> ma <strong>zakres funkcyjny</strong> (function scope), co oznacza, że zmienna zadeklarowana w funkcji jest dostępna w całej funkcji, ale poza funkcją jest dostępna globalnie, co jest źródłem wielu problemów. Dlatego w nowoczesnym kodzie <strong>zdecydowanie unikamy <code>var</code></strong>.</p>
<h3 id="różnice-między-let-const-i-var" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#różnice-między-let-const-i-var">>>></a>Różnice między <code>let</code>, <code>const</code> i <code>var</code></h3>
<ul>
<li>
<p><strong><code>let</code></strong>:</p>
<ul>
<li><strong>Deklaruje zmienną</strong>, której wartość może być <strong>zmieniana</strong> w dowolnym momencie.</li>
<li>Ma <strong>zakres blokowy</strong>.</li>
<li>Nie można jej ponownie zadeklarować w tym samym bloku (np. <code>let x = 5; let x = 10;</code> to błąd), ale można zmienić jej wartość (<code>x = 10;</code>).</li>
<li>Używaj <code>let</code>, gdy wiesz, że wartość zmiennej będzie się zmieniać (np. licznik w pętli).</li>
</ul>
</li>
<li>
<p><strong><code>const</code></strong>:</p>
<ul>
<li>Deklaruje <strong>stałą</strong>, której wartość musi być <strong>przypisana od razu</strong> i <strong>nie może być zmieniana</strong> później.</li>
<li>Ma <strong>zakres blokowy</strong>.</li>
<li>Jeśli przypiszesz do <code>const</code> obiekt lub tablicę, nie możesz przypisać do niej <em>nowego</em> obiektu/tablicy, ale możesz <strong>modyfikować zawartość</strong> tego obiektu/tablicy (np. dodawać lub usuwać elementy). <code>const</code> gwarantuje, że referencja (wskaźnik) do obiektu pozostaje taka sama, ale nie "zamraża" samego obiektu.</li>
<li>Używaj <code>const</code>, gdy wartość zmiennej nie powinna się zmieniać. To jest domyślny wybór w nowoczesnym JS, chyba że potrzebujesz <code>let</code>.</li>
</ul>
</li>
<li>
<p><strong><code>var</code></strong>:</p>
<ul>
<li><strong>Ma zakres funkcyjny</strong> (lub globalny, jeśli jest poza funkcją).</li>
<li>Jest podatny na <strong>hoisting</strong> (podnoszenie deklaracji), co oznacza, że deklaracja zmiennej jest "przenoszona" na początek zakresu, co może prowadzić do nieintuicyjnych zachowań.</li>
<li>Można go <strong>wielokrotnie deklarować</strong> w tym samym zakresie, co łatwo prowadzi do przypadkowych nadpisań.</li>
<li><strong>Unikaj używania <code>var</code> w nowym kodzie!</strong></li>
</ul>
</li>
</ul>
<p><strong>Przykład <code>const</code> z obiektem/tablicą:</strong></p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> tablica = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
tablica.<span class="hljs-title function_">push</span>(<span class="hljs-number">4</span>); <span class="hljs-comment">// DOZWOLONE! Zmieniamy zawartość tablicy, nie przypisujemy nowej tablicy.</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(tablica); <span class="hljs-comment">// Wyświetli: [1, 2, 3, 4]</span>

<span class="hljs-comment">// tablica = [5, 6]; // WYWOŁA BŁĄD! TypeError: Assignment to constant variable.</span>
<span class="hljs-comment">// Próbujesz przypisać zupełnie nową tablicę do stałej referencji.</span>

<span class="hljs-keyword">const</span> osoba = { <span class="hljs-attr">imie</span>: <span class="hljs-string">"Anna"</span>, <span class="hljs-attr">wiek</span>: <span class="hljs-number">28</span> };
osoba.<span class="hljs-property">wiek</span> = <span class="hljs-number">29</span>; <span class="hljs-comment">// DOZWOLONE! Zmieniamy właściwość obiektu, nie przypisujemy nowego obiektu.</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(osoba); <span class="hljs-comment">// Wyświetli: { imie: "Anna", wiek: 29 }</span>

<span class="hljs-comment">// osoba = { nazwisko: "Nowak" }; // WYWOŁA BŁĄD!</span>
</code></pre>
<hr>
<h2 id="funkcje-strzałkowe-arrow-functions-i-ich-zastosowania---krócej-i-czytelniej" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#funkcje-strzałkowe-arrow-functions-i-ich-zastosowania---krócej-i-czytelniej">>></a>Funkcje strzałkowe (Arrow Functions) i ich zastosowania - krócej i czytelniej</h2>
<p>Funkcje strzałkowe to zwięzła alternatywa dla tradycyjnych funkcji JavaScript, która została wprowadzona w ES6. Są nie tylko krótsze, ale także rozwiązują pewien problem z kontekstem <code>this</code>, który często mylił początkujących programistów.</p>
<h3 id="składnia-funkcji-strzałkowej" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#składnia-funkcji-strzałkowej">>>></a>Składnia funkcji strzałkowej</h3>
<p>Największą zaletą funkcji strzałkowych jest ich zwięzła składnia, zwłaszcza dla prostych funkcji.</p>
<ul>
<li>
<p><strong>Szybszy zapis (szczególnie dla funkcji jedno-liniowych):</strong>
Jeśli funkcja składa się tylko z jednej instrukcji, która zwraca wartość, możesz pominąć nawiasy klamrowe <code>{}</code> i słowo kluczowe <code>return</code>.</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// Tradycyjna funkcja</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">dodajStara</span>(<span class="hljs-params">a, b</span>) {
  <span class="hljs-keyword">return</span> a + b;
}

<span class="hljs-comment">// Funkcja strzałkowa (krótszy zapis)</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">dodaj</span> = (<span class="hljs-params">a, b</span>) => a + b;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">dodaj</span>(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">// Wyświetli: 8</span>

<span class="hljs-comment">// Funkcja z jednym argumentem (można pominąć nawiasy wokół argumentu)</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">powitanie</span> = (<span class="hljs-params">imie</span>) => <span class="hljs-string">`Cześć, <span class="hljs-subst">${imie}</span>!`</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">powitanie</span>(<span class="hljs-string">"Ola"</span>)); <span class="hljs-comment">// Wyświetli: Cześć, Ola!</span>

<span class="hljs-comment">// Funkcja bez argumentów (konieczne puste nawiasy)</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">powiedzHello</span> = (<span class="hljs-params"></span>) => <span class="hljs-string">"Hello!"</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">powiedzHello</span>()); <span class="hljs-comment">// Wyświetli: Hello!</span>
</code></pre>
</li>
<li>
<p><strong>Brak własnego obiektu <code>arguments</code>:</strong> Funkcje strzałkowe nie mają własnego obiektu <code>arguments</code> (który zawiera wszystkie argumenty przekazane do funkcji). Jeśli go potrzebujesz, użyj <strong>rest operatora</strong> (<code>...</code>), o którym powiemy później.</p>
</li>
<li>
<p><strong>Brak możliwości użycia jako konstruktor:</strong> Nie możesz użyć funkcji strzałkowej do tworzenia nowych obiektów za pomocą słowa kluczowego <code>new</code>.</p>
</li>
</ul>
<h3 id="funkcje-strzałkowe-a-kontekst-this" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#funkcje-strzałkowe-a-kontekst-this">>>></a>Funkcje strzałkowe a kontekst <code>this</code></h3>
<p>To jest jeden z najważniejszych powodów, dla których wprowadzono funkcje strzałkowe. W tradycyjnych funkcjach, wartość <code>this</code> zależy od tego, jak funkcja jest wywoływana. To prowadziło do częstych błędów, zwłaszcza w callbackach (funkcjach wywoływanych przez inne funkcje, np. w <code>setTimeout</code> czy w obsłudze zdarzeń).</p>
<p>Funkcje strzałkowe rozwiązują ten problem: <strong>nie mają własnego <code>this</code></strong>. Zamiast tego, <strong>dziedziczą <code>this</code> z otoczenia, w którym zostały zadeklarowane</strong> (tzw. leksykalny <code>this</code>).</p>
<p><strong>Przykład problemu ze <code>this</code> w tradycyjnych funkcjach:</strong></p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// Tradycyjna funkcja, która "gubi" kontekst this</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">TimerProblem</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">sekundy</span> = <span class="hljs-number">0</span>;
  <span class="hljs-built_in">setInterval</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-comment">// Tutaj 'this' nie odnosi się do obiektu TimerProblem,</span>
    <span class="hljs-comment">// ale do obiektu globalnego (np. window w przeglądarce) lub jest undefined w trybie 'strict mode'</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">sekundy</span>++; <span class="hljs-comment">// To nie zadziała tak, jak byśmy chcieli!</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">sekundy</span>);
  }, <span class="hljs-number">1000</span>);
}
<span class="hljs-comment">// new TimerProblem(); // W konsoli prawdopodobnie zobaczysz NaN lub błąd</span>
</code></pre>
<p><strong>Rozwiązanie z funkcją strzałkową:</strong></p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">TimerPoprawny</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">sekundy</span> = <span class="hljs-number">0</span>;
  <span class="hljs-comment">// Funkcja strzałkowa dziedziczy 'this' z TimerPoprawny (czyli z obiektu TimerPoprawny)</span>
  <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">sekundy</span>++;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Sekundy: <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.sekundy}</span>`</span>);
  }, <span class="hljs-number">1000</span>);
}
<span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerPoprawny</span>(); <span class="hljs-comment">// Będzie poprawnie liczyć sekundy: Sekundy: 1, Sekundy: 2, itd.</span>
</code></pre>
<p>Dzięki temu funkcje strzałkowe są idealne do użycia w callbackach, metodach obiektów (choć nie jako metody obiektów najwyższego poziomu, bo wtedy <code>this</code> wskazałoby na <code>window</code>), czy w sytuacjach, gdzie chcesz, aby <code>this</code> zachowało kontekst nadrzędny.</p>
<hr>
<h2 id="szablony-stringów-template-literals---łatwiejsza-praca-z-tekstem" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#szablony-stringów-template-literals---łatwiejsza-praca-z-tekstem">>></a>Szablony stringów (Template Literals) - łatwiejsza praca z tekstem</h2>
<p>Szablony stringów, wprowadzone w ES6, to potężne narzędzie do tworzenia ciągów znaków (stringów). Zastępują tradycyjne łączenie stringów za pomocą operatora <code>+</code> i oferują znacznie większą elastyczność i czytelność. Używamy ich, otaczając tekst <strong>backtickami</strong> (apostrofami wstecznymi) <code> </code> zamiast pojedynczych lub podwójnych cudzysłowów.</p>
<h3 id="interpolacja-i-wielolinijkowość" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#interpolacja-i-wielolinijkowość">>>></a>Interpolacja i wielolinijkowość</h3>
<ul>
<li>
<p><strong>Interpolacja zmiennych i wyrażeń:</strong>
Możesz łatwo osadzać zmienne lub dowolne wyrażenia JavaScript bezpośrednio w stringu, używając składni <code>${...}</code>. To znacznie ułatwia budowanie dynamicznych komunikatów.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> imie = <span class="hljs-string">"Alicja"</span>;
<span class="hljs-keyword">const</span> wiek = <span class="hljs-number">30</span>;

<span class="hljs-comment">// Stary sposób: męczące łączenie stringów</span>
<span class="hljs-keyword">const</span> infoStare = <span class="hljs-string">"Mam na imię "</span> + imie + <span class="hljs-string">" i mam "</span> + wiek + <span class="hljs-string">" lat."</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(infoStare); <span class="hljs-comment">// Wyświetli: Mam na imię Alicja i mam 30 lat.</span>

<span class="hljs-comment">// Nowy sposób z szablonami stringów: czytelniej i prościej!</span>
<span class="hljs-keyword">const</span> infoNowe = <span class="hljs-string">`Mam na imię <span class="hljs-subst">${imie}</span> i mam <span class="hljs-subst">${wiek}</span> lat.`</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(infoNowe); <span class="hljs-comment">// Wyświetli: Mam na imię Alicja i mam 30 lat.</span>

<span class="hljs-comment">// Możesz umieszczać dowolne wyrażenia JavaScript:</span>
<span class="hljs-keyword">const</span> cena = <span class="hljs-number">10.5</span>;
<span class="hljs-keyword">const</span> ilosc = <span class="hljs-number">2</span>;
<span class="hljs-keyword">const</span> rachunek = <span class="hljs-string">`Koszt zakupu: <span class="hljs-subst">${cena * ilosc}</span> zł.`</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(rachunek); <span class="hljs-comment">// Wyświetli: Koszt zakupu: 21 zł.</span>
</code></pre>
</li>
<li>
<p><strong>Łatwe tworzenie tekstów wielolinijkowych:</strong>
Koniec z dodawaniem <code>n</code> do każdej linii! W szablonach stringów możesz po prostu nacisnąć Enter, a tekst zachowa formatowanie z nowymi liniami. Jest to szczególnie przydatne przy generowaniu fragmentów HTML bezpośrednio w JavaScript.</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// Stary sposób: brzydkie i niewygodne</span>
<span class="hljs-keyword">const</span> htmlStare =
  <span class="hljs-string">"&#x3C;div>\n  &#x3C;h1>Witaj!&#x3C;/h1>\n  &#x3C;p>To jest wielolinijkowy tekst.&#x3C;/p>\n&#x3C;/div>"</span>;

<span class="hljs-comment">// Nowy sposób: super czytelne!</span>
<span class="hljs-keyword">const</span> htmlNowe = <span class="hljs-string">`
  &#x3C;div>
    &#x3C;h1>Witaj!&#x3C;/h1>
    &#x3C;p>To jest wielolinijkowy tekst. I kolejna linia w tym samym akapicie.&#x3C;/p>
  &#x3C;/div>
`</span>;

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(htmlNowe);
</code></pre>
</li>
</ul>
<h3 id="dodatkowe-możliwości" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#dodatkowe-możliwości">>>></a>Dodatkowe możliwości</h3>
<p>Szablony stringów wspierają także tzw. <strong>tagowane szablony</strong> (<code>tagged templates</code>), które pozwalają na zaawansowaną manipulację tekstem przed jego finalnym utworzeniem. Możesz zdefiniować funkcję ("tag"), która będzie przetwarzać części stringu i wartości zmiennych. Jest to bardziej zaawansowana funkcja, używana np. do tłumaczeń, walidacji, bezpiecznego generowania HTML (zapobieganie XSS) czy formatowania danych.</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// Przykład funkcji "tagującej"</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">upper</span>(<span class="hljs-params">strings, ...values</span>) {
  <span class="hljs-comment">// 'strings' to tablica tekstów, 'values' to tablica zmiennych</span>
  <span class="hljs-keyword">let</span> wynik = strings[<span class="hljs-number">0</span>];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &#x3C; values.<span class="hljs-property">length</span>; i++) {
    wynik += values[i].<span class="hljs-title function_">toUpperCase</span>() + strings[i + <span class="hljs-number">1</span>]; <span class="hljs-comment">// Zamienia zmienne na duże litery</span>
  }
  <span class="hljs-keyword">return</span> wynik;
}

<span class="hljs-keyword">const</span> imie = <span class="hljs-string">"Kasia"</span>;
<span class="hljs-keyword">const</span> wiek = <span class="hljs-number">20</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(upper<span class="hljs-string">`Cześć, <span class="hljs-subst">${imie}</span>! Masz <span class="hljs-subst">${wiek}</span> lat?`</span>); <span class="hljs-comment">// Wyświetli: Cześć, KASIA! Masz 20 lat?</span>
</code></pre>
<p>W tym przykładzie funkcja <code>upper</code> została "przypięta" do szablonu stringu i zmodyfikowała zmienną <code>imie</code> na wielkie litery.</p>
<hr>
<h2 id="destrukturyzacja-tablic-i-obiektów---wyciągnij-to-czego-potrzebujesz" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#destrukturyzacja-tablic-i-obiektów---wyciągnij-to-czego-potrzebujesz">>></a>Destrukturyzacja tablic i obiektów - wyciągnij to, czego potrzebujesz</h2>
<p>Destrukturyzacja to potężna i bardzo często używana funkcja w nowoczesnym JavaScript. Pozwala na "rozpakowanie" wartości z tablic lub właściwości z obiektów do oddzielnych zmiennych w bardzo zwięzły i czytelny sposób. Upraszcza kod i czyni go bardziej deklaratywnym.</p>
<h3 id="destrukturyzacja-tablic" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#destrukturyzacja-tablic">>>></a>Destrukturyzacja tablic</h3>
<p>Pozwala na szybkie przypisanie wartości z tablicy do zmiennych, bazując na ich pozycji.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> kolory = [<span class="hljs-string">"czerwony"</span>, <span class="hljs-string">"zielony"</span>, <span class="hljs-string">"niebieski"</span>];

<span class="hljs-comment">// Stary sposób:</span>
<span class="hljs-comment">// const kolor1 = kolory[0];</span>
<span class="hljs-comment">// const kolor2 = kolory[1];</span>

<span class="hljs-comment">// Nowy sposób z destrukturyzacją tablic:</span>
<span class="hljs-keyword">const</span> [pierwszyKolor, drugiKolor, trzeciKolor] = kolory;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pierwszyKolor); <span class="hljs-comment">// Wyświetli: czerwony</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(drugiKolor); <span class="hljs-comment">// Wyświetli: zielony</span>

<span class="hljs-comment">// Można pomijać niektóre elementy (używając przecinków):</span>
<span class="hljs-keyword">const</span> [a, , b] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]; <span class="hljs-comment">// Pomijamy drugi element (2)</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a, b); <span class="hljs-comment">// Wyświetli: 1 3</span>

<span class="hljs-comment">// Można przypisać wartości domyślne, jeśli element nie istnieje:</span>
<span class="hljs-keyword">const</span> [x, y, z = <span class="hljs-string">"domyślny"</span>] = [<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x, y, z); <span class="hljs-comment">// Wyświetli: A B domyślny</span>

<span class="hljs-comment">// Można zbierać pozostałe elementy do nowej tablicy (rest operator - patrz dalej):</span>
<span class="hljs-keyword">const</span> [pierwszy, ...resztaKolorow] = kolory;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pierwszy); <span class="hljs-comment">// Wyświetli: czerwony</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(resztaKolorow); <span class="hljs-comment">// Wyświetli: ["zielony", "niebieski"]</span>
</code></pre>
<h3 id="destrukturyzacja-obiektów" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#destrukturyzacja-obiektów">>>></a>Destrukturyzacja obiektów</h3>
<p>Pozwala na przypisanie wartości z obiektu do zmiennych na podstawie nazw ich <strong>kluczy (właściwości)</strong>. Kolejność nie ma znaczenia, liczy się nazwa klucza.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> samochod = { <span class="hljs-attr">marka</span>: <span class="hljs-string">"Ford"</span>, <span class="hljs-attr">model</span>: <span class="hljs-string">"Focus"</span>, <span class="hljs-attr">rok</span>: <span class="hljs-number">2018</span> };

<span class="hljs-comment">// Stary sposób:</span>
<span class="hljs-comment">// const markaSamochodu = samochod.marka;</span>
<span class="hljs-comment">// const modelSamochodu = samochod.model;</span>

<span class="hljs-comment">// Nowy sposób z destrukturyzacją obiektów:</span>
<span class="hljs-keyword">const</span> { marka, model } = samochod;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(marka); <span class="hljs-comment">// Wyświetli: Ford</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(model); <span class="hljs-comment">// Wyświetli: Focus</span>

<span class="hljs-comment">// Można przypisać wartości domyślne, jeśli właściwość nie istnieje:</span>
<span class="hljs-keyword">const</span> { <span class="hljs-attr">marka</span>: m, kolor = <span class="hljs-string">"czarny"</span> } = samochod; <span class="hljs-comment">// 'kolor' nie istnieje w obiekcie 'samochod'</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(m, kolor); <span class="hljs-comment">// Wyświetli: Ford czarny</span>

<span class="hljs-comment">// Można zmienić nazwę zmiennej, do której przypisujemy wartość:</span>
<span class="hljs-keyword">const</span> { <span class="hljs-attr">marka</span>: nazwaMarki, <span class="hljs-attr">model</span>: typModelu } = samochod;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(nazwaMarki, typModelu); <span class="hljs-comment">// Wyświetli: Ford Focus</span>

<span class="hljs-comment">// Można też zbierać pozostałe właściwości do nowego obiektu (rest operator - patrz dalej):</span>
<span class="hljs-keyword">const</span> { rok, ...resztaSamochodu } = samochod;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(rok); <span class="hljs-comment">// Wyświetli: 2018</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(resztaSamochodu); <span class="hljs-comment">// Wyświetli: { marka: "Ford", model: "Focus" }</span>
</code></pre>
<p>Destrukturyzacja jest szczególnie przydatna w funkcjach, gdy chcesz łatwo wyciągnąć konkretne dane z obiektów konfiguracyjnych lub z wyników API.</p>
<hr>
<h2 id="spread-i-rest-operator----elastyczność-w-manipulacji-danymi" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#spread-i-rest-operator----elastyczność-w-manipulacji-danymi">>></a>Spread i Rest Operator (<code>...</code>) - elastyczność w manipulacji danymi</h2>
<p>Operator <code>...</code> (trzy kropki) jest jednym z najbardziej uniwersalnych i potężnych narzędzi w nowoczesnym JavaScript. Nazywany jest <strong>operatorem spread</strong> lub <strong>operatorem rest</strong>, w zależności od kontekstu, w jakim jest używany.</p>
<h3 id="spread-operator-operator-rozproszenia" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#spread-operator-operator-rozproszenia">>>></a>Spread Operator (operator rozproszenia)</h3>
<p>Gdy używasz <code>...</code> do <strong>rozbicia</strong> elementów tablicy lub właściwości obiektu na pojedyncze elementy, mówimy o <strong>operatorze spread</strong>. Jest to jak "rozłożenie" zawartości kolekcji. 🌐</p>
<p><strong>Zastosowania Spread Operatora:</strong></p>
<ul>
<li>
<p><strong>Kopiowanie i łączenie tablic:</strong> Tworzenie płytkich kopii tablic lub łączenie ich bez modyfikowania oryginalnych.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> cyfry = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-keyword">const</span> noweCyfry = [...cyfry, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]; <span class="hljs-comment">// Rozwija [1, 2, 3] do 1, 2, 3, a potem dodaje 4, 5</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(noweCyfry); <span class="hljs-comment">// Wyświetli: [1, 2, 3, 4, 5]</span>

<span class="hljs-keyword">const</span> tablica1 = [<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>];
<span class="hljs-keyword">const</span> tablica2 = [<span class="hljs-string">"c"</span>, <span class="hljs-string">"d"</span>];
<span class="hljs-keyword">const</span> polaczoneTablice = [...tablica1, ...tablica2];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(polaczoneTablice); <span class="hljs-comment">// Wyświetli: ["a", "b", "c", "d"]</span>
</code></pre>
</li>
<li>
<p><strong>Kopiowanie i łączenie obiektów:</strong> Podobnie jak z tablicami, możesz tworzyć kopie obiektów i łączyć ich właściwości.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> osoba = { <span class="hljs-attr">imie</span>: <span class="hljs-string">"Anna"</span>, <span class="hljs-attr">wiek</span>: <span class="hljs-number">28</span> };
<span class="hljs-keyword">const</span> osobaZZawodem = { ...osoba, <span class="hljs-attr">zawod</span>: <span class="hljs-string">"Programista"</span> };
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(osobaZZawodem); <span class="hljs-comment">// Wyświetli: { imie: "Anna", wiek: 28, zawod: "Programista" }</span>

<span class="hljs-keyword">const</span> daneKontaktowe = { <span class="hljs-attr">email</span>: <span class="hljs-string">"a@example.com"</span>, <span class="hljs-attr">telefon</span>: <span class="hljs-string">"123-456-789"</span> };
<span class="hljs-keyword">const</span> pelneDane = { ...osoba, ...daneKontaktowe };
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pelneDane); <span class="hljs-comment">// Wyświetli: { imie: "Anna", wiek: 28, email: "a@example.com", telefon: "123-456-789" }</span>
</code></pre>
<p>Jeśli klucze się powtarzają, ostatnia wartość nadpisuje poprzednią.</p>
</li>
<li>
<p><strong>Przekazywanie argumentów funkcji:</strong> Możesz rozwijać tablicę jako argumenty funkcji.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sumuj</span>(<span class="hljs-params">a, b, c</span>) {
  <span class="hljs-keyword">return</span> a + b + c;
}
<span class="hljs-keyword">const</span> liczby = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sumuj</span>(...liczby)); <span class="hljs-comment">// Rozwija [10, 20, 30] do sumuj(10, 20, 30), wyświetli: 60</span>
</code></pre>
</li>
</ul>
<h3 id="rest-operator-operator-reszty" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#rest-operator-operator-reszty">>>></a>Rest Operator (operator reszty)</h3>
<p>Gdy używasz <code>...</code> do <strong>zbierania</strong> wielu elementów w jedną tablicę (lub właściwości w obiekt), mówimy o <strong>operatorze rest</strong>. Jest to jak "zbieranie" luźnych elementów w jedną kolekcję. 🧺</p>
<p><strong>Zastosowania Rest Operatora:</strong></p>
<ul>
<li>
<p><strong>Zbieranie argumentów funkcji:</strong> Pozwala funkcji przyjmować nieokreśloną liczbę argumentów i traktować je jako tablicę.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">suma</span>(<span class="hljs-params">...liczby</span>) {
  <span class="hljs-comment">// 'liczby' zbiera wszystkie przekazane argumenty w tablicę</span>
  <span class="hljs-keyword">return</span> liczby.<span class="hljs-title function_">reduce</span>(
    <span class="hljs-function">(<span class="hljs-params">akumulator, aktualnaLiczba</span>) =></span> akumulator + aktualnaLiczba,
    <span class="hljs-number">0</span>
  );
}
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">suma</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">// Wyświetli: 6</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">suma</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>)); <span class="hljs-comment">// Wyświetli: 100</span>
</code></pre>
</li>
<li>
<p><strong>W destrukturyzacji (jak widzieliśmy wcześniej):</strong> Zbieranie pozostałych elementów do nowej tablicy lub obiektu.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> [pierwszy, drugi, ...resztaTablicy] = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pierwszy); <span class="hljs-comment">// Wyświetli: 10</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(drugi); <span class="hljs-comment">// Wyświetli: 20</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(resztaTablicy); <span class="hljs-comment">// Wyświetli: [30, 40, 50]</span>

<span class="hljs-keyword">const</span> { imie, ...resztaOsoby } = {
  <span class="hljs-attr">imie</span>: <span class="hljs-string">"Ola"</span>,
  <span class="hljs-attr">wiek</span>: <span class="hljs-number">25</span>,
  <span class="hljs-attr">miasto</span>: <span class="hljs-string">"Warszawa"</span>,
};
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(imie); <span class="hljs-comment">// Wyświetli: Ola</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(resztaOsoby); <span class="hljs-comment">// Wyświetli: { wiek: 25, miasto: "Warszawa" }</span>
</code></pre>
</li>
</ul>
<p>Zarówno spread, jak i rest operator są niezwykle przydatne i sprawiają, że kod jest znacznie bardziej zwięzły i czytelny, szczególnie podczas pracy z tablicami i obiektami.</p>
<hr>
<h2 id="promise-api-i-obsługa-asynchroniczności---opowiadaj-historie-o-przyszłości" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#promise-api-i-obsługa-asynchroniczności---opowiadaj-historie-o-przyszłości">>></a>Promise API i obsługa asynchroniczności - opowiadaj historie o przyszłości</h2>
<p>JavaScript jest językiem <strong>jednowątkowym</strong>, co oznacza, że może wykonywać tylko jedną operację w danym momencie. Jednak wiele operacji, takich jak pobieranie danych z internetu, odczyt plików, czy operacje na bazie danych, trwa pewien czas. Gdyby JavaScript musiał czekać na ich zakończenie, strona internetowa by się "zawiesiła" (nie reagowałaby na kliknięcia, przewijanie itp.).</p>
<p>Tutaj wkracza <strong>asynchroniczność</strong>. Pozwala ona na rozpoczęcie operacji, a następnie przejście do kolejnych zadań, nie czekając na zakończenie tej pierwszej. Kiedy asynchroniczna operacja się zakończy, JavaScript wróci do niej i wykona dalsze kroki.</p>
<p>Starszym sposobem obsługi asynchroniczności były <strong>callbacki</strong> (funkcje zwrotne), które jednak często prowadziły do tzw. "callback hell" (piekła callbacków) - zagnieżdżonego, trudnego do czytania i utrzymania kodu.</p>
<h3 id="czym-jest-promise" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#czym-jest-promise">>>></a>Czym jest Promise?</h3>
<p><strong>Promise (Obietnica)</strong> to obiekt w JavaScript, który reprezentuje ostateczne zakończenie (lub niepowodzenie) operacji asynchronicznej. Możesz myśleć o Promise jako o "przyszłej wartości". Składasz obietnicę, że w przyszłości otrzymasz wynik - albo sukces, albo błąd. 📦</p>
<p>Promise może znajdować się w jednym z trzech stanów:</p>
<ol>
<li><strong><code>pending</code> (oczekujący)</strong>: Początkowy stan; ani spełniony, ani odrzucony. Operacja asynchroniczna nadal trwa.</li>
<li><strong><code>fulfilled</code> (spełniony)</strong>: Operacja asynchroniczna zakończyła się sukcesem i zwróciła wartość.</li>
<li><strong><code>rejected</code> (odrzucony)</strong>: Operacja asynchroniczna zakończyła się błędem.</li>
</ol>
<p>Możesz "podpiąć" funkcje, które zostaną wywołane, gdy Promise zmieni swój stan:</p>
<ul>
<li><strong><code>.then()</code></strong>: Wywoływany, gdy Promise zostanie <code>fulfilled</code> (operacja zakończy się sukcesem). Otrzymuje wartość zwróconą przez Promise.</li>
<li><strong><code>.catch()</code></strong>: Wywoływany, gdy Promise zostanie <code>rejected</code> (wystąpi błąd). Otrzymuje obiekt błędu.</li>
<li><strong><code>.finally()</code></strong>: Wywoływany zawsze, niezależnie od tego, czy Promise zakończył się sukcesem, czy błędem. Idealny do czyszczenia zasobów.</li>
</ul>
<p><strong>Przykład tworzenia i używania Promise:</strong></p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> obietnica = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> {
  <span class="hljs-comment">// Symulujemy operację asynchroniczną (np. pobieranie danych)</span>
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-keyword">const</span> sukces = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() > <span class="hljs-number">0.5</span>; <span class="hljs-comment">// Losowo decydujemy o sukcesie lub błędzie</span>

    <span class="hljs-keyword">if</span> (sukces) {
      <span class="hljs-title function_">resolve</span>(<span class="hljs-string">"Dane pobrane pomyślnie!"</span>); <span class="hljs-comment">// Jeśli sukces, wywołujemy resolve z wynikiem</span>
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"Nie udało się pobrać danych."</span>)); <span class="hljs-comment">// Jeśli błąd, wywołujemy reject z błędem</span>
    }
  }, <span class="hljs-number">2000</span>); <span class="hljs-comment">// Operacja trwa 2 sekundy</span>
});

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Rozpoczęto operację..."</span>);

obietnica
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">wiadomosc</span>) =></span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"SUKCES:"</span>, wiadomosc); <span class="hljs-comment">// Wykona się, jeśli obietnica się spełni</span>
  })
  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">blad</span>) =></span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"BŁĄD:"</span>, blad.<span class="hljs-property">message</span>); <span class="hljs-comment">// Wykona się, jeśli obietnica zostanie odrzucona</span>
  })
  .<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Operacja zakończona (niezależnie od wyniku)."</span>); <span class="hljs-comment">// Wykona się zawsze</span>
  });

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Kod po obietnicy nadal się wykonuje..."</span>); <span class="hljs-comment">// Pokazuje asynchroniczność</span>
</code></pre>
<h3 id="łańcuchy-promise-promise-chaining" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#łańcuchy-promise-promise-chaining">>>></a>Łańcuchy Promise (<code>Promise Chaining</code>)</h3>
<p>Jedną z największych zalet Promise jest możliwość łączenia wielu operacji asynchronicznych w jeden czytelny "łańcuch". Każdy <code>.then()</code> zwraca nowy Promise, co pozwala na kolejne <code>.then()</code> wywołane po sobie. Jest to idealne, gdy jedna operacja asynchroniczna zależy od wyniku poprzedniej.</p>
<p><strong>Przykład łańcucha Promise (pobieranie danych z API):</strong></p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// fetch() to wbudowana funkcja JS, która zwraca Promise</span>
<span class="hljs-title function_">fetch</span>(<span class="hljs-string">"https://jsonplaceholder.typicode.com/users/1"</span>) <span class="hljs-comment">// Pobierz dane użytkownika o ID 1</span>
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">response</span>) =></span> {
    <span class="hljs-comment">// Pierwsze .then: sprawdź, czy odpowiedź jest OK i sparsuj ją jako JSON</span>
    <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`Błąd HTTP! Status: <span class="hljs-subst">${response.status}</span>`</span>);
    }
    <span class="hljs-keyword">return</span> response.<span class="hljs-title function_">json</span>(); <span class="hljs-comment">// Zwróć kolejny Promise z danymi JSON</span>
  })
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">user</span>) =></span> {
    <span class="hljs-comment">// Drugie .then: otrzymaj sparsowane dane użytkownika</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Pobrany użytkownik:"</span>, user.<span class="hljs-property">name</span>, user.<span class="hljs-property">email</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">fetch</span>(
      <span class="hljs-string">`https://jsonplaceholder.typicode.com/posts?userId=<span class="hljs-subst">${user.id}</span>`</span>
    ); <span class="hljs-comment">// Pobierz posty tego użytkownika</span>
  })
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">response</span>) =></span> {
    <span class="hljs-comment">// Trzecie .then: sprawdź odpowiedź i sparsuj posty</span>
    <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`Błąd HTTP! Status: <span class="hljs-subst">${response.status}</span>`</span>);
    }
    <span class="hljs-keyword">return</span> response.<span class="hljs-title function_">json</span>();
  })
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">posts</span>) =></span> {
    <span class="hljs-comment">// Czwarte .then: otrzymaj posty</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Liczba postów użytkownika:"</span>, posts.<span class="hljs-property">length</span>);
  })
  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =></span> {
    <span class="hljs-comment">// .catch: Obsłuż każdy błąd, który wystąpił na dowolnym etapie łańcucha</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"Wystąpił błąd w łańcuchu Promise:"</span>, error);
  })
  .<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Pobieranie danych zakończone."</span>);
  });
</code></pre>
<p>Promise to podstawa nowoczesnego JS w obsłudze asynchroniczności, a kolejny rozdział pokaże Ci, jak jeszcze bardziej uprościć ich użycie.</p>
<hr>
<h2 id="asyncawait---nowoczesna-obsługa-kodu-asynchronicznego---pisz-asynchronicznie-myśl-synchronicznie" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#asyncawait---nowoczesna-obsługa-kodu-asynchronicznego---pisz-asynchronicznie-myśl-synchronicznie">>></a>Async/await - nowoczesna obsługa kodu asynchronicznego - pisz asynchronicznie, myśl synchronicznie</h2>
<p>Mimo że Promise są ogromnym krokiem naprzód w porównaniu do callbacków, kod z długimi łańcuchami <code>.then().then().catch()</code> może wciąż być trudny do czytania. Standard ES2017 wprowadził słowa kluczowe <strong><code>async</code></strong> i <strong><code>await</code></strong>, które pozwalają pisać kod asynchroniczny w sposób, który wygląda i zachowuje się niemal identycznie jak kod synchroniczny, jednocześnie zachowując asynchroniczną naturę. To game changer! 🎮</p>
<h3 id="uproszczenie-pracy-z-promise" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#uproszczenie-pracy-z-promise">>>></a>Uproszczenie pracy z Promise</h3>
<ul>
<li><strong><code>async</code></strong>: Musisz oznaczyć funkcję słowem kluczowym <code>async</code>, aby móc używać w niej <code>await</code>. Funkcja <code>async</code> <strong>zawsze zwraca Promise</strong>, nawet jeśli zwrócisz w niej zwykłą wartość - JavaScript automatycznie opakuje ją w Promise.</li>
<li><strong><code>await</code></strong>: Słowo kluczowe <code>await</code> może być użyte <strong>tylko wewnątrz funkcji <code>async</code></strong>. Powoduje ono, że wykonanie funkcji <code>async</code> zostaje <strong>wstrzymane</strong>, dopóki Promise, na który czeka <code>await</code>, nie zostanie <strong>spełniony (fulfilled)</strong>. Kiedy Promise się spełni, <code>await</code> "rozpakowuje" jego wartość i przypisuje ją do zmiennej. Jeśli Promise zostanie odrzucony (rejected), <code>await</code> "wyrzuci" błąd, który możesz obsłużyć za pomocą <code>try...catch</code>.</li>
</ul>
<p><strong>Przykład użycia <code>async/await</code> (porównaj z przykładem z Promise Chaining):</strong></p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">pobierzDaneUzytkownikaIPosty</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Rozpoczynam pobieranie danych..."</span>);

    <span class="hljs-comment">// Krok 1: Pobierz dane użytkownika</span>
    <span class="hljs-keyword">const</span> userResponse = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(
      <span class="hljs-string">"https://jsonplaceholder.typicode.com/users/1"</span>
    );
    <span class="hljs-keyword">if</span> (!userResponse.<span class="hljs-property">ok</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(
        <span class="hljs-string">`Błąd HTTP przy pobieraniu użytkownika! Status: <span class="hljs-subst">${userResponse.status}</span>`</span>
      );
    }
    <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> userResponse.<span class="hljs-title function_">json</span>(); <span class="hljs-comment">// Poczekaj na parsowanie JSON</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Pobrany użytkownik:"</span>, user.<span class="hljs-property">name</span>, user.<span class="hljs-property">email</span>);

    <span class="hljs-comment">// Krok 2: Pobierz posty tego użytkownika</span>
    <span class="hljs-keyword">const</span> postsResponse = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(
      <span class="hljs-string">`https://jsonplaceholder.typicode.com/posts?userId=<span class="hljs-subst">${user.id}</span>`</span>
    );
    <span class="hljs-keyword">if</span> (!postsResponse.<span class="hljs-property">ok</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(
        <span class="hljs-string">`Błąd HTTP przy pobieraniu postów! Status: <span class="hljs-subst">${postsResponse.status}</span>`</span>
      );
    }
    <span class="hljs-keyword">const</span> posts = <span class="hljs-keyword">await</span> postsResponse.<span class="hljs-title function_">json</span>(); <span class="hljs-comment">// Poczekaj na parsowanie JSON</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Liczba postów użytkownika:"</span>, posts.<span class="hljs-property">length</span>);

    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Wszystkie dane zostały pobrane pomyślnie."</span>);
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-comment">// Obsługa każdego błędu, który wystąpił na dowolnym etapie</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"Wystąpił błąd w funkcji async:"</span>, error.<span class="hljs-property">message</span>);
  } <span class="hljs-keyword">finally</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Operacja pobierania danych zakończona."</span>);
  }
}

<span class="hljs-comment">// Wywołanie funkcji async</span>
<span class="hljs-title function_">pobierzDaneUzytkownikaIPosty</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Kod poza funkcją async nadal się wykonuje..."</span>); <span class="hljs-comment">// Pokazuje asynchroniczność</span>
</code></pre>
<p>Widzisz, jak kod stał się znacznie bardziej liniowy i czytelny? Wygląda to prawie jak tradycyjny kod synchroniczny, mimo że w tle nadal działają Promise i cała magia asynchroniczności.</p>
<h3 id="zwracanie-wartości-i-obsługa-błędów" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#zwracanie-wartości-i-obsługa-błędów">>>></a>Zwracanie wartości i obsługa błędów</h3>
<ul>
<li>
<p><strong>Zwracanie wartości z funkcji <code>async</code></strong>:
Jeśli funkcja <code>async</code> zwraca jakąś wartość, ta wartość jest automatycznie opakowywana w Promise, który zostanie spełniony z tą wartością.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">zwrocLiczbe</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// Możesz też użyć await, np. await Promise.resolve(42);</span>
  <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;
}
<span class="hljs-title function_">zwrocLiczbe</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">val</span>) =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(val)); <span class="hljs-comment">// Wyświetli: 42</span>
</code></pre>
</li>
<li>
<p><strong>Obsługa błędów z <code>try...catch</code></strong>:
Największą zaletą <code>async/await</code> jest to, że pozwala na używanie standardowych bloków <code>try...catch</code> do obsługi błędów w kodzie asynchronicznym. Jeśli Promise, na który czeka <code>await</code>, zostanie odrzucony (rejected), <code>await</code> "rzuci" błąd, który zostanie przechwycony przez blok <code>catch</code>.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">symulujBlad</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> {
      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"Coś poszło nie tak!"</span>)), <span class="hljs-number">1000</span>);
    });
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result); <span class="hljs-comment">// To się nie wykona</span>
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"Złapano błąd:"</span>, error.<span class="hljs-property">message</span>); <span class="hljs-comment">// Wyświetli: Złapano błąd: Coś poszło nie tak!</span>
  }
}
<span class="hljs-title function_">symulujBlad</span>();
</code></pre>
</li>
</ul>
<p><code>async/await</code> to obecnie <strong>najczęściej rekomendowany</strong> sposób pracy z asynchronicznością w JavaScript, ponieważ znacząco poprawia czytelność i łatwość utrzymania kodu, sprawiając, że złożone operacje asynchroniczne stają się bardziej przejrzyste.</p>
<hr>
<h2 id="zadania-do-wykonania-sprawdź-swoją-wiedzę" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#zadania-do-wykonania-sprawdź-swoją-wiedzę">>></a>Zadania do wykonania: Sprawdź swoją wiedzę!</h2>
<p>Czas na praktykę! Rozwiąż te zadania, aby utrwalić to, czego się nauczyłeś/aś. Po każdym zadaniu możesz rozwinąć sekcję <code>Pokaż rozwiązanie</code>, aby sprawdzić swój kod. Powodzenia! 💪</p>
<h3 id="zadanie-1" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#zadanie-1">>>></a>Zadanie 1</h3>
<p>Napisz <strong>funkcję strzałkową</strong>, która przyjmuje dowolną liczbę argumentów numerycznych i zwraca ich sumę. Użyj <strong>rest operatora</strong> do zebrania argumentów.</p>
<details>
<summary>
<span>Pokaż rozwiązanie</span>
</summary>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">sumaWszystkichLiczb</span> = (<span class="hljs-params">...liczby</span>) => {
  <span class="hljs-keyword">return</span> liczby.<span class="hljs-title function_">reduce</span>(
    <span class="hljs-function">(<span class="hljs-params">akumulator, aktualnaLiczba</span>) =></span> akumulator + aktualnaLiczba,
    <span class="hljs-number">0</span>
  );
};

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sumaWszystkichLiczb</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">// Oczekiwany wynik: 6</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sumaWszystkichLiczb</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>)); <span class="hljs-comment">// Oczekiwany wynik: 100</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sumaWszystkichLiczb</span>()); <span class="hljs-comment">// Oczekiwany wynik: 0</span>
</code></pre>
</details>
<hr>
<h3 id="zadanie-2" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#zadanie-2">>>></a>Zadanie 2</h3>
<p>Utwórz obiekt reprezentujący produkt z kluczami: <code>nazwa</code>, <code>cena</code>, <code>dostepny</code>. Następnie użyj <strong>destrukturyzacji obiektu</strong>, aby wyodrębnić te wartości do osobnych zmiennych i wyświetlić je w konsoli. Dodaj również zmienną <code>producent</code> z wartością domyślną "Nieznany", na wypadek gdyby nie było jej w obiekcie.</p>
<details>
<summary>
<span>Pokaż rozwiązanie</span>
</summary>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> produkt = { <span class="hljs-attr">nazwa</span>: <span class="hljs-string">"Książka JS"</span>, <span class="hljs-attr">cena</span>: <span class="hljs-number">49.99</span>, <span class="hljs-attr">dostepny</span>: <span class="hljs-literal">true</span> };

<span class="hljs-keyword">const</span> { nazwa, cena, dostepny, producent = <span class="hljs-string">"Nieznany"</span> } = produkt;

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Nazwa: <span class="hljs-subst">${nazwa}</span>`</span>); <span class="hljs-comment">// Oczekiwany wynik: Nazwa: Książka JS</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Cena: <span class="hljs-subst">${cena}</span> zł`</span>); <span class="hljs-comment">// Oczekiwany wynik: Cena: 49.99 zł</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Dostępny: <span class="hljs-subst">${dostepny}</span>`</span>); <span class="hljs-comment">// Oczekiwany wynik: Dostępny: true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Producent: <span class="hljs-subst">${producent}</span>`</span>); <span class="hljs-comment">// Oczekiwany wynik: Producent: Nieznany</span>
</code></pre>
</details>
<hr>
<h3 id="zadanie-3" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#zadanie-3">>>></a>Zadanie 3</h3>
<p>Stwórz tablicę ulubionych filmów. Następnie użyj <strong>operatora spread</strong> do utworzenia nowej tablicy, która będzie zawierać wszystkie te filmy plus dwa dodatkowe filmy na końcu. Wyświetl nową tablicę w konsoli.</p>
<details>
<summary>
<span>Pokaż rozwiązanie</span>
</summary>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> ulubioneFilmy = [<span class="hljs-string">"Incepcja"</span>, <span class="hljs-string">"Matrix"</span>, <span class="hljs-string">"Interstellar"</span>];

<span class="hljs-keyword">const</span> nowaListaFilmow = [...ulubioneFilmy, <span class="hljs-string">"Pulp Fiction"</span>, <span class="hljs-string">"Forrest Gump"</span>];

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(nowaListaFilmow);
<span class="hljs-comment">// Oczekiwany wynik: ["Incepcja", "Matrix", "Interstellar", "Pulp Fiction", "Forrest Gump"]</span>
</code></pre>
</details>
<hr>
<h3 id="zadanie-4" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#zadanie-4">>>></a>Zadanie 4</h3>
<p>Napisz <strong>funkcję asynchroniczną</strong> o nazwie <code>pobierzWiadomosc</code>, która symuluje pobieranie wiadomości z serwera. Funkcja powinna używać <code>setTimeout</code>, aby po 3 sekundach zwrócić tekst "Wiadomość pobrana!". Użyj <code>async/await</code> do wywołania tej funkcji i wyświetlenia jej wyniku w konsoli. Dodaj również blok <code>try...catch</code> do obsługi potencjalnych błędów.</p>
<details>
<summary>
<span>Pokaż rozwiązanie</span>
</summary>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// Funkcja symulująca pobieranie danych (zwraca Promise)</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">pobierzWiadomoscAPI</span> = (<span class="hljs-params"></span>) => {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> {
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> {
      <span class="hljs-comment">// Możesz zmienić to na reject, aby przetestować obsługę błędów</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() > <span class="hljs-number">0.1</span>) {
        <span class="hljs-comment">// 90% szans na sukces, 10% na błąd</span>
        <span class="hljs-title function_">resolve</span>(<span class="hljs-string">"Wiadomość pobrana pomyślnie!"</span>);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"Błąd podczas pobierania wiadomości!"</span>));
      }
    }, <span class="hljs-number">3000</span>); <span class="hljs-comment">// Symulujemy 3 sekundy oczekiwania</span>
  });
};

<span class="hljs-comment">// Funkcja asynchroniczna używająca async/await</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">pobierzWiadomosc</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Rozpoczynam pobieranie wiadomości..."</span>);
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> wiadomosc = <span class="hljs-keyword">await</span> <span class="hljs-title function_">pobierzWiadomoscAPI</span>(); <span class="hljs-comment">// Czekaj, aż Promise się spełni</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Sukces:"</span>, wiadomosc);
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"Wystąpił błąd:"</span>, error.<span class="hljs-property">message</span>); <span class="hljs-comment">// Złap i wyświetl błąd</span>
  } <span class="hljs-keyword">finally</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Zakończono próbę pobierania wiadomości."</span>);
  }
}

<span class="hljs-comment">// Wywołaj funkcję asynchroniczną</span>
<span class="hljs-title function_">pobierzWiadomosc</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(
  <span class="hljs-string">"Ten tekst wyświetli się natychmiast po uruchomieniu programu, zanim wiadomość zostanie pobrana."</span>
);
</code></pre>
</details>
<hr>
<p>Gratulacje! 🎉 Dotarłeś/aś do końca kursu wprowadzającego w nowoczesny JavaScript. Masz teraz solidne podstawy do dalszego rozwoju. Pamiętaj, że kluczem jest praktyka - im więcej będziesz kodować, tym lepiej zrozumiesz te koncepcje.</p>
<p>Co chciałbyś/chciałabyś zgłębić dalej? Może:</p>
<ul>
<li><strong>Moduły ES6</strong> (import/export)?</li>
<li><strong>Klasy</strong> w JavaScript (obiektowość)?</li>
<li><strong>Metody tablicowe</strong> (map, filter, reduce)?</li>
<li>Głębsze nurkowanie w <strong>asynchroniczność</strong> i Web API?</li>
</ul>
<p>Daj znać! 😊</p></article><div class="container prose"><h2>Quiz: Podstawy nowoczesnego JavaScript</h2><div><p class="font-bold mb-0!">Pytanie <!-- -->1<!-- --> z <!-- -->5</p><div class="prose-p:mt-2"><p>Jaką główną różnicę między <code>let</code> a <code>var</code> podkreśla się w nowoczesnym JavaScript?</p></div><div class="grid grid-flow-row gap-3"><button data-slot="button" class="button button--variant-outline button--size-sm w-full text-left inline-flex justify-start transition-none text-wrap! min-h-min! py-1.5 cursor-pointer">`var` nie istnieje w nowoczesnym JS</button><button data-slot="button" class="button button--variant-outline button--size-sm w-full text-left inline-flex justify-start transition-none text-wrap! min-h-min! py-1.5 cursor-pointer">Zakres blokowy (`block scope`) w `let`</button><button data-slot="button" class="button button--variant-outline button--size-sm w-full text-left inline-flex justify-start transition-none text-wrap! min-h-min! py-1.5 cursor-pointer">Obie są identyczne</button><button data-slot="button" class="button button--variant-outline button--size-sm w-full text-left inline-flex justify-start transition-none text-wrap! min-h-min! py-1.5 cursor-pointer">`let` nie pozwala na przyjmowanie wartości domyślnej</button></div></div></div><div class="container"><p class="button button--variant-secondary button--size-lg w-full p-10 text-wrap flex-wrap h-auto text-center gap-y-4 text-wrap!" data-slot="button">Widzisz jakiś błąd, bądź literówkę? Chcesz coś poprawić?<a href="https://github.com/jakubszpil/jakubszpil.github.io/edit/main/app/content/courses/nowoczesny-javascript.md" target="_blank" rel="noreferrer" data-slot="button" class="button button--variant-link button--size-default">✏️ Przejdź do edycji tego pliku</a></p></div></main><footer class="prose max-w-full border-t"><div class="container flex items-center gap-3 justify-start flex-wrap-reverse lg:justify-between"><p class="xl:text-sm">© <!-- -->2025<a data-slot="button" class="button button--variant-link button--size-sm" href="/" data-discover="true">jakubszpil</a></p><nav class="flex items-center flex-wrap -ml-3"><a data-slot="button" class="button button--variant-link button--size-sm" href="/" data-discover="true">🏠 Strona główna</a><a data-slot="button" class="button button--variant-link button--size-sm" href="/blog" data-discover="true">📝 Blog</a><a data-slot="button" class="button button--variant-link button--size-sm" href="/learning" data-discover="true">🏫 Learning</a><a data-slot="button" class="button button--variant-link button--size-sm" href="/portfolio" data-discover="true">🛠️ Portfolio</a><a data-slot="button" class="button button--variant-link button--size-sm" href="/me" data-discover="true">🙋‍♂️ O mnie</a><a data-slot="button" class="button button--variant-link button--size-sm" href="/search" data-discover="true">🔍 Szukaj</a><a data-slot="button" class="button button--variant-link button--size-sm" href="/handbook" data-discover="true">📋 Handbook</a></nav></div></footer><script>((storageKey2, restoreKey) => {
    if (!window.history.state || !window.history.state.key) {
      let key = Math.random().toString(32).slice(2);
      window.history.replaceState({ key }, "");
    }
    try {
      let positions = JSON.parse(sessionStorage.getItem(storageKey2) || "{}");
      let storedY = positions[restoreKey || window.history.state.key];
      if (typeof storedY === "number") {
        window.scrollTo(0, storedY);
      }
    } catch (error) {
      console.error(error);
      sessionStorage.removeItem(storageKey2);
    }
  })("react-router-scroll-positions", "/learning/nowoczesny-javascript/.default")</script><script>window.__reactRouterContext = {"basename":"/","future":{"v8_middleware":false,"unstable_optimizeDeps":true,"unstable_splitRouteModules":true,"unstable_subResourceIntegrity":false,"unstable_viteEnvironmentApi":true},"routeDiscovery":{"mode":"initial"},"ssr":false,"isSpaMode":false};window.__reactRouterContext.stream = new ReadableStream({start(controller){window.__reactRouterContext.streamController = controller;}}).pipeThrough(new TextEncoderStream());</script><script type="module" async="">import "/assets/manifest-af720f14.js";
import * as route0 from "/assets/root-yHJ3vYDP.js";
import * as route1 from "/assets/layout-DYpV2se7.js";
import * as route2 from "/assets/course-details-DLJ6fZBl.js";
  
  window.__reactRouterRouteModules = {"root":route0,"routes/layout":route1,"course-details":route2};

import("/assets/entry.client-D07Jc1yP.js");</script><!--$?--><template id="B:0"></template><!--/$--><script id="_R_">requestAnimationFrame(function(){$RT=performance.now()});</script><div hidden id="S:0"><script>window.__reactRouterContext.streamController.enqueue("[{\"_1\":2,\"_7\":-5,\"_8\":-5},\"loaderData\",{\"_3\":4},\"course-details\",{\"_5\":6},\"v\",\"㞂⁆⁜⁊੠㬸ᧀ蘎䀈໩腈ಠദ̘נ➀㘂婠胶\\uda31䨊循ƺꁩ栀瀂衒偁큈톘ŘꙒ뀦―Ö든ִ찠挀倞準ꨒ㭄ٸ᧍牥쎛✧ᒀ଄経ཆ搛์\\u0013䙌儖ş⃔棊Ы娊฀챺娄儸䭇䩬泿ბ匄岂ꊤ兦䨀耺䰀甲婀偀㌀坌パ呑ₜ깞縡ㅌ牴고렖樾魀⅀ቬጛ⣲吕滒٦㡌3㺄ᵒ㕜ፔ氻⎓\\uda0f₸石茿缭鲀撡딺ꉊᆇ䟐ጡ芌̓闢ࡢᶰꡀྠ㟅䏧㧁ꢆ䐄㓢썣ₐ晘鲚梣፬찀ᑀ考恹ㆰ뢖蒄Ԓ老둀⩹㈖鸤鍃憼鶩鴟둃♟ଊ␑탊䤅\\udaa8偃Ӕ₃むº鉋搈刭曢ᭈฃ 　᤽\\u0016-㞵逘̳稀⫞ᨻỴ떣\\ude80ᚯ╅Ԁ䆠E㺭ᲉӀ\\u0015ᡑ་펉쵢柳灊品䋭樌考찠Ǳ존\\udd4cᦃ撈䀎юⱦ卉耲턴פֿݴ詛荶ঢເẙ甕幠剋闷瞀⋜帨躀䜄ͪL䉳鰉㪾쑧匛䨀㼖챢ਠ\\u0000批Čぉ悔쮁噤蜄成벲檃帨☆͐谎蓒怀Ԑᦆ뀺ࡌ묈瀐ဂ匾䁺㲘ఓ 괋렔촂쇪䢴尊ↁ\\udf23칃ꈏ멌戤鐊赣ꉂ稠∴랩ཀ쐠뷤莦溁蔀鈂̡揇ઠ儊䁱ꅘᄓ蝠鐉ॸ储ᘆ慄鰈ᩩ脆֚蓞堕썲遒䜃저비᭩\\ud8f60걂➎쩣쐐戾✃蕄㾦:ࠗ捻皇껦䁌젲\\u0002‿赀Ӂ槴ꠙ蜀ڎ뎞⥕蕲ణꀥ玑啕㕎‘⥈쀈儗岸怛ꛣ힠\\uddbe࢘㥙耊ᶢ퍒邥惝囕저悁᠄兵㩖瘤㛛훭ﭥ塴趧秙璀\\udda7ꍶ㵷昀筀틷෇篑琈嵨毵ⵖ耍쮖͏䠴㔝ꍸ킓䵟泑࠲퀫\\ud898आŚ퀢⍹仟햕ꃺ㉹\\ud898秀ퟴ최\\u0003谆ࣀዸ팣瓁혌ڢⴊ‒霵쩂䮼映랇፠┝䶞䞯ﺀ枩芆벎鱮鮘➫쭜뮅쾑쁑㦵ꛩ社耀蠈紙轃腊ꎨ輬蔝ᩋ䂑账ٯ킡顑ᒀכ皱昊挱茹ᥢ㑫体禙媸뒥캻뭶鑦基䠀綢Ȁ芀윕ౚ颳눇\\u0000⼣Ȱ≭Ȫ悾￉엄ꠦᦒ火᠃聬ꠒ魀낋엀踟䯈䘉୹쩰䖛称ᮾ뱌黽찋⣩加ᬷ䵪䣚搇ꒀٴ@顰ⅴ⌤턈ᬏꁢ七ᇓ뽵砡컀ⴜⰡ栄䎰쏀銏朋膆⓲૵侢콆ڼ㞼璊짆⥐⌎㤧⏦鰁囡༏࢑酈ꖞ懙ᴁ끾ⲴਪẂ帜เ찵ޜ蘀ᮞ滊⇼⟇⺫骻瘃潜\\u0018뗁ꄩຄᰍ裂롇৔ᴁဗᆟẊ䡅ᗂ呕䍑ᨨ䭹㧬ⱂㄒ㤂颐๢桹앑బ玏냬㳲㣏褊䠀ܬწ礋ᠽ\\ud9da뽗洀㱝싱嘧읠玄Ⓖ⦗㋁㬃콚콙鱉賀ƚ⎐紀ረç곤ၢ㐶಑ࡢ犊붕ࠎ礨ꔀ㠠ଈ䨼㞚퀔ꋝ튌詆\\udfd0ꮞ兠쳪鬲樭䶪詎ꗴ䖰㞦棄榍থ㒺뎓䢤ၘ͚抲얺ベ壋ꠅ祠苲苓輻㇪䲵鱵▴뜸ᜡ堠╦⏔᪶姏凤ٞꥠల˪苚謀㮔೾毖㪧㉫据썹䐌⚹띒ᒣ喓੎駔虝䀂눋硩腂鈴㧐뱛㲙曲깧차磆㰩䖅餭䙘늖벹滳楿葀㼵院찧貱餜폦朁֋⾹䜪朝嶍鰡ᝑ噠뭛湝斕琂\\b䇹ᨐ|ᄑ쀃녜樇涨Ģ裝邱국ജζ䠈헢꟢_ꡠ䧮⥅\\udc14莲ဉ쀸岗샴퐊䁒য湰҂ꀙ泣ဘᎲრ卅팰ḫ੖鰨联̠惠펊幁灚筂隇᧲\\ude57蟡舶튨볌썶勞샫ᔧ逳ु껚ⴷ怀蒘ဂ\\u0000뷼ݸ\\u0000ሑ耂저ᤸ謐簞藶쨎蛳笯뤰㑐 ፴ܕ΁⠀軨億腇࿀㫦㮃\\udd45ᒃࣺࢉ舰ꔿ㢼㬂䀱੎ꡌ㐇ꈒ๙⚜蘿ꌔࡆ偒ઓ䠙ଢꀰ䗑稀수⌌恔ঌꄟ碠鈵韁䐍脤帀䮲頊꣞␆耰ᕓ桮\\udca6栽΁瘼ꉈ됀掖䍊梢Ã淕Ꮄ뉖䰺쓲폂䲚⢮耈⓻鐏ꇒ確诐ᰠ䡔㥇\\udc1b줷\\uddc2Ყ얰⠌專䃯蛂\\udd4f腣䚅谐唔鐰\\ud897ና㠎䇠徂猿ጷ퀰Ч쩇୵ഠ慥閻⣎鄂醕詘㔼삞﨑⎜梤殺◧↏ᔐ꡴䤹ﳕǈ喑筆＀෡鱽ฐ躑㩢欀鰃㚠溚☻坮悯鲒灢㋨꓏孨ᄯ\\udc03و᪇보׵\\ude47蕓䐴❸鐓炤劑ᬨށ쉗ꑒ\\ude20芉꼶់❺႐媒妐젏ᴁ⛳ݡ朩㒠랆焸⇉리ტ憎틃送聱䈸䝄\\udd33鎴語䆧๘䏍ก둨갏〵쏫氐溜聘㷃㫐卂豆ࢼ❠§◼ㅯ⯸⍮쑞轔웲⼪ꃲ䀳꟦퐀〘儀᡽⠩䣲ꪨ᠁Ϗ一憶䔎脠䰏㜂⢐ᱜࡉ竳堽堌\\udc13ᙠ꽝势똡៛쬓ꯌ㿰㞂\\f䝎鹣㹒嵛눕ල\\ud8bfꟃ裶渪煎㬿㗷琐ꢤ獶헴䁈3글쮍맭\\f陏쩐Ã擎`֌\\u0002鍅㱙黵瑓곩ᯠ⟵穨몲斜ᇮȖ拦맸钏蝹㞇袞倧Տ꘼怶悋ꦵ㟌ꪁ鷠穆臣댇譽澨版ೞ㬾ǉꭕ㑲耳勞汵䟰৹쨴偻慐㩾볙컺吀枏ᐒ舔樍袺鉎莩㵆₧嚳ɠ㦊岞김㪟ꈊ润͞ᎃ\\udf83쌿꯻或雠侞兏賺螕僛臁ᄹ槐빁頵﫟똀䬡茈ℚ딝ρ鉫ᴀ振ꙹ꾈쌶踠ᰀ⩘౨鞡䏨ꅀ᠗倐㸅愤䄐䖡∾Ꮕ膁偈쎜᫩䬿㈃儩䯏㱃䄏肤㏀욼쇄㫰砡芠磺퀀碘瓻䮬﫠满킟䁯⮀ᰐ桋ࢪ搣ḋ芐庪蘹Іᶓ⤶秺㌅稏Ҳ「竸┠枕譪ὃ령ŵ⧰\\ud85d虐΅༆৐߂꼇薠띻䊄旪㐉ư㵡砬䖀㱄ꀹĘ稄顤輦瘆宮ߧ࿱䐫藹㜹．牍㩸ؾ₟霑〓Ѐ✞ꨄ猄;ᾆ玭茈ὀ䰝쏇릐ℭȈ矲᜽πƈㄶ瀀髑窗ᑚ袊蜠郅搑㭴긃礐䀬勇炴䎠␡箋믔榅ޅ蓠䠁宮쏆聢ꀼસ帋–֯鞰很栄㕂搂셧蹺枸윩㩹㰳ǘ่؋諧㺁롧Րྃ艧ꀢ湻≺약ᱩ骂餖\\u0002䠼⠧茆눂믴闄꼩䦢毂\\udda5擓숩ᣭ뤂\\ud9a2曠恇慠矄둯읂䯂ꀔ뎧띫鈅廒儦䉨튖ὂɋ⚆鬥谷ፄ䀪簹˪欦쉒습ࠡ豞ꡳ麤쉻◹靐⦃ꑭ먡䬷碪碐㉤⛀皧ꐚ尦㢷硦굋䉰敚䤁ꤵ֥㩷쎊撧䩈竊喸ᰪ엘`쐟虐⺋龢לּ㘁䐓ת芚⾎㩌䫹蕃꓆豨잗귛␴䋄⬊猪៲堉昀ហࡀ㠻㐹躲搴痋ﮒ㎛꾹厮䅄௓融缐잞劉뇹夲穷ꭓꞗ苷뽺딙꒞㌸஫㨈㬺玷㫳鋋⤋袹〘뫫늻䮬믋ꊺ빅슫뇐殜⍫꟧瀒ᆹ〒ƛꖆﱒ둺잫薷謤Ꞗၯ뽇禙襸鹗턻醄垵ൺ袺뷒袳穪蕲랯鎷蘓Ⅿ誔騕髨僺騈ﭻꞢﮏ扴㥢숩塔㩊숈ꃤლຼ쉗닧䐙ඁ퀭ᶐ㼕ꚥ遲뀀⶛ꈬ֬ԁ鰽抱槠光猞됺萄釬㥊\\ud9b9鞀舻࢑㴁吟䎪㍀吸રꮃ⤊䆀ۃ츒↍騹隠\\udbf6褚쨅钤ᑁ楧ⅸ陉୉岣龸韡殔ힾ굻ᅑ霻멖皃썵處酺裚躵墸㧀㦲镸ㅥ밀㞛Ȁࢠހ뀃삪ૃ넩䄦錂\\ude37䡙鑘㪆㳦⹵᜝❻湖ነຂ⾙ኛ蠀뎛㫚闤ꇳ謸㹑넾怕䮌맋肀钻繩ƫ鿥殁⌝䒹š뭳頖ⵌꖇ蓕ⅶᄴ㯖쵼헿⎸뢡ᖒ텇훑釆袑ው椑＃穑㞺蘗ᗅ걀鞐ඃ꜄⨀亞ᕗ꩚㓉沒啖萢᪔袑梋嗍୻礰䠕杨ⅰ㛙│镧樣걁䜕啐២怃ჳ懃琐ᩕ䒗褤።㧀䈵ǭ긁艨᫰ᖤ꽨ᲈ趐అ鮳翓㾂껚〩䗅㩀꠰魁鏢츼蓁ஓ䋎⨠Ȼ浸䊉윒荹ൂ㒖ⱦః℘ࢠ鄖ၩ뾏쀹⮃ꈨ쁰Ꝗꢢꆴḃ캽́䇢袀x랋䉔䐊䎤饃琕袳䢚袭\\\\औ愍뜄ీ砦茈㢓䭬됇䥵됁ၘꎨॹ䗫ऊ䄝衁砚ꍔ䘒᪛䁆ⱂ㩐䌞鏢畣낹꽑布뚢ᑀ疷섘㐖륿똔◨뭇தó鰮Ϥڑ逴㢯⃗鎬娳睠Ἦ菏ᑂ䀮땟幑貱炳頳픺γ᳋딳ꄨ⠨઱쮬꘳슗厗绉᱐ప鑸⡥荐ᝑ㥴꠲脳芮剠㨨罉쪀훋⬽碠ꝅ㋼鬫謄㉽㝠ኁഒ褎઺㌮Ƃꂗ剮⛢怑ో琑䭍ˋ䫂踱瘔㵡歮䁗䄏ꃦඞ碱슮ྲྀ㤕ꊧmⴏøモ蔌ꈒ뢏銽ఢግ紋๠✃踙䏨آ쉰쌠쭻曰텶␞蘈ຨ賔⚎郣㊚㌲誷霰》Ď쪔⦸죐犧ࢀ䟊ꪹ膫㩵欫跐죐ヮ轶㺏됛\\udb36뒲퀣ꯡ⵶蠽甠⤲쐂\\udbc9朂뛃玌銍㇊階Ⓨ贒㌎냤ꠒୀ꬞ዄ턪꓀ɫ됃့ʚ怞꠷ 舁묄ׁᐢξ錠Q햰\\ud98e鰲苛㶱䐠늒赌蓱턤썍䷯钪듹臡━쓷仴ｎೈ춌䳔캆鰂쳩菌뮓̬\\udbaa곺콜ꢉ鮰㸗脘ｻጁ闓䇢挳系ԛ㐭ڴ즮ᢡＥႛ惂ୈ뜥䑸菉㞟ṷ㸼祿癶俧夃\\udf07଒⚌노ǂ炍ࠎ⤭హ⸎ᘑ֛ﯨد束枎ԛࢳ榬㦔댢⍠⬛偽拁⁕블⊖࡛ꭴ鮐⻡Ԍ䋉ぃ射煘⋢袰ﭥ溷筴䴻톆㙤㖥츂ꫥ셼祡狔幪핳뫖浙梹쀝䟤빾뮝旖殀ᗺ풻ş舽䦸䅏앛둈嫧㥚픀\\udaf7㧚䌶៽壸쀹꾾賠⛮걓縎袩ᔞ㤕卽΂솮渿菃刲Ⱨ읟吮敡浪鐭㽴嫖籍Ĵ弨럡睂哞◨璵쓎⌃Ɔቐ᝙䋒㩂Ｐ℄㊐⎇옴睠꺤⸢䵡꽮顸\\ud84e혠ꐚ艞鞂爐鉦湵莳ᆀ뭣℈\\ude10‰膴፯⠑౭ḩኺ웑꣼シ鑰省ﻠ쬵艞츭з䭞홨⤸凣ﻴ獺㠟敳⢞풤顀ʫ膃櫾뤩俨ྃ拘戞齘͗型\\ud984闘㝊绷ࡤ䜳Ĺ퀾᱊䓥渝洣ゟ훫∭㞱噖뽇憉瘏澟ࣴ\\udf79怿ხ쁍塰鴟璁菕ꁘ컒공苶馏ꟽꨂΒ퐮\\ud8a4᭛璼鋯ࠓ臶瘡䖊撘廭駨\\udd15\\ud931컭❜\\ud90a硤푛枓䕲雑硛悬哠連鼁ꍘ姚ʹ렋戀㈘⽛꒥Ⅾㅟ◆㩝ԝⷼ᎞㖍ᮑ\\udb23હ슥ꇿ售삎쐻螅齃嗳蕠ꜝ됌䎙Ꮼ켊㬠ὁ㻈⧌ﻍ㟒锵頼鎠㈩꠶ⱛ뷍ھᅲຂꀷ鱇㔓肟屯を쌌ǜ萕茓ቨ撰䅕ǁ஦⊠㌹憝杻鸇褜敉ɑ៯玛ꉍ꬟弻ᾏ兎ܪ醽鯺铥ƀஃ㸷Ꞿ㄁逿腣쩁仅䑥镄⑼庮┵ḯ\\udefbꛣ⧁Ṋ你\\udf45滼숯䦛漍办盎䁜신槂틭\\udc08鸊苫权Ⲥㄯ琐鷹ܥꕣ飋ꐓ၈빞ጂ鏢᦭Á拢쀜㘯ᯗԏᐾ庶畕❔ᯪ㞤㌻褗茭뫲ꖕ釴د쇹썱馓钾廄㟁솞愅ນ潃蓋먣㕝㳮쫪仸鏩启૶ኘᐓ鋯ꂣ↾웴䵏ⶐⱁ꡻圇쁉엂⬵閙遵ꉽ㏙蕂턜樃梀轖뙛㴥청\\ud93c간鰁蹇㳵脜㏯㽜꒦係㓟巷첍징㛔럞ᠠ\\ude60띁뛣澶ᔻ퇑罣偳ը甋ꈀ⓬⣠숪죭죕쩀洖퍀ￋ郚潶㗐ჽ펿혪翋꠿䗿뱌鑭訏ꅿ옘а䘮冟౑耬⛈듹˅透僟찁耊﨟ꇕ䨀領ꂍ㓀᮰ᢌ類馮膈愢搶㓘咰᧜碘␽♉⒁驪袢ᨪ씒ᮨ↾梣᠛અ颧꾌熀猀髝ḁ堵ঔ납䗊ᩑ䓕堄㏂㏼샿鈐㑀쐋䦓槴ও䋀ਏ䢖선ᾩ〇䍼썦섵뾚殳ᒚ냙︔쀔Ḩ䠊전扠᳦細ᦐ쵆愺ࣂ倜衏㒚Ⅱ崧࠾鳴뇧宦Ąዓ㸇ￜ墚ภ筴⧫᝜멵鹠紇∆삄脎★摚烠⋓蜉뛠왥襅雨륂끂ɠ攣߹짍ᑡ蔰ⅎꂬ傌ઠ꼠냒ꦀ頙行쁝䊪ʘ呁懿\\udfa1Ｄﶛ䎠庇︪㋿Ꞡ埏뉐ꍓᦡ䅢遱ﱆ蒪⊀ꪋ࿙ʍሞ豬ݽᑢᨷ桒䏪摀붘逬脔ઠ䴃〃赤耩幸识帷䦾㼓䗓໑⥝端舟려⩡墣衫ㆼ渪㼛萂䅿䇘浌鹋⃎劆鮔訋嘖썐ڠ뎅퓎쇷ࡰ塱琟쐺ȖȔ됄꼡恆ᘰ褀슅蓴⣅㶬蝈㭦眊큃썱᫐푀༙8䖤䠀쉃思̳荡鸍憻䁺淠ꮙ膕댙㓤Ћ㥪瀮䪨쒵樷衿캒䁈\\\\苈럟⏸Ȍ縐獀徢瀗뼫蒐⾈矱ⵌ僧஬漥嬋蝪ᄒꭵ厨ꮂ鈍跔紖᭐⩆쥪榓鼠棔ࢾ濰ꅋ糌ǟ㲂⨂᪰뼥菰孅候ː䏺醅㿂٫ዿ鿼犂ª戰؁䏲ꖂ퇙軯㖢㡏䀻䝲쟠᱐䚙挪ག㵅䭎⢯ې㳱惯ٴ舡航ྂꠙ醚܋ᲀ틁냊昝薑烊㢰꣱鎲쾀錛䀈8℡㝉᫣蔐ޙ惥ⵔⅎ퓀φ㦂乄曐퐗恢뗐꺉砠愣˗飄전꺣聜ীਂ栌쨠莠┘뷮䀢飠寕\\ud805耲Ǡ缪⧚뙣努Ⴂᾬ途앰鸼몈\\udf0a腏ⴊ杅굍퇦ჴ揥봒᭯宾䣪㺈ධ揿⨘ᮄ਑뜂鑣₣減뎪ᬲ㒷豿扰韵東辀耜䵬ꋣ낖瀕ǃ䄚愣䐜丄풳글炢䡌區爍鴆쐏ѱ⨦በᡘ侒爁㤚⁀따ހ랣䬣姥ᆞ쳶鎴预▏咢ꖃ㓸䇰᥄鰉\\ud8a3⟋혱瘓삂缋袻깑⋠멢孩⇺鰡⚠畁똮梞송ⴭ瓢⍠ஂ淪촵쑣⃗⮲骔烠້뒥怹䎜ේꅁ漽4Ꟗ洩䩝ረ充㦿䉤묊쀘꥿ꂲ⯹Ⲁ酜訤伢䤑ᡋƹᨾ詤⎬ᘀ慎鲖뇻↸稰逛壏醍탠Іᠥ耰᜴頚ʊ쀠ꋺڰ셎樱᢭␆鬠䔫勍ྲᒀ\\u001a茈퓂ꦇ⎺魠ﲖ◢娴ē쒷àᦠꦕ䎪澴ﾐ⴬䄠◒턒饢⯨魈鉁఩蔃⡇謐ꛙ⤰캞呥ꈽ㧩潍䑪洼欈돸딂哢แꒂⱴ䘣⅁쫆覲菩隴챇㌻뀨쯚浂阑ü偌ㅡ\\u000e塴チ侈챧棄槚ཉ麂⤙耵螲㰙糊씲䈞ᷴ뢤櫓邦蟨⨉葇葸㩻킩\\udd06⩳땊涄✂冇奧䈤ὁ䆗敬쌘흈䑼텡鐴虤⌹ŝ䈞뵨錦貍ꁣ∙墦왱펻ൈﴃ棴찘坐肄踻삵顙鮘\u003cה\\u0000錀ȹ瀆ꩁೇ䐄䉒㬦섰踐侍ꦟ朢㶙賎㊔᭴⃤ꬢ钵콚侳턬み昷☹唆₰쉀Äঃ谠蚔䂖灳渝ⲇ蓨⌦乿呈࠼걪堹妜裺綂뺛ᣯ⥹蕨뫊␄藾鿒弱䮕ƅɶ鶀夯沥ꌗ㹩癲툽里袘ꀽሣ鑝㸠낂炢㐹ꂡṺ톣釬\\ud8e5紊ꡯ춵⌀음㳛ꍫϙꗍ艗饐휫\\ud96d쾮漳垘ﲤ杶៙꿏繣Õ証騘笭夤躞岲뉤먼ᚏ찙╖픿춧ᄸ돊ᙺ꘨㶈੆ࣜ誗䣰훍䄷갔혫蓥證⏜⛋鉼銆信쯵⇸啍群햓胡ꝋ㹵劋뙠臈걸鵐㮁삥츂ᩛ㊎瑑眨ꌁ⨭儚㥷䩈腴䒳迼峢ꀄ廇ጮḜ䠄赥ᔘ܅⢄\\udc7eŤ훹쿅蕬⾃鴁鞈鑮䠺䣗岲即蠢麲怜㝽멌ꓟꞤ鋴蠤텸쿝唤君ᑥ궔즧咭⬣冩꣕Ѳﲐ඀皧續榬䀍ꢞ⑖㽑៥籾薹엸밥늀覮裚귤뚩報⟖呈才Ꮥ수蘡䯕瀩튱⓴ꭒ稠끜俄틆옴䔃訽Ὂ뼯원몶࣐麀瀌伔蒲풌\\uda45杳㼕Ḇꠤ䂐ਠ྅ﱧ鐄굟㝺쐛兽軩䈸㨁앍ⳉ鯈࠶쁲齇俄뢅밇$⠉؈룍锈䲵\\udbb6瓬苀඀ಘι怫栅数ခ㓉㤁閰ॶ㲓㤀즌뗀౩浄ᙙ꩕鼈ᅉ적⬘ъ\\ud923䄣ⲵℾ蘣㱉霮㫠ᚼ᷅င憩ᜀ䘁桔홿㏡素꡹莙̬쵒Ꮇ㱻௘궗鰊Ƽ籄܀桑墠贪袵널뗘娙⑖䢞予덨਑朂繻ᬛ囅\\udcc9ଥ䧤铪蔕◝绵\u2029素﹘졔楩악晃쾒Eᄡ됀郺⟌꒽⹜誼㨄릅袰徇ክ塠⁲唴䑗⻊돬⚗㢘㘕︄䥆喚委闂爬맧ꋉ몉Ⳃ䙽㖆蕰儼酢ᗅ톄ý٢㌹칐扒퓐ꏙ僎ⷯ駚젳馊싪㲫︀–冊\\udd05﹒죿鰀த삣옢ꂦ䢂祌板㓀쪤ꀗ倻贈䍃싍ᒧౝ砃煅᭐죵澪ꢭƨਠ乣䆤鵀Ћ쁪î뒙뎯鵚㊛骼뷔ㅱ蘍䋽ᡆᥕඤ耈萖ꥏ蔻렢؎몢腮ꔄ䐆閭ැ\\udc42အ熑碼륪ᤑ먲バ耕蜔䖨୺千뺚袓盎뢹\\udd40핣\\ud820鷂₼뀧殸仡톾跴춁尢ꦘ荌핞귵﬈初胺魣㺯䡺儊\\udf59蚞힇쁼⇴ऊ䆮鈡떄Ꚅ鴁ꡐ㜧㷆䈅㵋樴\\udd0c쑅圩栨詶昊릖ꨶ朞럍䈋腅嶦ꌗ䶇໬↚齞ꨱᮅᯍ潅ᙗ탔洘䲴 ꘘ橣䏂ᩚ䪅噮ꌸ⠢攧䱥Ῡ缘눱Ҽḉ⽧驉愥䮨䒨ꨪ丷폮㗣㹜圄譥㯶纃欏푇例ꡭꠚ䝪鋕璳酽ญ絸字嗴䨶溩郠㐚鶔蚳ꘞꗆꩩ㵬寔\\udf02꧗场ᕋ穚\\udc89ﳺ摜⯵倩﵆\\udb86鷚⢔ᕩ₊龫쩆ꪼ㒸肍딢㭉憋⤐㰣㪕癅╚㝟໓뚜\\ud94d﵀᪀킀ံ蠌෰撃秚氜謮ꄲ鿹ﬦ뭽ᩲ\\udbf9㮵磒馏櫓珚瓓窃蟩괭㍠녌\\udd4c究\\udda6ⷌ䈢ꕄ芇╵鄳䅔嫟吂Ā肼彃ﻘ븜Ꭷ⯨姎᝹㎖\\udf16饓붲聹춺ⅲ䞘⻢剌⍝ᜈ⭏\\uda50틴퐶寧䁩䋪㗖ጣ鉼踝❩砙\\udb94ᘼ䬰ᵺꙣꏀᇜာ襐ଜꫫ爷散\\ud940䋁ᠥ嶏ꮏ熃爊\u2028艔㏍됮ᭊ烘쬤윪ᚪ洧⣟ࡀ\\ud88b롞꯸阠優䄛⪓䵀乔᷎ᔳ蟢⥡륒勜ģꙜࠌ䭛\\ud8d0㜢ꎢ䈯Ⲡ⪴챞刄䏼Ⰰ⠐ﬃ勞綸\\ud9de啄㋽布웆鞸곺ꔷ貲⢌쥖ほ࿕촵ᕫ㹬⮊媵突鍠넭\\ud972臒Ԑ䒃츄⢈䭔瓤㔛乡ࠞ螉쐒䐅֤ⵁ堙큉䋽ᒯ蚄㠭ꄋ䷱ﰒᥦ⡆嵹㆗먾ⷚ듋⢟죾䅥瑊奃Ꮓ᳄䘵ꉟ꽳쐮䅾ࣈ傠䀜傃Ѓ؁銰徒̼៩憀䬒ࢊ胴綍ｗ窤ⵁ뤉샞苧ᑠﬄ됥铝ࣀ烂喴墸ぁ丂ఫ摊뻀䷍뢶䏞阠ᔔ퀖′䩨桳ᾷ┻쑔㼹ਪ勴胨ό쨞쀱詐蝝֋҆熓上㧀钫옐ㇰ敊 ⁱ㓩ḁ䰘Ⓦ⾀㠞槉ᙉ㸀ᰠ쑩弉稻똰뇶躸魀Ǯ蠔䈟菅쌂爻샴ⅲ鯩㞲塜궜ࢼ脤こ\\\\໬岄⠖䅞ⵄ嫰̌딯眾极᠏ᓝ鎼뉮鞆쀓肫児ந⸒ꔈ乩孋㔒8ㄔீ輐뼼礳锂\\ud91aᠺȇ嵮㊒╺㧲❕粌쬰㿫氍嵘㚻Ὰ錓噔䆶╌恀㌘㽫萖㾐䇣Ɀꪇ⥷ऻ꘿찃ǣ䄂壟墺᫚太纄瘉戭\\ude33燏軭퍺㤇ꀝ鄬ఆ暩횳뒹䅏뙝橉彞릠ὠ養螟婗渝⯐≬썋褣͔밋砛쉱㶲발樉ƻ粎ꄬ죓햯ᙲ丧鳑ጣ즬蹢ሟ䃀㷥未₟쒨斜㵆爃萣㩷촄\\ud9a8孓殺鲶读ｌ䃗泫ῤ둜艗领耯⃐쎀刀Ա摄傐⯺㐊\\udf5e꧆蛜蹡㪛絅쏃ќ쉴꼽泀㛓䴄ꆬ遷傰؄퀕䡳懡앁硢莳䨏曚쁨ᚷ曜鼠\\udf97瓭奟冮앵唏癆ܖ떵蝟눧ꓧ㌀佉耭࿜螃礈삦鳔폒活駝俦罓ㅢ媡ᡚਖ਼艣驣嵪楧䕲苙⺽띋꧹\\ud88e偌朘ܙ렂޵禮鬡礢⡒馵㩰䚜점䕠捣程甆ۏ嗲鴺囉ⱑ둡䀻ꮡ䴈၎ᰬݣ૬횢牮앀ṯ峽㌭㌌‛鼸ɦ쌼瑅甁ታ榚簌犵\\uda34곤\\uddd1馜⋧Ｖ鳀⼀๡⁜퓽柍\\udbf6錵덢䒻ɬ若퓶湝跏㋩늶邶姣鰬࿧郎駙컭셳䘇ఊが檅Ⅹ\\ud9ae魄儧ↇ할勧蓦⁉㨥㄂㴳ꥷ䈋詷펉ᷳꯍ띂您梅﯍襣匄었ᘐ씋榛痥믨躚勋댣㾲⸋﯒뼰iゃ這䂖䛈彁헑留癁猹쀂鋊䀀Նꖰ芐ᘋ꩙ᒋ䀐뙩ꝷﲅ௥켗刢䋙薌䝡浰곌湑陌뎠Ȯ錴猤忐昀겳⺡ị첋㘀圆햪㳷藅不둅荱堥ⵓఞ㾥ሑ욊岉話奻ꍬ룜쳁ჼ줮㮆ⅷॺ㼦퀂琼唠氱筴蓨擉棬堧삊鳈瀶⚀ꌆ⎏騵뼠⁯∴͖镑␫언\\uda02❐㡑셲呄\\udc9a삪Ιغ䊔ᰢࢂƁꢨₐ닩흁萯げ檓䄁ꓠ靗㇔륏ᔁ印⩔ﭫ㜸ຸ칺罳怄ⰘĤ蕸ࠡ좔聊桧垐黎⻜鿀ꈀ〵ć㺴㾵㥩㌠\\u0000ᤕ맓ꨘ梣쌊₴۠ౘ쑩䷪滓翀㩆榆͹陬퍾ᡕ냦馵䶾泶໥퀖ᄖ㫍㖮깷鮴\\udf6d깑췺渳熳\\udd86ꘈ坕鑅ﴘᯈ۴졁눔倝䑾食究㚣㦩뱬፵崦\\udea6ⷖ淓憛ᓧꝲ럙맍𢡄嬊\\udef6\\ud88cぬ궱沣샄൛ᡠ㛐㩉榇䏲䔬彫眐䄘ᔈ䂔젾聚ಭﷻݿ󚭶芴둍漱撹䳫㵸囐뤕艢薦쇻涗屖ᮗ⋛窀픐\\uda0a踧᧺뒤혓᳚䫘폆እ粒躵〳괐㛫ᐎ鄧捷埚蘇ꢔ燅鐜琶⬪窔淓⠽鐨轢◤鉷٭哮\\udea1轻揜鉼蝈㒡뵏핮鳿왰엢ꖤ骟圌ነ䓑࠵剚딓ᖔᚠ遪⮃ܿ锇툄䦧땸逎©㹢준灷ᄐ⋄賃ᒶླྀꌬ軃倽懝䤯⌃⪦ꬿꍨᬗ᫂ꭏ鯽槶쒶鰞Ⴊ蛽ꪠ胦곞匏杕懌萁╸茈᠜☑墔ᡏ궈ၘꚂᙋ퍀柦驦㩇無绔湜혁㞐媯઺Ιᥢ鹤檑ꋔ␂╕늟壝ḑ膗휦䤉\\u0000ᪧꚢ᪪뚳뗨଼岠늝少ﲖ\\ude0d햴Ð椖槖뽅읐令뼺뚵뤣ㄬ婦䇛묍郬각䡬ᡲHɱ䠵W椦죦뱹聙㗪礀Ѫ踓艠㊡컡ꓥ㫦郜Ⲇⵗ⣣둋者꼵띔띤ᒰ洉❯ో痩歭玬騤෺焙ꚟ聦崦矚㑯䁥滄⤴䀝瘒秎봶ꪑfܑ೏䳚蛺皴཈\\uda39侐(威娙朰の᠄䝡ͧᨨ칆ୁㆩ퓴躟퀒덝㠖繛ց澯㖆䞍俰ꁡ肕顰㘳竦づ匆㑚汋띍䔵ꟃ莠䝴湡꜃㥒댹㎧斓拋칃뀺랛㓥꭯편린䗂紋ꗨ럫긭ᅚ秐넢睜ꛭꬖ❅ό\\udf72뺏᳟Ϗ↝칞흷悀륞㼯躓{둫ꀊº⿬邌徆⻪෌톮뒭鈣⭳쩎䖖铃䤅ぎ鉗딡荂睪仠葤㗘ᾨ꬈ꜯ쎗虓徚೯㘅츘惌椇꧎ᾉ咰鐅殦솁焞ǂ힇㤭ガ睍인㋰Ᵽ濬꜇着赡✪ꑝ∗蠥섗ﻴ垠뼟ࢤ䕻䌑牺墱⊎迂厬崝㷍軏筣㺏\\ud8f2ᎁ\\udf38墝᭔\\udfc4ꘐ椓룖濣짞ﺋꉅ묨葄짫蓸΃揦䢚澑佡⾌헞鈹뷀ᛙ騈兟蹮钢儑탹請炑滄˝䃽뵝ꎋꆄ㨅頬鏕㊔瀙ヶ⦴勏Ẉ䄊讠\\udbaeα₺垍া೎㨸ꆙϫ匫븖㷝੷떍儆ᾆ㰠⭓빔愁⎜ࢥ幪添䟫掺砅홒ດ䐉倚窂㘋㐐꒫\\udb11芔Ĉ脯ᣋ탻筡ᗞ໱숵畘ꭸ䒤༑㺷匨ዽ᳛샚筞⃞홛㾦䍵磢竇臜曢ཻ␄쾵罿\\udd15ᅐఀㆸ졜醸犎骹肎⢨窫㨟漜瀩쳤Ɩ촆迆伩霜㶢᭫椙녿⊸ᧁ岸ⳁꛘ ᘀ瀝寖ﮒᘑ௩ꡙ腹곕冾ڼⅇ鉇\\udbf9ශ硋瞜捖欞弾䴌\\ud81b䋓ⓑ⠀⡯䀣˛꥙짩庪⍢嗿飕簰絞閕韑ꛫ眈箘㛬䜧똿ꑂ핃瀫쮳糆鳹㹥௪催럧笛\\ud82b粚㷨㋌ꑍ밈ᲘI窼낯숺뭌뢹￈깻\\ud9c6ﭬ筹䫋ᙲ瘹責藬⽐뺛\\udebaﳐ쮋빶揝\\udd9a셤嬛飾꽢퀑멲\\udaae枑䋘밞饹뵾⁚⚍鰜䲇簔߈⏶ㄠﯼ蹵奈㜂䐐刚뉝ꌨ頤Ԧǟ㚅⳿훨酽鋶鞀჏腟\\uda63⼂뵴ޏ䃐罻ጟ鄋숧ꄯ闷멜﷡齂鲳瞜ⲷ捘佹끴㿈咞⏨꾀쒆ꠁ혛袙놐⦀炢罡ः蘿گा氖侴倊ᴺ␄㴭䤩瘀뉭ꏝ䣱纀䁞ꬽ쯚착舯ʻ⛞꧕대馼ࠢ묆￞旸ྈ럅斻໸ㆥ\\ud915酳\u003e࠷悔﷖ಐ鼇뿧ኽ侅郗襠源㋍煸腁㳜삍㹰༈࣮烃∰㬛餛䳄ﹱ鞞ᨘ留䰭ﴬ\\udb61䧩烼荥퐁胔參㐳밅뱋勿杀㹐匮쾓ϥ믷絊੾ࠒ꿋㷯뿮훙꣼慪崫ﶊ﫿᥂㿡莏郾짱幥ឿ訔ਙ\\ud83dᕐ䠌韽ʥ啀堥\\udf99껴⡶Ӈ詮⩻짨穜碡⏇꣊㏙늁ق竺⯫⨁ᱯ䒪Ąᡜ施떸ꍹꧧ熌ǩ뀉⪧␁捹籩\\udea5炖ȤЎ毩᧬ဘḨ긂⼎谆阎堳栂謟䎐෴픩ꪧ萴Ị䏯樌ꮪ饙䪃꘸ꣲ惒⺒凩⡤⢣䆆〶为ⶥ댢ꙮ㢪懣骦쩙婩ꦋ뒬Ë裬ې洈笣゗僞䀈w˂襻∄昉祘ᨠᝂ彃㗏蠃脾串뎁䆈߯䲵腟䊘༰脌蹙㏥탞胩ࢬ騨ᬉㅨ较승稍떾꧹㗮뤘ᙶװՠ⦁Ɠ듯遀䂥肴ୠ䇜롳亩ﻥ¦븠Ѓᐖ恀쁅ݘɐ噺帇倉偧騳ꁟ麶祹෫ꄡŗ묄觞铞뻠拪㎏鸐ꎔ᱌❁쒠匂恻䄧箽✿밊촲巢쮪੬묨✰盾ᨊꮼ닎ՍƐ硾⋪坮瞂︵\\udb32阖䃻쟨쨧䄇ݫ捐毞✄﹎꾵䆚珞鹜ჲ쇮琳挧佢ఞ鯮挥븓۴ᳬ꘮䘆ꥩ恛ݶܰ䋂؀㠁힚퀮⓭끞܁騉䅋Դᩘ⏾葘퐙\\udc0b帄楂᎟ఐ镲滋鎲셦ԩꑿ鯪䯫灕\\udeecꋇ뗾켺或垀肯я⠎蟁ᐪ鰘遄蝼᪫蹎嫺⇉踯Ǔ耻췲꞊ᕐ\\udec6\\udc6a)䂊Ꝉ낅蟩ಡ膽濫ါꨡ䐛쁪{뇘᪔끁翉큂숐茈ʟ⻠⊲蔊䡛䅦ڬᲅ葾뽸\\udc15끽성娼᳝ꌨ⨄\\uda1a栞胷ꈄ⻨縠盈刘ힻ솯猪Ԩ倄弄꾁纊蘔੣㤀◺搮徉䋠蚈ᐈ硼穒炯휾ႍﯬ䳟茔그跠肝凜ၠ峞袇ⴁਘ䅃୿鹁㺄م䄅Մߨ厲鲅鿭⾆੼蘷怨睠෻愊⡾给碿䔊ꩣ쐒▇℁葋勾ㇺ忦ᡚ냽蘴ᠸ炘쮅皠径ꆔ裤ၷࢢ劇翯偵\\u000f蓾䤨酖ᗁﳀ贒뮱㙴᝙혅疳顈\\ud9e1腋⼪噻菀ျ扢敺㊐ָ鬨횚ၷ媬侵밞먡\\udb0f퀗ӳ蠑莂⺄כּ填耵␴鈱頁즺뎉넇䓱䛡ᵡ紓ᆄ“鉴謱Ȏ༒鯃餋쒳苀ṹ⓶㖸汬膒ƨᦑ⪀卮猨꽮➲쩝뭉꿄洑餉턺胴䘸꣄穸챇్焻ᇳᄠ㜑欐⻪ᄏì䲠Ễ橆᱊쑇莜䦤欑쾀焗ꑓ쒫ኼ䙻钜ᙆ됵鄭⤤Ⰴ㞩䐶瓱䦮쳲ꇀ䈻࿉稖겂冠ಇ蕀紡蠖Ŀꍟüﵡ껈඘\\ud836烷웠⁰㟑㟩㐰袊䖬옿⣨絪ᔐ쑍⍼蹔杨ꊧ\\u0016₰笰脺눨ݍ䢽쫊¾飆﷚펍䑪酞䒍ၱ`聸餠功ᇫᤑ❹࢑珚㛤붤鄭률ớ苶鉺줖늼鄶ᑔ炸פּ䴟\\udc2e삆冄㶓둏촵凸䏭ᄂ㞘卅顡匍쪱怀ฤ㺋煲曢锴\\udf45碳ၞ儮쩯鹄晹䇥愫새ꑬꝆꆢ䚂ౡ덒⧀ⱀ商夙ᨩ円뇎耣ꪀ㢫톏\\udc2d飀悁㡨﫹읢钛䂀ð渀뇔趒㵠㡥颒咗䘗৤恆쵚⧅撓૴욎蕥밈슘㰈ᦁ礮춼㹊䆛᠄䪊\\ud80d觀譀⎔䍱ⱄႴ꭯ⳗ⁮ᇁ\\ud8ed垷냩υ᳧뎎\\uda06룯풻軫檒丶骙ԇ꠼谴⭮ꮁ鼸纣ꖈʴפּᔀ귐ꇻ矧粚㋑卅ࠛ뾞꿰鱉汫肌﮽ⅰ긂컆\\udb1dꖂ陿䋼櫡뜲䂃쾦큆੺ɠ뤰꜒悪형ገ芌맀纀逍ᱡ帻虜᤟鿞癤硜绡蜼徱ꜱ☜懫萘⦜熰␀᜛騐ƹ駱ᖊⶾ俳員垍넊᭙믜 \\udb18馨䆀ȟ룡㛹鬜펲탏哱텻פၯ腉秲ܼ尡ﷆ橫熮鑈Fз᯦魀鱌１芗읔ޱ쟺讥嶐懑ᕜ缡伇㳤籛뱰ʟᦂღ跅⯤灌㸆ॕ฼俾㸕吩⛯ᵨߡ丹킯伲볥孉蟌羒챓퀄걹샣Ԯ쉘ీ态ऄᴔ蛕㢽贵ꍘ礪䤀㔓샰艮獰꙰㘢⁨쇫ᖠ淼㨅ᬗꁉ녘\\uda2fᾲἢᘇ騘䊑쥚ᣠ䆦ꌋ믁㱄焨蔈鑰螄㸄㬑䌪싫௏ᬷ舡ꚇⴋ袲怨䆪ఢ✒ᱩ㊨螆詘ʉﯥ吉ꢰ䮷ǫ钉आꢑ災⹻螗ᴸ篒닺\\udc96褺⒮`◡紇윓硹ꡚ鯨Ȩ蒉怦㈮밳∫苰⥠⊋墔ਤუ얲⏜枱ٙꌦ葫囗狭湼爡᫪ꈘ怢ꑐ檈鶼署ꠀ\\u0000✀㩴嘁偀踃౛쓈釠埈҃繄讒킑ޙ洼䠀㩂稊᠀恾臢舘ᓄ⯡㙏扭좉۷ᨓ蝡ᨧ᠏梜n쎠ޒ昀ا萄ᘯ慙⛳Β澈錧緢羪ᛏ쑗Ჿ菁헅ꬎ䐸璋┠࿢嫲脦ꘜ቎牡⟒ⶰጢ雀쒜㰷郿ꢊ⥒畉딤듀퉃⊯诌ࢢ봧㉰즣➾ᰀ坶ꀄᒦ頨킱촸ჴ㭈ᰄ瀇諥腁ඔꝜ않꽄ࢽ쀵厠㝀脪镪ঊऽ懟亼⹑筘沁䀒გ쳕ꅾ\\udd15Ȧ䈵獎࿞뚊쒃餡ꁋ麠\\ud9b9螞웇꒗㪒퉨쭬ᪿ뷪权쑏ᎁ툦≴ꤰꔒ擣皔쇒㈢蹦ᡀ䀚⹢ꓹ魘\\udefa⢕：貓씹测轎Ӂᢔ꘶ꝶོ䥱츦鿪쒜黼䵱அ䪛ᖴ\\udc46犣⣜规욦鳍牫ꙣ殲鲜瞠␀拓悝幱瀆鼑Ḑ樲욓ᩒ燙˜昀겂㪞✌⥈⒉쬿ㆬ졈Ǣꑡ톇䛟蓶鞐‗宂턍뮠戧諑批뛡➣ዡ뇠Ꮫ멤瑄嚝呄턵እ꡽醄晇崙摭턷䕖鳴倦⧃봙쀧톃፤攔罅컈塲䀅怰࠱܎ꠄ\\ude98≐ጉﯛꪮࢌ᱈쒢ઌ听צּ䚅턖ㅉ탣ᑂ珜츚샞煯䎺渀렂蔐㠹ㅷɨې 簛老续팓紣㇍ଶ⨺嬱丨猜튗ㅠ魉貘⯩쩗鋌ꗐᨤê⥉੍␍肽Ꚅ㷠변ฌ橴期䤊ꎀ䑤܋豞\\ud89cꚰ髧膱㒘ꧡ㩪柪嘊Ƨ㢯⺆멈梆霉᭘檥싯⡕↡꓃ꡘ一ᨫ䬔ἆ塺⤬靊樈믪犟厼⺍㥪隌ꡩ㲄뜦ﱣ癔騵Ⓥ锎幫팩亗퀈櫮ꢪ塲륙ᧈ䘖\\ude7a揯꛾⨀倄ᘔ狷䭂æ䇄㪦ꄂ䃮搖ὠၶ泻瓬Ꚗ낹䂕ꃼ嗁氒ﱻ観薯澩ↅ䓨\\uddbf᧲ꟳ⣬紾罁\\uda95䮳㺖ꕄᣬ宱⡫蚔Ɋ븹Ꞝᨕ껡溦Ზ㈞⟎ᵦ卙쥤쪝夢쭄ᅪ璉婛䐓䮟奖ꝩ惩郙╤僇ꦄ⩳穾ի삜囈⒍ꔋ❀⌅︟䀞၄⚼҇관⹫怎踶₭蘢웰騙ᝳ䚣逷ﮉ❟齚缈놘⩛ᧂꑱ骩ꦱ㌧鬚ꖿ繅ȏ㫞ꥈ鱏\\ud86fቐ൏Ꝏﵦ奘ଳ硙껆쎒놓朕騜呱躧㪒\\ud99d备␥鑲懡庥츚陞ႛ縷Ŗ獱쀧懃噴≘ᎎ捙慫떗⾣⡼鍊쀂晁擥喘㙛慎婎Ừ呖닢홠㤼ઓ鸨巉ʃ蘁\\udc7a楸ꇕ寙綕\\ud848䤉ꂬ鰿ꃩꠀㄆ뉧Ã螝⺪卉忰䛪剈웖梼葞夻봪衱슆钢共뚧鮜扬襨薴澂떹兺墒;䂦艨予ᦹ앪㢛噩熁蛓釪剙虤ꖓ္좋鵸巉诊厔⨵㧗҇韎敱䞒硚뤚䌞淉\\ud9a4䊇コ⊮૦쉾⌀⊉算씂ꑐꚚ佶䖦㏃\\ud80aဠ낇䁜ᷨ豤㰋塸䇸舤㹤脗疭劵儋䶋⤞\\ud9d1䑬ဤ儢㩡踞Ẉљ胀䖀᎐堃桂ꊆ鹷提෷ـ摇ꨪ婿쑇숂䰉࣮槊㉅ऐ撖鈤抉⨤뻊褤ဂ銵഻꒐㸂詀滃⯀᭛낑颣‖⑆텨یꆀ咑涤줙\\uda77渲秼䡼ݰ⟤ᾆ連鉆䵾彔럧턞褃識鄈˾縤슐羐綑遷Ɵ괤᮸楇։鋁㷹㤣䮄﹎׾킹軾䗶눘⍈ඏ冪ͨྙ࿨㺪蔜쀄ሎ탩셯㽰図ጅ㬠籗ꋨ菕㝈녉ﺐ배㖀᮱杧㨺ꀸꬊ춂组輇ꀚ鈸ꥸٶ殑ဒ퐎㢿ჿખҁㆀ琁ᄐ箊ㅺៜฤၘ誱顕枕䁚叞⵼᧴칁됇㩉ꦜᔙ쩤┘氀᷌咸Еəࣀ㍔⮞锲ᣠ栴ڍ঩っສꊊ\\u0014ꢤ駻぀׃뽯簄䄜၀纚픻⧦愈෻Ẫ뜨㬵扫쏖ᔅ蚑툖ㄸ搰ᖸ뢐聻嘎兮藿쏨宧ꎆ흘ﰈ밵窾篇欟ⷘ쵒旌း䕂킜ԃꨐ넗쑗ꄍ﫢ʠᭀᙘ咉쀛䔡鄰賡瑒뻳걕䀉ᙥ⼁ઐ황똭⅖辶蹶৖瓅왪鐫偝Ѡ⾤ﳹ᱑줢偭愒ꏪ묪跫䚇ꀈ밠ꯅ๢闉쎳鰊ᑎ⫔꣞ꖔ쐂ﶔऍ괮㯲쳡᎑锷ꑏ띸܂葌푔䀘肛襈㛞칒虅䪡扉叐ಪ꒐࠸釭ꤣẃ䕀驂᭐⩅ᾑ\\udc0c턿ῇ荩艹Q⑨֫䚯愁䑢\\udb45넬︁聼闬ꀩ拔蟙途踣⃙판圀♐⽄궛骬קǡӄẂ飓蠔⊔烟炄藻銀쎲ᣇ7m춂昩娻鱗ᅧ蛸䉍췰ჴ઱٭䐀䛋ሆ䂙㭅Ĩ늛ᜬ摰˼⫝̸⦨␗ါ긄邊侧ঞⱡ멡쒳⫉煁ੀ⚀둱੊셔ㅖ≂֙愑\\udde1⚃㺑뚷 ݋╥偱枥㨠g㭴쓪崵輦톞酯졯䇮⾀㤀঄蠗㲾䊧⬼ꈣ鄈栮뱥ꧡ૸␒䅀婓혡急茭茭肘䒢\\ud808㴜¹ड़衺⛥ꖂ␈풁Ƴ᮷%๠꽄騇루脧옹捬ꈡ媃樝ꢾ䓵ඹ翖ᰂ⹚㨡悧锏๹櫅㡂穙䀨ᝍ쵙䝰䘀ꝃ煲郫诪᭹栦Ḃ㬸氎싹ၹ怸덃掯呃ꡣꗛ쳉⡥윔穜︰ᕏ臒ꮸƀ灖渊㥊灄㫔賯⥠鬬츶ꋰ韌ஆⷰﲫ켄澸㲭韎젹㽆矀‌㥇汝돞孏㢈蠁㊋䊫污숒ꞔ出﯁ᩚ앀颭ꀾ墱Ꮵ⡔칔᥽뱫ᘁ奂ᕥう᠌抃Ⴥ阆鑽㺡㴣쁎䙢墵⃪圅哸ꉔ圂퀌梢\\u0004थ䮪鳰쥐⪜閃脏ꏅ嬕⩖⅙澼뀚嘨Ꝥހ\\udd03삏횔䁆咙刽㖥ꑕ敛簲煲涃궨鐁륞켴镩㋉吪茂Ꞌ簄푱堘ꥺ꣡汥ᅕ䀥ᠠ囘䁥傡檪酘怌皕윗᝚Ⲩ鉬พࢣ᫷戉蹪퉠尅अ⠼ߔ刈㪔↟ꪈ㛧ƃ滆有鱤檓\\udf82맙陣䃭載费뮩⩺奞Ω坙妖陎骶敵ߤ㼰狠逄蕼끞斣❎賙㔄ဉࠢ쓀訨岃补朗ꁐ㠗ᨦᖨꑯ௄Ā诡깸갆膚ﱂ冤ꪒ攻⡵町ӊ펦ᙡꦝ蟩庄⸡흺㌣땗큻녬枩ꆅ猩怏ᨆ\\u0010ꦀ\\n暥甏▵쉱엵᫨큦쐊ꬥ\\u0016툘ʌ樵炂댏葩ᔡ振␮ꋕ裆訞Ⴀ品᮳봺ʸ碖畵r庌ᤶ霥胨越馶卧Њⴋ鹭㔦⠮舭䵥垢ኢ땲ኋ迨쩨신⮬職ࢍ垚ብ䵴乗坃嘪曕뭫Დ㕾킟⌄⡥㝲攤ᩮ笳鐫剡楾⨖됎궴\\ud9c9Ғ⼊呕\\udb00䴌Ȯꄎ閨༦굈赔鍜㪰륛꜎掱㺂ᖡ溽햀彦ꡞ⤁ᬌ溷첡䅅麋让햒鹭皼暜頦箹縅唆㚘ሄ쳡候ꗁ䝚嶟尹鞽싣㺙ꭈ㎖∯⣭✼浢哫팤蚏⒪䃹捵娨睔㭚瞒秱擓⢖孙\\udde2\\udd98覵預ч֖텀눉\\u0000绋횓䘨ᚵ㋈ᙉ䈨⅑猏媵䠕㤉Ќꚍ畢㎏匠臵㣀谀ာ딣䇃墽䧕彂愆搚⁯倫輹൦螟뵺祝䄔ೳ」龛璛끗푫孪洔時ｘꨪ캩毼ٔܰ砈읚錾摛譍豯苨꿖搊뢲闘☿꺅杤忖儃﵋痑㦥嵀⟞䝔殧൵ဈ훝咍汙旄⃚鹧딙摧雝櫲據静啖ᕹ胷ㅕ찢ᄗ沃暸㙗૎仾⦆㽞酸梸聰\\ud997뢍쇦赘秈㘳鬽䁵떙奯㴕愹鑫컟麕ᶒ鴆ꀉ쒃휗偟襠稨轇掠쐋敾ቚ筊쑘풑㲜ᇆ嫔⪥㇢Ȉ帵ꕏ戩糑￦褟㶀拀ា馀䲥䧯⥴民㑝䀐㉸쓐ဢꓦ胖氺䮸镚䓖卹啦ꁡ셜⭥텂ⓓ卌㐴ҧҝ㻩먐벣ᆻ쩍䜨૙癴퇄걾瑛ꚽ尙忥寓癑쐮ậ啕ɓ呍የ㖹逸쎉傀♕솪攭ᨡ䪴惪冋̬롥꾧ᶎ飅ꦉ崽绍鑐煜굖珰ᑰ＂ࡏ闹䕨嬳濥埦♃⨨옻ণ硺䒧䄍骏㆝ꈍ壬ᫍ唷㓒䅑㥽焓卝㿕턖道䤱\\ud9d2揲龬笉蛆嚉㗄ੌ싥羀퓩䜍耕䓪늾ꄀ䎫씄獢ⵌ맂ᇢ椭䀵죕퉱륃䎸ᰠ㈀退냃蠯〲Ꮎ茮㔀❐됊䀫脹傈̼᷂숉렎遑훸\\udf1c䥠◹㘕⸷粧\\uda77쿭ത滃䜌ꚡඞ죘픽弨鲶錪ͷ㘢芀ⷬ뛕Ｂ⍺㓼៣盅醢䫝㵡惿ꏶ䙕紕⿉䐀㤶琌䁙惰⋐낃쑊ꀋⱫ០@ᔂᛕ孖▄೰榎蟤㶭宰붫窗僘䎉鸭墩쨎릣㮻儓뛕\\uded5甋ിᐄƨ랡⺁᠄恅聎軩눨ﲶߣ⮎뫀Ʀힾȸ颧햆⮒꺺㖅鎝曵雘⋥慝퉨쫶톀٭槥㭘\\udd90괳퐮ώ䏂즀\\udc55䉶频ñ务掴萃웕鵱⢜㖏巃捶묷囕歱핀ꆇ⽖✮躷↩ꦬඔ㚰쇬ᠾ竘耡惇몐胚㡭ሻꙶ궶䉷삛廉过➙捝㧵\\uda4f勖燵嘧쭂診둇΃傲瞴ࠌ歊嫜࿰㨝વ懜䍷㩅⟾ꑖ鼵婤ೣꙇ떎퓈\\ude72㼐Ჶ㜦ᙸ쥾枍赅ﲶ૞ဗᇀث䒭劷鸋⭁聙䄌ಀ០ᡴ퉀뤄ᙂ륧ↇ䭀໐魚讪\\ude96Œꙉ窬蝈ᷚ끰헃缹㬄廑歬㗳학阃䷭ꝕ\\udad7\\udb74൏뒺\\ud926怺ဧ嘏䋖胤ﺷ㚈᭘涀ꃪቤР恷浂횦\\ud967峭葶붭캎洇ꤱ\\ud89b捎ַ〄孺픃㪖폆祭̀ﭗ㌵浟鯖\\ud8ec㋨춶뛜〻涝⒱헛炮㶵藑\\udc0b䀃뜠ࢧ䖺ꎶ\\ud9dc学꥓뒮\\ude9c╝䣚쮲⩛귽槭勺䪕鷾햾ꕻ備㚵撂碵鵈蘵퓿ꀺ䣠璁ﭮ췟뒙僚ⓝﰶ췖끶Ձ\\ud883紹ￖ碔絽赕䌅駝ⓝሓǜ쀧籨璀⤷勎试ᇞ뎅ꂸ훝ଢ଼䰮➴惌歇觎吱푷棝♴ࣔ᪨㔌嶵\\ud9d0従門㛖꿍ህ꘰൤㺽时镞踕簈鑣褀䦚䁧满ꨀ贶Ȁ᝽痻ⓓ鮷咍㑶닢ཟ땿瑘針枹㭢蠁ᕅ⩑圾་熖체\\uddda쾕㵯眞힧䋭둷涯逃竼㓃兎耽㻓㝹駦㒸餣獵͵忨乼᷆ꂢ\\udcc5ޅ䨶䖈㵖媵훧깫詰궔\\udee5쁰쁑勊쇂걭枤偙ꪐ䶋슭敳摀垈ҏ簣쀃婥誔鄉ऑ뀎螰軔筤⩠⋰\\udd20㘫庖렟黒벤ẓ玌ꤩ뷩Ƞ允匤媓঎椇행邖⦤䧵佃융ꓨ辅喤䊔छ잢ę㘭ᓚ稁䀕⑁䵛䙜洛㡽誒䟜温⁥ꆪ䒁籽ᙠ柕ᤑꐑᆧ폠❽ꠖ᤮緉固穬䘒멋눻ꐍ䴟匈淴牜☻햙ڭ̔ꚓ⿕\\udf77쀱鎣켙ࣽ姷뤝䕵⊱Ŏ쫙睹뜆묫엂⎤ʨᎀꂶ㰂ଭ考Œ궉䐥⨚釢㞣␑쩠ۏ巘윒쨳鵀೽\\ude4b䕌哑䡐癏䂦ス쇮㴥⁎縮쭪꣬ଠꩡ䱊ꆅ铌ꉇ訴븠⅑尴⑒咝齧੕㰨䟒䃴頬垜턃鷢ꙡ傘췏膤ᘀ਽棘ম搕ᐥݠȽ㩅幑჊儐驇耭䯃䏀鯶絚蠊暒꬐ጤ＂Ꮝﴑ䀓ꉓ᠀ᵾ\\udc94耋雱ᙰ䴚㉸暒꩐彭榿剟捩ⴕ⥫椧ᤀ宀吅㭇ᠸѱ砛蕠六⻢\\udce5㑆씛䞵嚞쉕ྐྵ咹䒮왲㖆Ⅳ颦灐ᧀ傃㼬討鉗䑑䟘✀뻣焟血肩ᒰ廑Ϋ뜭碱൓䍽ㆍ醢㋓ꄸ䍐뉥싰㼐琶䅛툣墰䍑嬈饚刧̪֨ꂈᴞ쩑㰋閽삹⌲풕琭ʤ쐹䃜䍟閺榥ሴ夌\\udcd4䃲쌐ഹ촻㝈\\udab6唥ବ刅퇰읣⋢㔎냇㓅臵苍惀䰂퇍䍡殖왐헃亹䆄烢ⲵᦲ咲亜굩㠉옩춗㜨꙽㔩눨砂얕叹巰꾔솞ႏ韾Ꝫ⟥㜏閱㗩墈큀얳氰\\udf4b磸읹蚱漃樃㎉莻擦圵ꎯ븩࢔ฎ쁘듡闇埥猍ᢪṑ蕍慁嗏ꌇൃ傎充吼⛨垏沏婒ﹺ꒮뼼㶦熔ꩍᾆ霪레᱌㵍⫵岆攩鉃庐䙄ය乐쪪䥳⋔ｨ蹂遱Ⱒඕ詔瓝危Ә랏켶ꚁ걧㕡ⶢꘅ\\uddd8ⱃ푷◚㎷ᦪ妞\\udcfc蚭૕ᇈ墶鴇烒䉘⦒햶嶣ᝮ맭萌㼍㫤䏝칶\\udd5c蜆῏䂹䫷ᷛ1퇕芊棰⦅磓ꍭ疛眦᠎薖愇䜌륊⶚랜ॷ熌Ờ읩㺼▣ↇ仄굑㭣仺败\\udd63拭鼣닞育花眫훇弭ʶ渌뭈궼石࿇恂튶❼굅̠ҫ灎幨\\ud8c2㬅\\udb72Ḑ掣똾흄嵙땽ഗ毝覍嵛㷘쩝⬁荗딙癖햗䣣ꦯ捝涆ꈶ\\udcdb緖㽗＄က샵蹷졗䣀闗讙嶲琪퇘\\udf6d핵ᗘ㭠냃뛅햸ꖌ똾炛溍影扚\\ud8dcᏇ跺㗔㝝ǩ灍䄫雸w◨黳箐ⱁℓ\\ud98e偹답㝗灺挻ׁ햘節䓗캚Ȋᴺɳ\\udf96渓顴㷙᝗傸甲脝剎鸽\\ud809ᴥ⚽\\uda5d鉣獴១壩\\ud89e荖ㆫ徝鰀ꝕ\\udd3a甶㜗粹㡍\\udddfӜ賁ꡄ瞏㸰⽜眎㣇柣쟕Ď㣇ᵓ赱팸\\udf1d䔂䫐룠鴌ら퇠ᢝት䧝⮋雝뗉킧䨓䩶宭룚覣㧮㦩臣噎鄹魗㫙랄ᅸ쥏㮯᝛Ⓑ趖텇䥭辍浟콖㗝腖퇸徍ᮛ럥푘\\u0013꫷ķ⃠伕\\ud9db䱓攷릸崵痕혌荓軞擴섨헝\\udb64혓̹ᄶ訐폩땽\\ud93d䔓跋⧟ꌭᏔꐱ㖡ጓ뒤넶쓲挜丷噏粽㱎ෘ督⣊퉍㰒렂脽꬘鍋䀹ਧ䧣㥍錎憤훝ꝏ掞瓷᎝盱㦘퍓瓷됏♌湨䔩尰ࠥ懕㳘澖癚엨憩⪏솭콥佑㉝䋽뀒戋렠貾匉軀쌽䳴揑ᔟ堘Ώ侘읍潘೩㶈⥘퓤跛低ㆣ\\udccf絥䒱礬뽋퍸㕓퇴\\udace鸄ꀆ耋偤瘬ᗆ傽菘퓻Ꭾꔃ㫌蠊쇞೷㏽쨨\\ud804ᅓꋑ꽆ᢨ쳂剁쒵伨鵳ᒋ衺㶸栳坏䀠揁貙㨘ﹶ儷ࡼ൜䶭ぷ弓჌瑓栎ഉ◥熑癜䑅豐\\ud96c쪝\\ud840\\ud9c8፸茡錄\\udd0a煖竷煎쐹䡖⪈㳂᚜穔侜Ḝ⇹⮄㉆⿡촚䰷ꅰ㊉䀘࢔檑ƈ㞟䋀裇Ῑ耔⃋þ闥軵Ҁ㠫旭訔嘅랰硗ज़씃䚖铐옔Ⰷ曧ὅ唢ൠ獄䲪彣菍Ꜹ㭄렅헶䁗⑛ዳ켗袼\\ud9f9쯌꞊䳚ඏ膻噒왺痈鐎滑캯㖾뺥㳲䧂鰤ᦇ㓆裼尾졔മ娔頡皺尲ˋ䚿쵞웒㯘ٳ\\ude8d詎棙튌㣐໖쌓숄ޓ䂲䁒숈쑪烏ㅏ裮ᨌ㓼콀ཤ븴\\ud9f3嚽门盍ꗞ哴谾输僬ゖ逊睩饦甝⯼빓໥㜛⥹蝘귒㺣銩됏꣜쏆헀ބᾠ싻琝ழ폍璮戹፤돬ᖱ媬뙏姂Щךּ歰\\udd34昷倽㚵鎦ཕ匪찷嚬읦泏歋妐歇弜픍\\ud9a4⢲።ॵ㿕佘䱃⼺㴽⨬傖꒨ꀎ肵葉僒䨕萳摆ི㏓郔﵄䵓䶝ॄ\\uddcd胯䁟⫒逦⨃䔨덁℧⽃홋䭸摩쟘ᘵꟺ䱾볍䀈⏢䀐뒱搣쒎菈䋐遨唞墎讵ໃ僠ꍻ菑訨Ⴕᪧ爠䟶忠㾄㰚畎鵲ᓋ붕┋춨ዙ缫ꏌⰢ裂溎낱ⵤ逹鼑ᶤ倵᧓悔挂Ⳇ㓗䈨⬻賁Ꮨ丙技⋄쨃㉢팎䶕㬘앓ꕍソ⍍匭ຘ몼릋表\\udadb⋥햼轍험棣Ỉ荐云㪐휪ꥻ碽숶䯖싅㴻һ嵛泪ꥴᲽ哅浟䇕㗌ﭵ㯆씎䠢鏜偡窵䎓̜隅햩㨻稓얓띺덻瓁\\udfec繀粵듕驺嗉೰삙쬶쭂흣㳻䲽杌佾㗎䵓\\udd97睉즃켈躆ꂋ㿴ᢳ詎紶衔돤㔗勻椢檴ऺ:껞衘ᔫ♂튰ࢵ\\udcb7魍캋匤佐睩쯏咨Ų\\ud951魎睡鳨Ť꜖鈶뀋ꆣ俑僙橖鑝ੀ႐㟑魆쎵癊梀ഭ㧸鶚샕ᡘ⁆䊜鉢폟ĕ蜠砒ᛲኒ咲총ᘋ᫁㣬겖ﻚ\\ud905颐挏黰㘬뒯剕⸖门柦뷄ᷰ퍨酒峖ꆾ¨۾慀ﯧ뾧㳋擙鋦䇣慤㺶ۙ备䛝ǖ䈹⚀ङ볖웢靤\\ud929䕽怖렽鍻菇콆즙Ⅴ环誾蒢錮둰᫫ﬀ溾㽀㐳꽓㣱栬\\udd93ᙅ㠫깄飺㻢얄踳邌׃莠⚀✝퀩貧쮞벐᧺⣡硐昜藞ꥎ䑕\\ude01똭먓㖳䥼妐అ⣛⧹ġჺꀙ쯳蠉ᬷ覙螐\\uda45微蟇앥䃾ŊᎢ予\\u0015仁菓굦䫔㊭忧쁬⥶碠ᄩ厃ޯ䩕彎ƅ㛗\\ude99ᰛ뢒াꥮᐳ꾜Ͽ߳㶃䤮ᤏꩩ್ꎧῊ\\udaf9䤊敛搼塑騦唙Ȃ쩬ံ쩹䇜冠\\ud880椪ః쐏ᐬ鷥礑⫉\\ud9ecݪl篈䫈ꜮϾ검Ⓛ杂\\ud819䀤셿䅑멣প㴀䶢쭪⡑決旅㓕鬯㨽닗ৈ훌附솚杂ꀅುⓒ쐄੷柲ꋴⓣ歈餞柰\\ud98a报凛爞餅滚\\udc26㯨櫂愶⽌먋흚\\ude67䧒㹥⃫鰢棺抹靴\\udc2b穢쪘큏䠅铔㣛ꉦ薝⽅㖟ꩅ鋴馍쓴䇓뵒꬗侰뱸嗋髏窴囉嬌忠՛蝯㊷侊㥓㤕阶樹껇謥䓛섥힄咼ም葆ᘉ☻↶ⲓ\\ud907滛⃌瓀珻浳⿆槛騫閺♵浲嫝뽪䰹ᖟ๒㯐᲎䣲슯啟潡잚枫돸꘿롲꯽輹㨎ﺤ鶽ೡ湭㖎쌐㣮網计怄툚씤䖺ꢬษ뫔➠鮭៟婽莻귬椦间Ἳ⛍緸۠俎켸䩻瘂萿ᮖ샴폘ᄜ렍⣮䑭町孬高ঈێࡅᇠ醆坄\\ude22\\u0002攖첿⹌躗ﮥ즲䨧즫⠈Ṯ⋎뙺䐯쵰ꎧ㹃癀Ṙ괒ᱺሂኼ⧜欦쁜⚯ﬡ쑽⍚袈鵢䂻窗ꂂ쉣̜憸乚怇孄肢긞숑姻꤀㠕僣怹踗茢冺Ы᪉႔炚鐤〥⣲軈졖瘡泣\\ude16谳ꖳ傭찥딆䪈ڝᛆ嬎踽鵂좂⊦⫬팹莡촥家距⑙月㐛㝲ဈ퉁䥎湢烙豂퀣撨쪈掻ීӍ芴ረ䢃➰䲻኉뛿쯞碣儊②ꔒ\\udbbeꡁ著䶩ᒖ鼮߭퉙筅ᄲ䔰묃ᮺ​ﬧ享㋌쎋ᫎ峥곤禞佉⽀䷻껸센$慣䰻ꪫ皵賭턱䁸纈Ⅰ䀵뻁\\t꼁쀻蠞盳诚챒뜜腸恰ザ߮妊ۀ쎴㎴컩ܬ譮纃Ᾰ\\ud900蝴ᴓ볌诺鎾쳘㎨὾㛬ᬬ埯灿爲眀ॾ윀砞歒ꄅ蘿纼इ飰樈堆蝣ᘧ꜀쩛鲬䣛嬔뱮倐⚢倶蝘ꋨ甅鐇♤ᐄ懲긄ἐ⹡\\ude80룭衵䞢Ȗਁ쯄\\ude2c镩컇笼턱芻ꆁஷ婟龜䀀喓碻믍䦲Ů෉뜮퐔橭蘄껊믌兀⦦嫭\\ud8c9쩊㠳싮傸뿪ㅇ묶⦣ᷦ⻎Ȟ໢욶䭟馞䎩㇌约䗡혛䂦塻㚢뀖卓㭵饺䬟ᑐՅ푠臯ǩ蔋㸋ꈒ箁⢤璡❻⏬ᛍᮃ᰾߱辵䋒谜Ⓔ㴾廅ꊌဦ觑惧끰榘᫯ꌈК໻삞홣赐胩퉂绡잹႘ᡋ標砺㚇正梢爆䧿ὐ̤㎂✐ﱵ爜x鲂ӊ캇\\udd25ᘈ넰聀ቤ໲㰧岴箚災誯䖝ఠự痕ﶽ뛷⭌Ἠ瓢샣蟔䘓怼蓥膒糀ຽ냁ᇥ蝗ꍘ禴ᕐꂞ㩑ৃ⋉骷ᰧꪜ耄觫샀鵉뒟ﱱጌब鸇ۉ者⑷꽦έ륎㤑耀껟ꃙỘ㺓幇餵ⴔ凤뮇꺔籺磊\\udda6뵏움줵ᶩ뙠못\\udd83榱뽍෾堻ᘕﻐꠐᕅ灎췖虤ⷵ驻\\udbb8曼摧Ⱂ駔ᢒ鍂밭䠊똉䉊蚲뻉쏋鋦䈲ꡃ傪鐵떋ဨ퓯歲꼔ⷅ爗㪺末ퟑ좌懲ꑩ䮑꺤럕뭤훎뙃봫쏟᧯訜悶燿ド罁穻쵄덈꣨‑⹣㯴堢售㰀栘璺憿㙱ﭻ᜞銆雫肱洭ͱ둭眣麂퀷鳅먲♛더킾햮럇ᆬ辫欃밂䴁掺愘胔扺讔ꚙ텧혁訂䑥宼⴪閊썛睕㖲흓䰂뮅\\udf2b㋀芴楺⮽溙\\udfd6\\udf0bꄄꀎ畲른꽘볫䫛᫩⊶൏㩲꠶皊헛Ａ࣓亨贞䵊焙焎汰ꆶ뺋딈洰㴙缗丆ﳂ淏⽼몔ﮎ䓣哎㔿俲硅ꄇꀊꐩ㗘꾍闿ɠ祦歓賕齫娱㞠駢置耖â䇫岓똜噞롘樬韊췁硍甗틔飯柅鶗䨾꫔迊泸뗨춺㍭叻Ս륲ꫫ⹴徒뽂숨蒭仍卤궂듉\\udd3d륶㰊빲㣺촥䍽疀쓡䝞蓻ꯙ푒緖楙䦁윶旱ʏ嗦竍熰ۢꞢ豈蝶ʘ\\udd16氇驏ﹹ벂莀듖簅冭⼝ע퍗ู㞅쬋ኧ赱ꗳ錈屦璅\\ud990㛆ឍ氪뽢튇筯륽ꯜ띦㷦⹣롷柳嶏欜ﵝ眬╰ﻂ揲깼熒娨՜說㓎⹴봵쬇驟患壯霋岡祄\\ud847༈✯䓢梦㆟퓸ㄋ賌̰쇎\\udb7c鵭猕뭜箐䀭唨Ǫ볲姗矖ꋃﲘ컊뜳ᢵ牟큷拂ޛ崃낍헓檮煷䦼츳\\ude8f呕༇㌸댤㒚댬\\ud9abﱝ媻䧬篇Յ嗽丷⬷썓쭰㜓믎簷擬昶ꇠ珽쨃䅱漰던睌詁染㖝狂䡗唲봨什䧚퓥倪荨熝㠜蝋꥽眵쫵技띲甭w뗼堵À敺㫡넟ꨆⅸʎ➰┅뇀「ቀꏼℶ醀佟퇍㋳ᐃ鲛㎣湐㫴耟伝Ꭓ鎑Ꮨ⯑㧃㤒㼦였ट늞컒\\ude0d蛜尻Ბ㓜堌녚됙䟁కഠ\\udfb8䫥饝ҥ麮炔뙗\\udc07ꉜꑴ梕煠ᤀᎈ瀨麗ꘇ䪯᠛〓甜㢂ӓᲅ裖㩐䑦옔态‾抈蜖馋찘⟉⅂횜㐑脣㦭렿聞叏೦변䎂⭌꡻縿ǳ䛅邕삘襘謻ꇼ驰Ħࢼ풋ˊ…⓿畜၊㟐奪吳教譩峀뎗舯䢀㶒齥毷淩ྣ圙쀢ఠऀ㚣솃૮篰㼫쫴澔槊䚊琝脂읊ꔋ㖽鴖♿䀻䃚艢\\ud994᪣°㚀䢜渀ԇ빎⼠︀젇ၮ沧䎈ਔက\\u0000\",\"actionData\",\"errors\"]\n");</script><!--$?--><template id="B:1"></template><!--/$--></div><script>$RB=[];$RV=function(a){$RT=performance.now();for(var b=0;b<a.length;b+=2){var c=a[b],e=a[b+1];null!==e.parentNode&&e.parentNode.removeChild(e);var f=c.parentNode;if(f){var g=c.previousSibling,h=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d||"/&"===d)if(0===h)break;else h--;else"$"!==d&&"$?"!==d&&"$~"!==d&&"$!"!==d&&"&"!==d||h++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;e.firstChild;)f.insertBefore(e.firstChild,c);g.data="$";g._reactRetry&&requestAnimationFrame(g._reactRetry)}}a.length=0};
$RC=function(a,b){if(b=document.getElementById(b))(a=document.getElementById(a))?(a.previousSibling.data="$~",$RB.push(a,b),2===$RB.length&&("number"!==typeof $RT?requestAnimationFrame($RV.bind(null,$RB)):(a=performance.now(),setTimeout($RV.bind(null,$RB),2300>a&&2E3<a?2300-a:$RT+300-a)))):b.parentNode.removeChild(b)};$RC("B:0","S:0")</script><div hidden id="S:1"><script>window.__reactRouterContext.streamController.close();</script></div><script>$RC("B:1","S:1")</script></body></html>