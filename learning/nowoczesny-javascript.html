<!DOCTYPE html><html lang="pl"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="modulepreload" href="/fetch.js"/><link rel="icon" href="/favicon.svg" sizes="any" type="image/svg+xml"/><link rel="preload" as="style" href="/assets/styles-CsCoTtlD.css"/><link rel="preload prefetch" href="/fonts/geist.ttf" as="font" type="font/ttf" crossorigin="anonymous"/><title>Renesans w JS, czyli nowoczesny JavaScript - Jakub Szpil</title><meta name="description" content="JavaScript jest językiem programowania, który jest powszechnie stosowany do tworzenia dynamicznych i interaktywnych stron internetowych. W ciągu ostatnich lat JavaScript znacznie ewoluował, wprowadzając nowe funkcje i poprawiając istniejące mechanizmy. W tym kursie omówimy najważniejsze elementy nowoczesnego JavaScript, w tym ES6 i nowsze."/><meta name="keywords" content="javascript,kurs,wprowadzenie,przewodnik,web,frontend,learning"/><meta property="article:published_time" content="2024-06-30T00:00:00.000Z"/><meta property="og:type" content="article"/><meta property="og:url" content="https://jakubszpil.github.io/learning/nowoczesny-javascript/"/><meta property="og:title" content="Renesans w JS, czyli nowoczesny JavaScript - Jakub Szpil"/><meta property="og:description" content="JavaScript jest językiem programowania, który jest powszechnie stosowany do tworzenia dynamicznych i interaktywnych stron internetowych. W ciągu ostatnich lat JavaScript znacznie ewoluował, wprowadzając nowe funkcje i poprawiając istniejące mechanizmy. W tym kursie omówimy najważniejsze elementy nowoczesnego JavaScript, w tym ES6 i nowsze."/><meta property="twitter:card" content="summary_large_image"/><meta property="twitter:url" content="https://jakubszpil.github.io/learning/nowoczesny-javascript/"/><meta property="twitter:title" content="Renesans w JS, czyli nowoczesny JavaScript - Jakub Szpil"/><meta property="twitter:description" content="JavaScript jest językiem programowania, który jest powszechnie stosowany do tworzenia dynamicznych i interaktywnych stron internetowych. W ciągu ostatnich lat JavaScript znacznie ewoluował, wprowadzając nowe funkcje i poprawiając istniejące mechanizmy. W tym kursie omówimy najważniejsze elementy nowoczesnego JavaScript, w tym ES6 i nowsze."/><link rel="modulepreload" href="/assets/manifest-f351e186.js"/><link rel="modulepreload" href="/assets/entry.client-D07Jc1yP.js"/><link rel="modulepreload" href="/assets/jsx-runtime-D_zvdyIk.js"/><link rel="modulepreload" href="/assets/chunk-OIYGIGL5-Rdhby1S0.js"/><link rel="modulepreload" href="/assets/index-DJQXGD61.js"/><link rel="modulepreload" href="/assets/root-BycHyJkk.js"/><link rel="modulepreload" href="/assets/layout-DTSVQAyN.js"/><link rel="modulepreload" href="/assets/button-BMGgmMxT.js"/><link rel="modulepreload" href="/assets/link-with-prefetch-DYt-PuIQ.js"/><link rel="modulepreload" href="/assets/icons-BBGQWBin.js"/><link rel="modulepreload" href="/assets/socials-DGthjeXP.js"/><link rel="modulepreload" href="/assets/date-NK96Yl5Q.js"/><link rel="modulepreload" href="/assets/not-found-BbFjFHzP.js"/><link rel="modulepreload" href="/assets/seo-Do91G143.js"/><link rel="modulepreload" href="/assets/course-details-B5tvZ0eW.js"/><link rel="modulepreload" href="/assets/categories-BnZHVW1j.js"/><link rel="modulepreload" href="/assets/edit-resource-Bp0MeTOm.js"/><link rel="modulepreload" href="/assets/banner-DCe0eTPI.js"/><link rel="modulepreload" href="/assets/compress-4c0pvVl7.js"/><link rel="modulepreload" href="/assets/creation-date-x1jkwlYO.js"/><link rel="stylesheet" href="/assets/styles-CsCoTtlD.css"/><script>globalThis.timestamp=1761469370649</script><script>let k="theme";let t="dark";let s=localStorage;let c=document.documentElement.classList;let v=s.getItem(k);if(v===null||v==="SYSTEM")matchMedia("(prefers-color-scheme:dark)").matches?c.add(t):c.remove(t);else if(v==="DARK")c.add(t);else if(v==="LIGHT")c.remove(t);else s.removeItem(k);</script><script type="module" src="/fetch.js"></script></head><body style="-webkit-tap-highlight-color:transparent"><header class="sticky w-full bg-background top-0 left-0 z-50 border-b"><div class="container pb-3! pt-4! px-3! flex justify-between items-center"><a data-slot="button" class="button button--variant-ghost button--size-sm font-bold" href="/" data-discover="true">jakubszpil</a><div class="flex flex-1 justify-end items-center sm:gap-1"><nav class="hidden items-center lg:flex"><a data-slot="button" class="button button--variant-ghost button--size-sm" href="/" data-discover="true">🏠 Strona główna</a><a data-slot="button" class="button button--variant-ghost button--size-sm" href="/blog" data-discover="true">📝 Blog</a><a data-slot="button" class="button button--variant-ghost button--size-sm" href="/learning" data-discover="true">🏫 Learning</a><a data-slot="button" class="button button--variant-ghost button--size-sm" href="/portfolio" data-discover="true">🛠️ Portfolio</a><a data-slot="button" class="button button--variant-ghost button--size-sm" href="/me" data-discover="true">🙋‍♂️ O mnie</a></nav><a data-slot="button" class="button button--variant-ghost button--size-icon inline-flex items-center justify-center" aria-label="Szukaj" title="Szukaj (CTRL+K)" href="/search" data-discover="true"><span class="sr-only">Szukaj</span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="size-6"><path d="M10 10m-7 0a7 7 0 1 0 14 0a7 7 0 1 0 -14 0"></path><path d="M21 21l-6 -6"></path></svg></a><div class="hidden xs:flex items-center sm:gap-1"><a href="https://www.linkedin.com/in/jakubszpil/" target="_blank" rel="noreferrer" data-slot="button" class="button button--variant-ghost button--size-icon inline-flex items-center gap-1 no-underline" title="LinkedIn" aria-label="LinkedIn"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="size-6"><path d="M8 11v5"></path><path d="M8 8v.01"></path><path d="M12 16v-5"></path><path d="M16 16v-3a2 2 0 1 0 -4 0"></path><path d="M3 7a4 4 0 0 1 4 -4h10a4 4 0 0 1 4 4v10a4 4 0 0 1 -4 4h-10a4 4 0 0 1 -4 -4z"></path></svg><span class="sr-only">LinkedIn</span></a><a href="https://github.com/jakubszpil/" target="_blank" rel="noreferrer" data-slot="button" class="button button--variant-ghost button--size-icon inline-flex items-center gap-1 no-underline" title="GitHub" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="size-6"><path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5"></path></svg><span class="sr-only">GitHub</span></a></div><button data-slot="dropdown-menu-trigger" class="button button--variant-ghost button--size-icon cursor-pointer" title="Zmień motyw" type="button" id="radix-_R_4ej5_" aria-haspopup="menu" aria-expanded="false" data-state="closed"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="size-6"><path d="M9.173 14.83a4 4 0 1 1 5.657 -5.657"></path><path d="M11.294 12.707l.174 .247a7.5 7.5 0 0 0 8.845 2.492a9 9 0 0 1 -14.671 2.914"></path><path d="M3 12h1"></path><path d="M12 3v1"></path><path d="M5.6 5.6l.7 .7"></path><path d="M3 21l18 -18"></path></svg></button><button data-slot="button" class="button button--variant-link button--size-icon inline-flex items-center justify-center relative z-50 lg:hidden" aria-label="Otwórz menu"><span class="sr-only">Otwórz menu</span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="size-6 text-black! dark:text-white!"><path d="M4 6l16 0"></path><path d="M4 12l16 0"></path><path d="M4 18l16 0"></path></svg></button></div></div></header><main><header class="prose container"><h1 class="mb-5">Renesans w JS, czyli nowoczesny JavaScript</h1><div class="text-xs sm:text-sm my-6"><div class="inline-block" title="Data opublikowania"><span class="mr-0.5">📆</span><span class="hidden">Data opublikowania:</span><time>30 czerwca 2024</time></div><span class="ml-2 mr-1">/</span><div class="inline-block sm:inline" title="Czas potrzebny na przeczytanie"><span class="mr-0.5">⌛</span><span class="hidden">Czas potrzebny na przeczytanie:</span>18 minut<!-- --> czytania</div></div><div class="flex items-center gap-3 flex-wrap"><a data-slot="button" class="button button--variant-secondary button--size-sm no-underline!" href="/learning/kategorie/javascript" data-discover="true">JavaScript</a></div></header><article class="prose container pt-0 prose-emerald"><p>Witaj w świecie <strong>nowoczesnego JavaScriptu</strong>! 🚀 Jeśli HTML to szkielet strony, a CSS to jej wygląd, to JavaScript jest sercem i mózgiem - sprawia, że strona ożywa, staje się interaktywna i dynamiczna. W ciągu ostatnich lat JavaScript przeszedł prawdziwy "renesans". Dzięki wprowadzeniu standardu <strong>ES6</strong> (ECMAScript 2015) i kolejnych aktualizacji, pisanie kodu w JS stało się znacznie przyjemniejsze, bezpieczniejsze i bardziej efektywne.</p>
<p>Ten przewodnik zabierze Cię w podróż po najważniejszych nowościach, które musisz znać, aby pisać <strong>nowoczesny JavaScript</strong>. Nie martw się, jeśli jesteś początkujący/a - wszystko wyjaśnimy krok po kroku, z przykładami i analogiami, byś mógł/mogła od razu zastosować nową wiedzę w praktyce. Czas unowocześnić swoje umiejętności! ✨</p>
<h2 id="spis-treści" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#spis-treści">>></a>Spis treści</h2>
<ol>
<li><a href="#zmienne-let-const-i-zakresy-blokowe--po%C5%BCegnanie-z-var">Zmienne: <code>let</code>, <code>const</code> i zakresy blokowe - pożegnanie z <code>var</code>?</a></li>
<li><a href="#funkcje-strza%C5%82kowe-arrow-functions-i-ich-zastosowania--kr%C3%B3cej-i-czytelniej">Funkcje strzałkowe (Arrow Functions) i ich zastosowania - krócej i czytelniej</a></li>
<li><a href="#szablony-string%C3%B3w-template-literals--%C5%82atwiejsza-praca-z-tekstem">Szablony stringów (Template Literals) - łatwiejsza praca z tekstem</a></li>
<li><a href="#destrukturyzacja-tablic-i-obiekt%C3%B3w--wyci%C4%85gnij-to-czego-potrzebujesz">Destrukturyzacja tablic i obiektów - wyciągnij to, czego potrzebujesz</a></li>
<li><a href="#spread-i-rest-operator---elastyczno%C5%9B%C4%87-w-manipulacji-danymi">Spread i Rest Operator (<code>...</code>) - elastyczność w manipulacji danymi</a></li>
<li><a href="#promise-api-i-obs%C5%82uga-asynchroniczno%C5%9Bci--opowiadaj-historie-o-przysz%C5%82o%C5%9Bci">Promise API i obsługa asynchroniczności - opowiadaj historie o przyszłości</a></li>
<li><a href="#asyncawait--nowoczesna-obs%C5%82uga-kodu-asynchronicznego--pisz-asynchronicznie-my%C5%9Bl-synchronicznie">Async/await - nowoczesna obsługa kodu asynchronicznego - pisz asynchronicznie, myśl synchronicznie</a></li>
<li><a href="#zadania-do-wykonania-sprawd%C5%BA-swoj%C4%85-wiedz%C4%99">Zadania do wykonania: Sprawdź swoją wiedzę!</a></li>
</ol>
<hr>
<h2 id="zmienne-let-const-i-zakresy-blokowe---pożegnanie-z-var" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#zmienne-let-const-i-zakresy-blokowe---pożegnanie-z-var">>></a>Zmienne: <code>let</code>, <code>const</code> i zakresy blokowe - pożegnanie z <code>var</code>?</h2>
<p>W starszych wersjach JavaScriptu zmienne deklarowaliśmy wyłącznie za pomocą słowa kluczowego <code>var</code>. Często prowadziło to do pomyłek i trudnych do wykrycia błędów. Nowoczesny JavaScript wprowadza dwa nowe sposoby deklarowania zmiennych: <strong><code>let</code></strong> i <strong><code>const</code></strong>, które znacznie poprawiają bezpieczeństwo i przewidywalność kodu.</p>
<h3 id="zakres-blokowy-block-scope" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#zakres-blokowy-block-scope">>>></a>Zakres blokowy (<code>block scope</code>)</h3>
<p>To kluczowa różnica! Zmienne zadeklarowane za pomocą <code>let</code> i <code>const</code> mają <strong>zakres blokowy</strong>. Co to znaczy? Oznaczają, że zmienna istnieje tylko w obrębie najbliższego <strong>bloku kodu</strong>, czyli wszystko, co znajduje się między klamrowymi nawiasami <code>{ ... }</code>.</p>
<p>Pomyśl o tym jak o specjalnej, prywatnej przestrzeni. Jeśli zmienna <code>x</code> jest zadeklarowana wewnątrz bloku <code>if</code>, będzie dostępna tylko w tym bloku. Próba użycia jej poza nim spowoduje błąd. To chroni Cię przed przypadkowym nadpisaniem zmiennych o tej samej nazwie w innej części kodu.</p>
<p><strong>Przykład:</strong></p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) {
  <span class="hljs-keyword">let</span> x = <span class="hljs-number">5</span>; <span class="hljs-comment">// x istnieje tylko wewnątrz tego bloku if</span>
  <span class="hljs-keyword">const</span> y = <span class="hljs-number">10</span>; <span class="hljs-comment">// y również istnieje tylko wewnątrz tego bloku</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x); <span class="hljs-comment">// Wyświetli: 5 (dostępne, bo jesteśmy w bloku)</span>
}
<span class="hljs-comment">// console.log(x); // WYWOŁA BŁĄD! ReferenceError: x is not defined</span>
<span class="hljs-comment">// console.log(y); // WYWOŁA BŁĄD! ReferenceError: y is not defined</span>
</code></pre>
<p>Dla porównania, <code>var</code> ma <strong>zakres funkcyjny</strong> (function scope), co oznacza, że zmienna zadeklarowana w funkcji jest dostępna w całej funkcji, ale poza funkcją jest dostępna globalnie, co jest źródłem wielu problemów. Dlatego w nowoczesnym kodzie <strong>zdecydowanie unikamy <code>var</code></strong>.</p>
<h3 id="różnice-między-let-const-i-var" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#różnice-między-let-const-i-var">>>></a>Różnice między <code>let</code>, <code>const</code> i <code>var</code></h3>
<ul>
<li>
<p><strong><code>let</code></strong>:</p>
<ul>
<li><strong>Deklaruje zmienną</strong>, której wartość może być <strong>zmieniana</strong> w dowolnym momencie.</li>
<li>Ma <strong>zakres blokowy</strong>.</li>
<li>Nie można jej ponownie zadeklarować w tym samym bloku (np. <code>let x = 5; let x = 10;</code> to błąd), ale można zmienić jej wartość (<code>x = 10;</code>).</li>
<li>Używaj <code>let</code>, gdy wiesz, że wartość zmiennej będzie się zmieniać (np. licznik w pętli).</li>
</ul>
</li>
<li>
<p><strong><code>const</code></strong>:</p>
<ul>
<li>Deklaruje <strong>stałą</strong>, której wartość musi być <strong>przypisana od razu</strong> i <strong>nie może być zmieniana</strong> później.</li>
<li>Ma <strong>zakres blokowy</strong>.</li>
<li>Jeśli przypiszesz do <code>const</code> obiekt lub tablicę, nie możesz przypisać do niej <em>nowego</em> obiektu/tablicy, ale możesz <strong>modyfikować zawartość</strong> tego obiektu/tablicy (np. dodawać lub usuwać elementy). <code>const</code> gwarantuje, że referencja (wskaźnik) do obiektu pozostaje taka sama, ale nie "zamraża" samego obiektu.</li>
<li>Używaj <code>const</code>, gdy wartość zmiennej nie powinna się zmieniać. To jest domyślny wybór w nowoczesnym JS, chyba że potrzebujesz <code>let</code>.</li>
</ul>
</li>
<li>
<p><strong><code>var</code></strong>:</p>
<ul>
<li><strong>Ma zakres funkcyjny</strong> (lub globalny, jeśli jest poza funkcją).</li>
<li>Jest podatny na <strong>hoisting</strong> (podnoszenie deklaracji), co oznacza, że deklaracja zmiennej jest "przenoszona" na początek zakresu, co może prowadzić do nieintuicyjnych zachowań.</li>
<li>Można go <strong>wielokrotnie deklarować</strong> w tym samym zakresie, co łatwo prowadzi do przypadkowych nadpisań.</li>
<li><strong>Unikaj używania <code>var</code> w nowym kodzie!</strong></li>
</ul>
</li>
</ul>
<p><strong>Przykład <code>const</code> z obiektem/tablicą:</strong></p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> tablica = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
tablica.<span class="hljs-title function_">push</span>(<span class="hljs-number">4</span>); <span class="hljs-comment">// DOZWOLONE! Zmieniamy zawartość tablicy, nie przypisujemy nowej tablicy.</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(tablica); <span class="hljs-comment">// Wyświetli: [1, 2, 3, 4]</span>

<span class="hljs-comment">// tablica = [5, 6]; // WYWOŁA BŁĄD! TypeError: Assignment to constant variable.</span>
<span class="hljs-comment">// Próbujesz przypisać zupełnie nową tablicę do stałej referencji.</span>

<span class="hljs-keyword">const</span> osoba = { <span class="hljs-attr">imie</span>: <span class="hljs-string">"Anna"</span>, <span class="hljs-attr">wiek</span>: <span class="hljs-number">28</span> };
osoba.<span class="hljs-property">wiek</span> = <span class="hljs-number">29</span>; <span class="hljs-comment">// DOZWOLONE! Zmieniamy właściwość obiektu, nie przypisujemy nowego obiektu.</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(osoba); <span class="hljs-comment">// Wyświetli: { imie: "Anna", wiek: 29 }</span>

<span class="hljs-comment">// osoba = { nazwisko: "Nowak" }; // WYWOŁA BŁĄD!</span>
</code></pre>
<hr>
<h2 id="funkcje-strzałkowe-arrow-functions-i-ich-zastosowania---krócej-i-czytelniej" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#funkcje-strzałkowe-arrow-functions-i-ich-zastosowania---krócej-i-czytelniej">>></a>Funkcje strzałkowe (Arrow Functions) i ich zastosowania - krócej i czytelniej</h2>
<p>Funkcje strzałkowe to zwięzła alternatywa dla tradycyjnych funkcji JavaScript, która została wprowadzona w ES6. Są nie tylko krótsze, ale także rozwiązują pewien problem z kontekstem <code>this</code>, który często mylił początkujących programistów.</p>
<h3 id="składnia-funkcji-strzałkowej" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#składnia-funkcji-strzałkowej">>>></a>Składnia funkcji strzałkowej</h3>
<p>Największą zaletą funkcji strzałkowych jest ich zwięzła składnia, zwłaszcza dla prostych funkcji.</p>
<ul>
<li>
<p><strong>Szybszy zapis (szczególnie dla funkcji jedno-liniowych):</strong>
Jeśli funkcja składa się tylko z jednej instrukcji, która zwraca wartość, możesz pominąć nawiasy klamrowe <code>{}</code> i słowo kluczowe <code>return</code>.</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// Tradycyjna funkcja</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">dodajStara</span>(<span class="hljs-params">a, b</span>) {
  <span class="hljs-keyword">return</span> a + b;
}

<span class="hljs-comment">// Funkcja strzałkowa (krótszy zapis)</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">dodaj</span> = (<span class="hljs-params">a, b</span>) => a + b;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">dodaj</span>(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">// Wyświetli: 8</span>

<span class="hljs-comment">// Funkcja z jednym argumentem (można pominąć nawiasy wokół argumentu)</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">powitanie</span> = (<span class="hljs-params">imie</span>) => <span class="hljs-string">`Cześć, <span class="hljs-subst">${imie}</span>!`</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">powitanie</span>(<span class="hljs-string">"Ola"</span>)); <span class="hljs-comment">// Wyświetli: Cześć, Ola!</span>

<span class="hljs-comment">// Funkcja bez argumentów (konieczne puste nawiasy)</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">powiedzHello</span> = (<span class="hljs-params"></span>) => <span class="hljs-string">"Hello!"</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">powiedzHello</span>()); <span class="hljs-comment">// Wyświetli: Hello!</span>
</code></pre>
</li>
<li>
<p><strong>Brak własnego obiektu <code>arguments</code>:</strong> Funkcje strzałkowe nie mają własnego obiektu <code>arguments</code> (który zawiera wszystkie argumenty przekazane do funkcji). Jeśli go potrzebujesz, użyj <strong>rest operatora</strong> (<code>...</code>), o którym powiemy później.</p>
</li>
<li>
<p><strong>Brak możliwości użycia jako konstruktor:</strong> Nie możesz użyć funkcji strzałkowej do tworzenia nowych obiektów za pomocą słowa kluczowego <code>new</code>.</p>
</li>
</ul>
<h3 id="funkcje-strzałkowe-a-kontekst-this" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#funkcje-strzałkowe-a-kontekst-this">>>></a>Funkcje strzałkowe a kontekst <code>this</code></h3>
<p>To jest jeden z najważniejszych powodów, dla których wprowadzono funkcje strzałkowe. W tradycyjnych funkcjach, wartość <code>this</code> zależy od tego, jak funkcja jest wywoływana. To prowadziło do częstych błędów, zwłaszcza w callbackach (funkcjach wywoływanych przez inne funkcje, np. w <code>setTimeout</code> czy w obsłudze zdarzeń).</p>
<p>Funkcje strzałkowe rozwiązują ten problem: <strong>nie mają własnego <code>this</code></strong>. Zamiast tego, <strong>dziedziczą <code>this</code> z otoczenia, w którym zostały zadeklarowane</strong> (tzw. leksykalny <code>this</code>).</p>
<p><strong>Przykład problemu ze <code>this</code> w tradycyjnych funkcjach:</strong></p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// Tradycyjna funkcja, która "gubi" kontekst this</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">TimerProblem</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">sekundy</span> = <span class="hljs-number">0</span>;
  <span class="hljs-built_in">setInterval</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-comment">// Tutaj 'this' nie odnosi się do obiektu TimerProblem,</span>
    <span class="hljs-comment">// ale do obiektu globalnego (np. window w przeglądarce) lub jest undefined w trybie 'strict mode'</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">sekundy</span>++; <span class="hljs-comment">// To nie zadziała tak, jak byśmy chcieli!</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">sekundy</span>);
  }, <span class="hljs-number">1000</span>);
}
<span class="hljs-comment">// new TimerProblem(); // W konsoli prawdopodobnie zobaczysz NaN lub błąd</span>
</code></pre>
<p><strong>Rozwiązanie z funkcją strzałkową:</strong></p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">TimerPoprawny</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">sekundy</span> = <span class="hljs-number">0</span>;
  <span class="hljs-comment">// Funkcja strzałkowa dziedziczy 'this' z TimerPoprawny (czyli z obiektu TimerPoprawny)</span>
  <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">sekundy</span>++;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Sekundy: <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.sekundy}</span>`</span>);
  }, <span class="hljs-number">1000</span>);
}
<span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerPoprawny</span>(); <span class="hljs-comment">// Będzie poprawnie liczyć sekundy: Sekundy: 1, Sekundy: 2, itd.</span>
</code></pre>
<p>Dzięki temu funkcje strzałkowe są idealne do użycia w callbackach, metodach obiektów (choć nie jako metody obiektów najwyższego poziomu, bo wtedy <code>this</code> wskazałoby na <code>window</code>), czy w sytuacjach, gdzie chcesz, aby <code>this</code> zachowało kontekst nadrzędny.</p>
<hr>
<h2 id="szablony-stringów-template-literals---łatwiejsza-praca-z-tekstem" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#szablony-stringów-template-literals---łatwiejsza-praca-z-tekstem">>></a>Szablony stringów (Template Literals) - łatwiejsza praca z tekstem</h2>
<p>Szablony stringów, wprowadzone w ES6, to potężne narzędzie do tworzenia ciągów znaków (stringów). Zastępują tradycyjne łączenie stringów za pomocą operatora <code>+</code> i oferują znacznie większą elastyczność i czytelność. Używamy ich, otaczając tekst <strong>backtickami</strong> (apostrofami wstecznymi) <code> </code> zamiast pojedynczych lub podwójnych cudzysłowów.</p>
<h3 id="interpolacja-i-wielolinijkowość" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#interpolacja-i-wielolinijkowość">>>></a>Interpolacja i wielolinijkowość</h3>
<ul>
<li>
<p><strong>Interpolacja zmiennych i wyrażeń:</strong>
Możesz łatwo osadzać zmienne lub dowolne wyrażenia JavaScript bezpośrednio w stringu, używając składni <code>${...}</code>. To znacznie ułatwia budowanie dynamicznych komunikatów.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> imie = <span class="hljs-string">"Alicja"</span>;
<span class="hljs-keyword">const</span> wiek = <span class="hljs-number">30</span>;

<span class="hljs-comment">// Stary sposób: męczące łączenie stringów</span>
<span class="hljs-keyword">const</span> infoStare = <span class="hljs-string">"Mam na imię "</span> + imie + <span class="hljs-string">" i mam "</span> + wiek + <span class="hljs-string">" lat."</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(infoStare); <span class="hljs-comment">// Wyświetli: Mam na imię Alicja i mam 30 lat.</span>

<span class="hljs-comment">// Nowy sposób z szablonami stringów: czytelniej i prościej!</span>
<span class="hljs-keyword">const</span> infoNowe = <span class="hljs-string">`Mam na imię <span class="hljs-subst">${imie}</span> i mam <span class="hljs-subst">${wiek}</span> lat.`</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(infoNowe); <span class="hljs-comment">// Wyświetli: Mam na imię Alicja i mam 30 lat.</span>

<span class="hljs-comment">// Możesz umieszczać dowolne wyrażenia JavaScript:</span>
<span class="hljs-keyword">const</span> cena = <span class="hljs-number">10.5</span>;
<span class="hljs-keyword">const</span> ilosc = <span class="hljs-number">2</span>;
<span class="hljs-keyword">const</span> rachunek = <span class="hljs-string">`Koszt zakupu: <span class="hljs-subst">${cena * ilosc}</span> zł.`</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(rachunek); <span class="hljs-comment">// Wyświetli: Koszt zakupu: 21 zł.</span>
</code></pre>
</li>
<li>
<p><strong>Łatwe tworzenie tekstów wielolinijkowych:</strong>
Koniec z dodawaniem <code>n</code> do każdej linii! W szablonach stringów możesz po prostu nacisnąć Enter, a tekst zachowa formatowanie z nowymi liniami. Jest to szczególnie przydatne przy generowaniu fragmentów HTML bezpośrednio w JavaScript.</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// Stary sposób: brzydkie i niewygodne</span>
<span class="hljs-keyword">const</span> htmlStare =
  <span class="hljs-string">"&#x3C;div>\n  &#x3C;h1>Witaj!&#x3C;/h1>\n  &#x3C;p>To jest wielolinijkowy tekst.&#x3C;/p>\n&#x3C;/div>"</span>;

<span class="hljs-comment">// Nowy sposób: super czytelne!</span>
<span class="hljs-keyword">const</span> htmlNowe = <span class="hljs-string">`
  &#x3C;div>
    &#x3C;h1>Witaj!&#x3C;/h1>
    &#x3C;p>To jest wielolinijkowy tekst. I kolejna linia w tym samym akapicie.&#x3C;/p>
  &#x3C;/div>
`</span>;

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(htmlNowe);
</code></pre>
</li>
</ul>
<h3 id="dodatkowe-możliwości" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#dodatkowe-możliwości">>>></a>Dodatkowe możliwości</h3>
<p>Szablony stringów wspierają także tzw. <strong>tagowane szablony</strong> (<code>tagged templates</code>), które pozwalają na zaawansowaną manipulację tekstem przed jego finalnym utworzeniem. Możesz zdefiniować funkcję ("tag"), która będzie przetwarzać części stringu i wartości zmiennych. Jest to bardziej zaawansowana funkcja, używana np. do tłumaczeń, walidacji, bezpiecznego generowania HTML (zapobieganie XSS) czy formatowania danych.</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// Przykład funkcji "tagującej"</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">upper</span>(<span class="hljs-params">strings, ...values</span>) {
  <span class="hljs-comment">// 'strings' to tablica tekstów, 'values' to tablica zmiennych</span>
  <span class="hljs-keyword">let</span> wynik = strings[<span class="hljs-number">0</span>];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &#x3C; values.<span class="hljs-property">length</span>; i++) {
    wynik += values[i].<span class="hljs-title function_">toUpperCase</span>() + strings[i + <span class="hljs-number">1</span>]; <span class="hljs-comment">// Zamienia zmienne na duże litery</span>
  }
  <span class="hljs-keyword">return</span> wynik;
}

<span class="hljs-keyword">const</span> imie = <span class="hljs-string">"Kasia"</span>;
<span class="hljs-keyword">const</span> wiek = <span class="hljs-number">20</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(upper<span class="hljs-string">`Cześć, <span class="hljs-subst">${imie}</span>! Masz <span class="hljs-subst">${wiek}</span> lat?`</span>); <span class="hljs-comment">// Wyświetli: Cześć, KASIA! Masz 20 lat?</span>
</code></pre>
<p>W tym przykładzie funkcja <code>upper</code> została "przypięta" do szablonu stringu i zmodyfikowała zmienną <code>imie</code> na wielkie litery.</p>
<hr>
<h2 id="destrukturyzacja-tablic-i-obiektów---wyciągnij-to-czego-potrzebujesz" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#destrukturyzacja-tablic-i-obiektów---wyciągnij-to-czego-potrzebujesz">>></a>Destrukturyzacja tablic i obiektów - wyciągnij to, czego potrzebujesz</h2>
<p>Destrukturyzacja to potężna i bardzo często używana funkcja w nowoczesnym JavaScript. Pozwala na "rozpakowanie" wartości z tablic lub właściwości z obiektów do oddzielnych zmiennych w bardzo zwięzły i czytelny sposób. Upraszcza kod i czyni go bardziej deklaratywnym.</p>
<h3 id="destrukturyzacja-tablic" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#destrukturyzacja-tablic">>>></a>Destrukturyzacja tablic</h3>
<p>Pozwala na szybkie przypisanie wartości z tablicy do zmiennych, bazując na ich pozycji.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> kolory = [<span class="hljs-string">"czerwony"</span>, <span class="hljs-string">"zielony"</span>, <span class="hljs-string">"niebieski"</span>];

<span class="hljs-comment">// Stary sposób:</span>
<span class="hljs-comment">// const kolor1 = kolory[0];</span>
<span class="hljs-comment">// const kolor2 = kolory[1];</span>

<span class="hljs-comment">// Nowy sposób z destrukturyzacją tablic:</span>
<span class="hljs-keyword">const</span> [pierwszyKolor, drugiKolor, trzeciKolor] = kolory;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pierwszyKolor); <span class="hljs-comment">// Wyświetli: czerwony</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(drugiKolor); <span class="hljs-comment">// Wyświetli: zielony</span>

<span class="hljs-comment">// Można pomijać niektóre elementy (używając przecinków):</span>
<span class="hljs-keyword">const</span> [a, , b] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]; <span class="hljs-comment">// Pomijamy drugi element (2)</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a, b); <span class="hljs-comment">// Wyświetli: 1 3</span>

<span class="hljs-comment">// Można przypisać wartości domyślne, jeśli element nie istnieje:</span>
<span class="hljs-keyword">const</span> [x, y, z = <span class="hljs-string">"domyślny"</span>] = [<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x, y, z); <span class="hljs-comment">// Wyświetli: A B domyślny</span>

<span class="hljs-comment">// Można zbierać pozostałe elementy do nowej tablicy (rest operator - patrz dalej):</span>
<span class="hljs-keyword">const</span> [pierwszy, ...resztaKolorow] = kolory;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pierwszy); <span class="hljs-comment">// Wyświetli: czerwony</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(resztaKolorow); <span class="hljs-comment">// Wyświetli: ["zielony", "niebieski"]</span>
</code></pre>
<h3 id="destrukturyzacja-obiektów" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#destrukturyzacja-obiektów">>>></a>Destrukturyzacja obiektów</h3>
<p>Pozwala na przypisanie wartości z obiektu do zmiennych na podstawie nazw ich <strong>kluczy (właściwości)</strong>. Kolejność nie ma znaczenia, liczy się nazwa klucza.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> samochod = { <span class="hljs-attr">marka</span>: <span class="hljs-string">"Ford"</span>, <span class="hljs-attr">model</span>: <span class="hljs-string">"Focus"</span>, <span class="hljs-attr">rok</span>: <span class="hljs-number">2018</span> };

<span class="hljs-comment">// Stary sposób:</span>
<span class="hljs-comment">// const markaSamochodu = samochod.marka;</span>
<span class="hljs-comment">// const modelSamochodu = samochod.model;</span>

<span class="hljs-comment">// Nowy sposób z destrukturyzacją obiektów:</span>
<span class="hljs-keyword">const</span> { marka, model } = samochod;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(marka); <span class="hljs-comment">// Wyświetli: Ford</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(model); <span class="hljs-comment">// Wyświetli: Focus</span>

<span class="hljs-comment">// Można przypisać wartości domyślne, jeśli właściwość nie istnieje:</span>
<span class="hljs-keyword">const</span> { <span class="hljs-attr">marka</span>: m, kolor = <span class="hljs-string">"czarny"</span> } = samochod; <span class="hljs-comment">// 'kolor' nie istnieje w obiekcie 'samochod'</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(m, kolor); <span class="hljs-comment">// Wyświetli: Ford czarny</span>

<span class="hljs-comment">// Można zmienić nazwę zmiennej, do której przypisujemy wartość:</span>
<span class="hljs-keyword">const</span> { <span class="hljs-attr">marka</span>: nazwaMarki, <span class="hljs-attr">model</span>: typModelu } = samochod;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(nazwaMarki, typModelu); <span class="hljs-comment">// Wyświetli: Ford Focus</span>

<span class="hljs-comment">// Można też zbierać pozostałe właściwości do nowego obiektu (rest operator - patrz dalej):</span>
<span class="hljs-keyword">const</span> { rok, ...resztaSamochodu } = samochod;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(rok); <span class="hljs-comment">// Wyświetli: 2018</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(resztaSamochodu); <span class="hljs-comment">// Wyświetli: { marka: "Ford", model: "Focus" }</span>
</code></pre>
<p>Destrukturyzacja jest szczególnie przydatna w funkcjach, gdy chcesz łatwo wyciągnąć konkretne dane z obiektów konfiguracyjnych lub z wyników API.</p>
<hr>
<h2 id="spread-i-rest-operator----elastyczność-w-manipulacji-danymi" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#spread-i-rest-operator----elastyczność-w-manipulacji-danymi">>></a>Spread i Rest Operator (<code>...</code>) - elastyczność w manipulacji danymi</h2>
<p>Operator <code>...</code> (trzy kropki) jest jednym z najbardziej uniwersalnych i potężnych narzędzi w nowoczesnym JavaScript. Nazywany jest <strong>operatorem spread</strong> lub <strong>operatorem rest</strong>, w zależności od kontekstu, w jakim jest używany.</p>
<h3 id="spread-operator-operator-rozproszenia" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#spread-operator-operator-rozproszenia">>>></a>Spread Operator (operator rozproszenia)</h3>
<p>Gdy używasz <code>...</code> do <strong>rozbicia</strong> elementów tablicy lub właściwości obiektu na pojedyncze elementy, mówimy o <strong>operatorze spread</strong>. Jest to jak "rozłożenie" zawartości kolekcji. 🌐</p>
<p><strong>Zastosowania Spread Operatora:</strong></p>
<ul>
<li>
<p><strong>Kopiowanie i łączenie tablic:</strong> Tworzenie płytkich kopii tablic lub łączenie ich bez modyfikowania oryginalnych.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> cyfry = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-keyword">const</span> noweCyfry = [...cyfry, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]; <span class="hljs-comment">// Rozwija [1, 2, 3] do 1, 2, 3, a potem dodaje 4, 5</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(noweCyfry); <span class="hljs-comment">// Wyświetli: [1, 2, 3, 4, 5]</span>

<span class="hljs-keyword">const</span> tablica1 = [<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>];
<span class="hljs-keyword">const</span> tablica2 = [<span class="hljs-string">"c"</span>, <span class="hljs-string">"d"</span>];
<span class="hljs-keyword">const</span> polaczoneTablice = [...tablica1, ...tablica2];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(polaczoneTablice); <span class="hljs-comment">// Wyświetli: ["a", "b", "c", "d"]</span>
</code></pre>
</li>
<li>
<p><strong>Kopiowanie i łączenie obiektów:</strong> Podobnie jak z tablicami, możesz tworzyć kopie obiektów i łączyć ich właściwości.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> osoba = { <span class="hljs-attr">imie</span>: <span class="hljs-string">"Anna"</span>, <span class="hljs-attr">wiek</span>: <span class="hljs-number">28</span> };
<span class="hljs-keyword">const</span> osobaZZawodem = { ...osoba, <span class="hljs-attr">zawod</span>: <span class="hljs-string">"Programista"</span> };
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(osobaZZawodem); <span class="hljs-comment">// Wyświetli: { imie: "Anna", wiek: 28, zawod: "Programista" }</span>

<span class="hljs-keyword">const</span> daneKontaktowe = { <span class="hljs-attr">email</span>: <span class="hljs-string">"a@example.com"</span>, <span class="hljs-attr">telefon</span>: <span class="hljs-string">"123-456-789"</span> };
<span class="hljs-keyword">const</span> pelneDane = { ...osoba, ...daneKontaktowe };
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pelneDane); <span class="hljs-comment">// Wyświetli: { imie: "Anna", wiek: 28, email: "a@example.com", telefon: "123-456-789" }</span>
</code></pre>
<p>Jeśli klucze się powtarzają, ostatnia wartość nadpisuje poprzednią.</p>
</li>
<li>
<p><strong>Przekazywanie argumentów funkcji:</strong> Możesz rozwijać tablicę jako argumenty funkcji.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sumuj</span>(<span class="hljs-params">a, b, c</span>) {
  <span class="hljs-keyword">return</span> a + b + c;
}
<span class="hljs-keyword">const</span> liczby = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sumuj</span>(...liczby)); <span class="hljs-comment">// Rozwija [10, 20, 30] do sumuj(10, 20, 30), wyświetli: 60</span>
</code></pre>
</li>
</ul>
<h3 id="rest-operator-operator-reszty" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#rest-operator-operator-reszty">>>></a>Rest Operator (operator reszty)</h3>
<p>Gdy używasz <code>...</code> do <strong>zbierania</strong> wielu elementów w jedną tablicę (lub właściwości w obiekt), mówimy o <strong>operatorze rest</strong>. Jest to jak "zbieranie" luźnych elementów w jedną kolekcję. 🧺</p>
<p><strong>Zastosowania Rest Operatora:</strong></p>
<ul>
<li>
<p><strong>Zbieranie argumentów funkcji:</strong> Pozwala funkcji przyjmować nieokreśloną liczbę argumentów i traktować je jako tablicę.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">suma</span>(<span class="hljs-params">...liczby</span>) {
  <span class="hljs-comment">// 'liczby' zbiera wszystkie przekazane argumenty w tablicę</span>
  <span class="hljs-keyword">return</span> liczby.<span class="hljs-title function_">reduce</span>(
    <span class="hljs-function">(<span class="hljs-params">akumulator, aktualnaLiczba</span>) =></span> akumulator + aktualnaLiczba,
    <span class="hljs-number">0</span>
  );
}
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">suma</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">// Wyświetli: 6</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">suma</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>)); <span class="hljs-comment">// Wyświetli: 100</span>
</code></pre>
</li>
<li>
<p><strong>W destrukturyzacji (jak widzieliśmy wcześniej):</strong> Zbieranie pozostałych elementów do nowej tablicy lub obiektu.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> [pierwszy, drugi, ...resztaTablicy] = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pierwszy); <span class="hljs-comment">// Wyświetli: 10</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(drugi); <span class="hljs-comment">// Wyświetli: 20</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(resztaTablicy); <span class="hljs-comment">// Wyświetli: [30, 40, 50]</span>

<span class="hljs-keyword">const</span> { imie, ...resztaOsoby } = {
  <span class="hljs-attr">imie</span>: <span class="hljs-string">"Ola"</span>,
  <span class="hljs-attr">wiek</span>: <span class="hljs-number">25</span>,
  <span class="hljs-attr">miasto</span>: <span class="hljs-string">"Warszawa"</span>,
};
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(imie); <span class="hljs-comment">// Wyświetli: Ola</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(resztaOsoby); <span class="hljs-comment">// Wyświetli: { wiek: 25, miasto: "Warszawa" }</span>
</code></pre>
</li>
</ul>
<p>Zarówno spread, jak i rest operator są niezwykle przydatne i sprawiają, że kod jest znacznie bardziej zwięzły i czytelny, szczególnie podczas pracy z tablicami i obiektami.</p>
<hr>
<h2 id="promise-api-i-obsługa-asynchroniczności---opowiadaj-historie-o-przyszłości" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#promise-api-i-obsługa-asynchroniczności---opowiadaj-historie-o-przyszłości">>></a>Promise API i obsługa asynchroniczności - opowiadaj historie o przyszłości</h2>
<p>JavaScript jest językiem <strong>jednowątkowym</strong>, co oznacza, że może wykonywać tylko jedną operację w danym momencie. Jednak wiele operacji, takich jak pobieranie danych z internetu, odczyt plików, czy operacje na bazie danych, trwa pewien czas. Gdyby JavaScript musiał czekać na ich zakończenie, strona internetowa by się "zawiesiła" (nie reagowałaby na kliknięcia, przewijanie itp.).</p>
<p>Tutaj wkracza <strong>asynchroniczność</strong>. Pozwala ona na rozpoczęcie operacji, a następnie przejście do kolejnych zadań, nie czekając na zakończenie tej pierwszej. Kiedy asynchroniczna operacja się zakończy, JavaScript wróci do niej i wykona dalsze kroki.</p>
<p>Starszym sposobem obsługi asynchroniczności były <strong>callbacki</strong> (funkcje zwrotne), które jednak często prowadziły do tzw. "callback hell" (piekła callbacków) - zagnieżdżonego, trudnego do czytania i utrzymania kodu.</p>
<h3 id="czym-jest-promise" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#czym-jest-promise">>>></a>Czym jest Promise?</h3>
<p><strong>Promise (Obietnica)</strong> to obiekt w JavaScript, który reprezentuje ostateczne zakończenie (lub niepowodzenie) operacji asynchronicznej. Możesz myśleć o Promise jako o "przyszłej wartości". Składasz obietnicę, że w przyszłości otrzymasz wynik - albo sukces, albo błąd. 📦</p>
<p>Promise może znajdować się w jednym z trzech stanów:</p>
<ol>
<li><strong><code>pending</code> (oczekujący)</strong>: Początkowy stan; ani spełniony, ani odrzucony. Operacja asynchroniczna nadal trwa.</li>
<li><strong><code>fulfilled</code> (spełniony)</strong>: Operacja asynchroniczna zakończyła się sukcesem i zwróciła wartość.</li>
<li><strong><code>rejected</code> (odrzucony)</strong>: Operacja asynchroniczna zakończyła się błędem.</li>
</ol>
<p>Możesz "podpiąć" funkcje, które zostaną wywołane, gdy Promise zmieni swój stan:</p>
<ul>
<li><strong><code>.then()</code></strong>: Wywoływany, gdy Promise zostanie <code>fulfilled</code> (operacja zakończy się sukcesem). Otrzymuje wartość zwróconą przez Promise.</li>
<li><strong><code>.catch()</code></strong>: Wywoływany, gdy Promise zostanie <code>rejected</code> (wystąpi błąd). Otrzymuje obiekt błędu.</li>
<li><strong><code>.finally()</code></strong>: Wywoływany zawsze, niezależnie od tego, czy Promise zakończył się sukcesem, czy błędem. Idealny do czyszczenia zasobów.</li>
</ul>
<p><strong>Przykład tworzenia i używania Promise:</strong></p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> obietnica = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> {
  <span class="hljs-comment">// Symulujemy operację asynchroniczną (np. pobieranie danych)</span>
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-keyword">const</span> sukces = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() > <span class="hljs-number">0.5</span>; <span class="hljs-comment">// Losowo decydujemy o sukcesie lub błędzie</span>

    <span class="hljs-keyword">if</span> (sukces) {
      <span class="hljs-title function_">resolve</span>(<span class="hljs-string">"Dane pobrane pomyślnie!"</span>); <span class="hljs-comment">// Jeśli sukces, wywołujemy resolve z wynikiem</span>
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"Nie udało się pobrać danych."</span>)); <span class="hljs-comment">// Jeśli błąd, wywołujemy reject z błędem</span>
    }
  }, <span class="hljs-number">2000</span>); <span class="hljs-comment">// Operacja trwa 2 sekundy</span>
});

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Rozpoczęto operację..."</span>);

obietnica
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">wiadomosc</span>) =></span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"SUKCES:"</span>, wiadomosc); <span class="hljs-comment">// Wykona się, jeśli obietnica się spełni</span>
  })
  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">blad</span>) =></span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"BŁĄD:"</span>, blad.<span class="hljs-property">message</span>); <span class="hljs-comment">// Wykona się, jeśli obietnica zostanie odrzucona</span>
  })
  .<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Operacja zakończona (niezależnie od wyniku)."</span>); <span class="hljs-comment">// Wykona się zawsze</span>
  });

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Kod po obietnicy nadal się wykonuje..."</span>); <span class="hljs-comment">// Pokazuje asynchroniczność</span>
</code></pre>
<h3 id="łańcuchy-promise-promise-chaining" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#łańcuchy-promise-promise-chaining">>>></a>Łańcuchy Promise (<code>Promise Chaining</code>)</h3>
<p>Jedną z największych zalet Promise jest możliwość łączenia wielu operacji asynchronicznych w jeden czytelny "łańcuch". Każdy <code>.then()</code> zwraca nowy Promise, co pozwala na kolejne <code>.then()</code> wywołane po sobie. Jest to idealne, gdy jedna operacja asynchroniczna zależy od wyniku poprzedniej.</p>
<p><strong>Przykład łańcucha Promise (pobieranie danych z API):</strong></p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// fetch() to wbudowana funkcja JS, która zwraca Promise</span>
<span class="hljs-title function_">fetch</span>(<span class="hljs-string">"https://jsonplaceholder.typicode.com/users/1"</span>) <span class="hljs-comment">// Pobierz dane użytkownika o ID 1</span>
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">response</span>) =></span> {
    <span class="hljs-comment">// Pierwsze .then: sprawdź, czy odpowiedź jest OK i sparsuj ją jako JSON</span>
    <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`Błąd HTTP! Status: <span class="hljs-subst">${response.status}</span>`</span>);
    }
    <span class="hljs-keyword">return</span> response.<span class="hljs-title function_">json</span>(); <span class="hljs-comment">// Zwróć kolejny Promise z danymi JSON</span>
  })
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">user</span>) =></span> {
    <span class="hljs-comment">// Drugie .then: otrzymaj sparsowane dane użytkownika</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Pobrany użytkownik:"</span>, user.<span class="hljs-property">name</span>, user.<span class="hljs-property">email</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">fetch</span>(
      <span class="hljs-string">`https://jsonplaceholder.typicode.com/posts?userId=<span class="hljs-subst">${user.id}</span>`</span>
    ); <span class="hljs-comment">// Pobierz posty tego użytkownika</span>
  })
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">response</span>) =></span> {
    <span class="hljs-comment">// Trzecie .then: sprawdź odpowiedź i sparsuj posty</span>
    <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`Błąd HTTP! Status: <span class="hljs-subst">${response.status}</span>`</span>);
    }
    <span class="hljs-keyword">return</span> response.<span class="hljs-title function_">json</span>();
  })
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">posts</span>) =></span> {
    <span class="hljs-comment">// Czwarte .then: otrzymaj posty</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Liczba postów użytkownika:"</span>, posts.<span class="hljs-property">length</span>);
  })
  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =></span> {
    <span class="hljs-comment">// .catch: Obsłuż każdy błąd, który wystąpił na dowolnym etapie łańcucha</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"Wystąpił błąd w łańcuchu Promise:"</span>, error);
  })
  .<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Pobieranie danych zakończone."</span>);
  });
</code></pre>
<p>Promise to podstawa nowoczesnego JS w obsłudze asynchroniczności, a kolejny rozdział pokaże Ci, jak jeszcze bardziej uprościć ich użycie.</p>
<hr>
<h2 id="asyncawait---nowoczesna-obsługa-kodu-asynchronicznego---pisz-asynchronicznie-myśl-synchronicznie" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#asyncawait---nowoczesna-obsługa-kodu-asynchronicznego---pisz-asynchronicznie-myśl-synchronicznie">>></a>Async/await - nowoczesna obsługa kodu asynchronicznego - pisz asynchronicznie, myśl synchronicznie</h2>
<p>Mimo że Promise są ogromnym krokiem naprzód w porównaniu do callbacków, kod z długimi łańcuchami <code>.then().then().catch()</code> może wciąż być trudny do czytania. Standard ES2017 wprowadził słowa kluczowe <strong><code>async</code></strong> i <strong><code>await</code></strong>, które pozwalają pisać kod asynchroniczny w sposób, który wygląda i zachowuje się niemal identycznie jak kod synchroniczny, jednocześnie zachowując asynchroniczną naturę. To game changer! 🎮</p>
<h3 id="uproszczenie-pracy-z-promise" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#uproszczenie-pracy-z-promise">>>></a>Uproszczenie pracy z Promise</h3>
<ul>
<li><strong><code>async</code></strong>: Musisz oznaczyć funkcję słowem kluczowym <code>async</code>, aby móc używać w niej <code>await</code>. Funkcja <code>async</code> <strong>zawsze zwraca Promise</strong>, nawet jeśli zwrócisz w niej zwykłą wartość - JavaScript automatycznie opakuje ją w Promise.</li>
<li><strong><code>await</code></strong>: Słowo kluczowe <code>await</code> może być użyte <strong>tylko wewnątrz funkcji <code>async</code></strong>. Powoduje ono, że wykonanie funkcji <code>async</code> zostaje <strong>wstrzymane</strong>, dopóki Promise, na który czeka <code>await</code>, nie zostanie <strong>spełniony (fulfilled)</strong>. Kiedy Promise się spełni, <code>await</code> "rozpakowuje" jego wartość i przypisuje ją do zmiennej. Jeśli Promise zostanie odrzucony (rejected), <code>await</code> "wyrzuci" błąd, który możesz obsłużyć za pomocą <code>try...catch</code>.</li>
</ul>
<p><strong>Przykład użycia <code>async/await</code> (porównaj z przykładem z Promise Chaining):</strong></p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">pobierzDaneUzytkownikaIPosty</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Rozpoczynam pobieranie danych..."</span>);

    <span class="hljs-comment">// Krok 1: Pobierz dane użytkownika</span>
    <span class="hljs-keyword">const</span> userResponse = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(
      <span class="hljs-string">"https://jsonplaceholder.typicode.com/users/1"</span>
    );
    <span class="hljs-keyword">if</span> (!userResponse.<span class="hljs-property">ok</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(
        <span class="hljs-string">`Błąd HTTP przy pobieraniu użytkownika! Status: <span class="hljs-subst">${userResponse.status}</span>`</span>
      );
    }
    <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> userResponse.<span class="hljs-title function_">json</span>(); <span class="hljs-comment">// Poczekaj na parsowanie JSON</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Pobrany użytkownik:"</span>, user.<span class="hljs-property">name</span>, user.<span class="hljs-property">email</span>);

    <span class="hljs-comment">// Krok 2: Pobierz posty tego użytkownika</span>
    <span class="hljs-keyword">const</span> postsResponse = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(
      <span class="hljs-string">`https://jsonplaceholder.typicode.com/posts?userId=<span class="hljs-subst">${user.id}</span>`</span>
    );
    <span class="hljs-keyword">if</span> (!postsResponse.<span class="hljs-property">ok</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(
        <span class="hljs-string">`Błąd HTTP przy pobieraniu postów! Status: <span class="hljs-subst">${postsResponse.status}</span>`</span>
      );
    }
    <span class="hljs-keyword">const</span> posts = <span class="hljs-keyword">await</span> postsResponse.<span class="hljs-title function_">json</span>(); <span class="hljs-comment">// Poczekaj na parsowanie JSON</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Liczba postów użytkownika:"</span>, posts.<span class="hljs-property">length</span>);

    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Wszystkie dane zostały pobrane pomyślnie."</span>);
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-comment">// Obsługa każdego błędu, który wystąpił na dowolnym etapie</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"Wystąpił błąd w funkcji async:"</span>, error.<span class="hljs-property">message</span>);
  } <span class="hljs-keyword">finally</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Operacja pobierania danych zakończona."</span>);
  }
}

<span class="hljs-comment">// Wywołanie funkcji async</span>
<span class="hljs-title function_">pobierzDaneUzytkownikaIPosty</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Kod poza funkcją async nadal się wykonuje..."</span>); <span class="hljs-comment">// Pokazuje asynchroniczność</span>
</code></pre>
<p>Widzisz, jak kod stał się znacznie bardziej liniowy i czytelny? Wygląda to prawie jak tradycyjny kod synchroniczny, mimo że w tle nadal działają Promise i cała magia asynchroniczności.</p>
<h3 id="zwracanie-wartości-i-obsługa-błędów" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#zwracanie-wartości-i-obsługa-błędów">>>></a>Zwracanie wartości i obsługa błędów</h3>
<ul>
<li>
<p><strong>Zwracanie wartości z funkcji <code>async</code></strong>:
Jeśli funkcja <code>async</code> zwraca jakąś wartość, ta wartość jest automatycznie opakowywana w Promise, który zostanie spełniony z tą wartością.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">zwrocLiczbe</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// Możesz też użyć await, np. await Promise.resolve(42);</span>
  <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;
}
<span class="hljs-title function_">zwrocLiczbe</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">val</span>) =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(val)); <span class="hljs-comment">// Wyświetli: 42</span>
</code></pre>
</li>
<li>
<p><strong>Obsługa błędów z <code>try...catch</code></strong>:
Największą zaletą <code>async/await</code> jest to, że pozwala na używanie standardowych bloków <code>try...catch</code> do obsługi błędów w kodzie asynchronicznym. Jeśli Promise, na który czeka <code>await</code>, zostanie odrzucony (rejected), <code>await</code> "rzuci" błąd, który zostanie przechwycony przez blok <code>catch</code>.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">symulujBlad</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> {
      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"Coś poszło nie tak!"</span>)), <span class="hljs-number">1000</span>);
    });
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result); <span class="hljs-comment">// To się nie wykona</span>
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"Złapano błąd:"</span>, error.<span class="hljs-property">message</span>); <span class="hljs-comment">// Wyświetli: Złapano błąd: Coś poszło nie tak!</span>
  }
}
<span class="hljs-title function_">symulujBlad</span>();
</code></pre>
</li>
</ul>
<p><code>async/await</code> to obecnie <strong>najczęściej rekomendowany</strong> sposób pracy z asynchronicznością w JavaScript, ponieważ znacząco poprawia czytelność i łatwość utrzymania kodu, sprawiając, że złożone operacje asynchroniczne stają się bardziej przejrzyste.</p>
<hr>
<h2 id="zadania-do-wykonania-sprawdź-swoją-wiedzę" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#zadania-do-wykonania-sprawdź-swoją-wiedzę">>></a>Zadania do wykonania: Sprawdź swoją wiedzę!</h2>
<p>Czas na praktykę! Rozwiąż te zadania, aby utrwalić to, czego się nauczyłeś/aś. Po każdym zadaniu możesz rozwinąć sekcję <code>Pokaż rozwiązanie</code>, aby sprawdzić swój kod. Powodzenia! 💪</p>
<h3 id="zadanie-1" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#zadanie-1">>>></a>Zadanie 1</h3>
<p>Napisz <strong>funkcję strzałkową</strong>, która przyjmuje dowolną liczbę argumentów numerycznych i zwraca ich sumę. Użyj <strong>rest operatora</strong> do zebrania argumentów.</p>
<details>
<summary>
<span>Pokaż rozwiązanie</span>
</summary>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">sumaWszystkichLiczb</span> = (<span class="hljs-params">...liczby</span>) => {
  <span class="hljs-keyword">return</span> liczby.<span class="hljs-title function_">reduce</span>(
    <span class="hljs-function">(<span class="hljs-params">akumulator, aktualnaLiczba</span>) =></span> akumulator + aktualnaLiczba,
    <span class="hljs-number">0</span>
  );
};

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sumaWszystkichLiczb</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">// Oczekiwany wynik: 6</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sumaWszystkichLiczb</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>)); <span class="hljs-comment">// Oczekiwany wynik: 100</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sumaWszystkichLiczb</span>()); <span class="hljs-comment">// Oczekiwany wynik: 0</span>
</code></pre>
</details>
<hr>
<h3 id="zadanie-2" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#zadanie-2">>>></a>Zadanie 2</h3>
<p>Utwórz obiekt reprezentujący produkt z kluczami: <code>nazwa</code>, <code>cena</code>, <code>dostepny</code>. Następnie użyj <strong>destrukturyzacji obiektu</strong>, aby wyodrębnić te wartości do osobnych zmiennych i wyświetlić je w konsoli. Dodaj również zmienną <code>producent</code> z wartością domyślną "Nieznany", na wypadek gdyby nie było jej w obiekcie.</p>
<details>
<summary>
<span>Pokaż rozwiązanie</span>
</summary>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> produkt = { <span class="hljs-attr">nazwa</span>: <span class="hljs-string">"Książka JS"</span>, <span class="hljs-attr">cena</span>: <span class="hljs-number">49.99</span>, <span class="hljs-attr">dostepny</span>: <span class="hljs-literal">true</span> };

<span class="hljs-keyword">const</span> { nazwa, cena, dostepny, producent = <span class="hljs-string">"Nieznany"</span> } = produkt;

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Nazwa: <span class="hljs-subst">${nazwa}</span>`</span>); <span class="hljs-comment">// Oczekiwany wynik: Nazwa: Książka JS</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Cena: <span class="hljs-subst">${cena}</span> zł`</span>); <span class="hljs-comment">// Oczekiwany wynik: Cena: 49.99 zł</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Dostępny: <span class="hljs-subst">${dostepny}</span>`</span>); <span class="hljs-comment">// Oczekiwany wynik: Dostępny: true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Producent: <span class="hljs-subst">${producent}</span>`</span>); <span class="hljs-comment">// Oczekiwany wynik: Producent: Nieznany</span>
</code></pre>
</details>
<hr>
<h3 id="zadanie-3" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#zadanie-3">>>></a>Zadanie 3</h3>
<p>Stwórz tablicę ulubionych filmów. Następnie użyj <strong>operatora spread</strong> do utworzenia nowej tablicy, która będzie zawierać wszystkie te filmy plus dwa dodatkowe filmy na końcu. Wyświetl nową tablicę w konsoli.</p>
<details>
<summary>
<span>Pokaż rozwiązanie</span>
</summary>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> ulubioneFilmy = [<span class="hljs-string">"Incepcja"</span>, <span class="hljs-string">"Matrix"</span>, <span class="hljs-string">"Interstellar"</span>];

<span class="hljs-keyword">const</span> nowaListaFilmow = [...ulubioneFilmy, <span class="hljs-string">"Pulp Fiction"</span>, <span class="hljs-string">"Forrest Gump"</span>];

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(nowaListaFilmow);
<span class="hljs-comment">// Oczekiwany wynik: ["Incepcja", "Matrix", "Interstellar", "Pulp Fiction", "Forrest Gump"]</span>
</code></pre>
</details>
<hr>
<h3 id="zadanie-4" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#zadanie-4">>>></a>Zadanie 4</h3>
<p>Napisz <strong>funkcję asynchroniczną</strong> o nazwie <code>pobierzWiadomosc</code>, która symuluje pobieranie wiadomości z serwera. Funkcja powinna używać <code>setTimeout</code>, aby po 3 sekundach zwrócić tekst "Wiadomość pobrana!". Użyj <code>async/await</code> do wywołania tej funkcji i wyświetlenia jej wyniku w konsoli. Dodaj również blok <code>try...catch</code> do obsługi potencjalnych błędów.</p>
<details>
<summary>
<span>Pokaż rozwiązanie</span>
</summary>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// Funkcja symulująca pobieranie danych (zwraca Promise)</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">pobierzWiadomoscAPI</span> = (<span class="hljs-params"></span>) => {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> {
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> {
      <span class="hljs-comment">// Możesz zmienić to na reject, aby przetestować obsługę błędów</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() > <span class="hljs-number">0.1</span>) {
        <span class="hljs-comment">// 90% szans na sukces, 10% na błąd</span>
        <span class="hljs-title function_">resolve</span>(<span class="hljs-string">"Wiadomość pobrana pomyślnie!"</span>);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"Błąd podczas pobierania wiadomości!"</span>));
      }
    }, <span class="hljs-number">3000</span>); <span class="hljs-comment">// Symulujemy 3 sekundy oczekiwania</span>
  });
};

<span class="hljs-comment">// Funkcja asynchroniczna używająca async/await</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">pobierzWiadomosc</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Rozpoczynam pobieranie wiadomości..."</span>);
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> wiadomosc = <span class="hljs-keyword">await</span> <span class="hljs-title function_">pobierzWiadomoscAPI</span>(); <span class="hljs-comment">// Czekaj, aż Promise się spełni</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Sukces:"</span>, wiadomosc);
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"Wystąpił błąd:"</span>, error.<span class="hljs-property">message</span>); <span class="hljs-comment">// Złap i wyświetl błąd</span>
  } <span class="hljs-keyword">finally</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Zakończono próbę pobierania wiadomości."</span>);
  }
}

<span class="hljs-comment">// Wywołaj funkcję asynchroniczną</span>
<span class="hljs-title function_">pobierzWiadomosc</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(
  <span class="hljs-string">"Ten tekst wyświetli się natychmiast po uruchomieniu programu, zanim wiadomość zostanie pobrana."</span>
);
</code></pre>
</details>
<hr>
<p>Gratulacje! 🎉 Dotarłeś/aś do końca kursu wprowadzającego w nowoczesny JavaScript. Masz teraz solidne podstawy do dalszego rozwoju. Pamiętaj, że kluczem jest praktyka - im więcej będziesz kodować, tym lepiej zrozumiesz te koncepcje.</p>
<p>Co chciałbyś/chciałabyś zgłębić dalej? Może:</p>
<ul>
<li><strong>Moduły ES6</strong> (import/export)?</li>
<li><strong>Klasy</strong> w JavaScript (obiektowość)?</li>
<li><strong>Metody tablicowe</strong> (map, filter, reduce)?</li>
<li>Głębsze nurkowanie w <strong>asynchroniczność</strong> i Web API?</li>
</ul>
<p>Daj znać! 😊</p></article><div class="container prose"><h2>Quiz: Podstawy nowoczesnego JavaScript</h2><div><p class="font-bold mb-0!">Pytanie <!-- -->1<!-- --> z <!-- -->5</p><div class="prose-p:mt-2"><p>Jaką główną różnicę między <code>let</code> a <code>var</code> podkreśla się w nowoczesnym JavaScript?</p></div><div class="grid grid-flow-row gap-3"><button data-slot="button" class="button button--variant-outline button--size-sm w-full text-left inline-flex justify-start transition-none text-wrap! min-h-min! py-1.5 cursor-pointer">Obie są identyczne</button><button data-slot="button" class="button button--variant-outline button--size-sm w-full text-left inline-flex justify-start transition-none text-wrap! min-h-min! py-1.5 cursor-pointer">Zakres blokowy (`block scope`) w `let`</button><button data-slot="button" class="button button--variant-outline button--size-sm w-full text-left inline-flex justify-start transition-none text-wrap! min-h-min! py-1.5 cursor-pointer">`var` nie istnieje w nowoczesnym JS</button><button data-slot="button" class="button button--variant-outline button--size-sm w-full text-left inline-flex justify-start transition-none text-wrap! min-h-min! py-1.5 cursor-pointer">`let` nie pozwala na przyjmowanie wartości domyślnej</button></div></div></div><div class="container"><p class="button button--variant-secondary button--size-lg w-full p-10 text-wrap flex-wrap h-auto text-center gap-y-4 text-wrap!" data-slot="button">Widzisz jakiś błąd, bądź literówkę? Chcesz coś poprawić?<a href="https://github.com/jakubszpil/jakubszpil.github.io/edit/main/app/content/courses/nowoczesny-javascript.md" target="_blank" rel="noreferrer" data-slot="button" class="button button--variant-link button--size-default">✏️ Przejdź do edycji tego pliku</a></p></div></main><footer class="prose max-w-full border-t"><div class="container flex items-center gap-3 justify-start flex-wrap-reverse lg:justify-between"><p class="xl:text-sm">© <!-- -->2025<a data-slot="button" class="button button--variant-link button--size-sm" href="/" data-discover="true">jakubszpil</a></p><nav class="flex items-center flex-wrap -ml-3"><a data-slot="button" class="button button--variant-link button--size-sm" href="/" data-discover="true">🏠 Strona główna</a><a data-slot="button" class="button button--variant-link button--size-sm" href="/blog" data-discover="true">📝 Blog</a><a data-slot="button" class="button button--variant-link button--size-sm" href="/learning" data-discover="true">🏫 Learning</a><a data-slot="button" class="button button--variant-link button--size-sm" href="/portfolio" data-discover="true">🛠️ Portfolio</a><a data-slot="button" class="button button--variant-link button--size-sm" href="/me" data-discover="true">🙋‍♂️ O mnie</a><a data-slot="button" class="button button--variant-link button--size-sm" href="/search" data-discover="true">🔍 Szukaj</a><a data-slot="button" class="button button--variant-link button--size-sm" href="/handbook" data-discover="true">📋 Handbook</a></nav></div></footer><script>((storageKey2, restoreKey) => {
    if (!window.history.state || !window.history.state.key) {
      let key = Math.random().toString(32).slice(2);
      window.history.replaceState({ key }, "");
    }
    try {
      let positions = JSON.parse(sessionStorage.getItem(storageKey2) || "{}");
      let storedY = positions[restoreKey || window.history.state.key];
      if (typeof storedY === "number") {
        window.scrollTo(0, storedY);
      }
    } catch (error) {
      console.error(error);
      sessionStorage.removeItem(storageKey2);
    }
  })("react-router-scroll-positions", "/learning/nowoczesny-javascript/.default")</script><script>window.__reactRouterContext = {"basename":"/","future":{"v8_middleware":false,"unstable_optimizeDeps":true,"unstable_splitRouteModules":true,"unstable_subResourceIntegrity":false,"unstable_viteEnvironmentApi":true},"routeDiscovery":{"mode":"initial"},"ssr":false,"isSpaMode":false};window.__reactRouterContext.stream = new ReadableStream({start(controller){window.__reactRouterContext.streamController = controller;}}).pipeThrough(new TextEncoderStream());</script><script type="module" async="">import "/assets/manifest-f351e186.js";
import * as route0 from "/assets/root-BycHyJkk.js";
import * as route1 from "/assets/layout-DTSVQAyN.js";
import * as route2 from "/assets/course-details-B5tvZ0eW.js";
  
  window.__reactRouterRouteModules = {"root":route0,"routes/layout":route1,"course-details":route2};

import("/assets/entry.client-D07Jc1yP.js");</script><!--$?--><template id="B:0"></template><!--/$--><script id="_R_">requestAnimationFrame(function(){$RT=performance.now()});</script><div hidden id="S:0"><script>window.__reactRouterContext.streamController.enqueue("[{\"_1\":2,\"_5\":-5,\"_6\":-5},\"loaderData\",{\"_3\":4},\"course-details\",\"㞂‮०͠꘠⸐ॖε膜ࡦ찀職簂這䀚簆》쁏栧촁溬ힴ盆媀✈\\u001c삀ꈀখ儓⊳䢄ँ䌖俀ોᠽ脱\\u0018ڰ謀ⶾ焣堇ㄝ鋻少녕㘀㏈\\udefbㄍ엙ㅩ憨,퀭失屹姰쀸䓃ꎱ鏨톜⃨礣⃐셠鲽訣拀䨪ꨰ쇙é푨℁䄁己냁ꉋꁦ串蓄畩捠㦠읝©७嵥榱疇ꡙ\\ud961쳆텍꧵䩭奭넉\\udd2f긡ˑ堟컩月䓜둋㴏꠳ϑ겦ㆈ錃ᕢ妼㽨䬂숀紀膺傝혇̄啸氎ᜓƇ늤㓋洘ࣦ遇ꉤ\\u001b㯚鉉䂦堭喂▒愐mီ鍉腧ઑ⣡燎잋㮠Ⳃ\\udb18䎋⚊駕뀀ᆰ뻬풩ꅤ슸㘄䴓䏘䀀崙㔆欀斈낲異륑襠\\uded9\\u0010䩄老　ᥣ\\u0016-㱧銘̳였⫱Ἰ後ᚰꀈ苑Ⴀ䠌Ḅ耂⫗栈簀ŕ蔮騐ꧬ丘亓桖䩪\\ud8c0섁半ဲ퀍湲ꍐy쐀㸍⦘澇돭ㅨψ鯈䰩᧰阈ᆌ\\udf50ﮰ淜ఁ렃팿ﰎ䧱綷䄄䋼罗쏥酌ᄖЁ딀ᙘ軲⁮ᩔ燡갦䭅壀\\u001f诱\\udd85侙䏀̀Ṍ톉〃숇鄩⊞Ƒ쭬ᨊ쇰㍚ա䰮鼀(\\u0003瘳蔱执\\udc45胸耒餋㸸叢䂾▁蠁如썹衪䑶爞䶓钻頥ꃱп↱㉺ᝁ烱⁈葵㩘㪆恒桞ࣁ瑷䙅섰䈊ꑀFᤖ\\u0000㷄֟☢퐙㘃ᛁ搜鳡戈䄫谜ꡠ陃ꆰȞ양砅㇒匬ᒹ覂ࡇ駦ꂬ鸈倁簨ᗖ琉ं\\uddb7\\u0018唡㏏朣鞂㰳\\u001d㐋熃띀㹁ꀖ䰓\\u0001硦适⚁襼ȯᦰ笖Ōᕁॖ쎶ꖳܑ灕뼬󽦸配䕱剖뮟㰃滜࿴瑄簃激攍\\udfe9榨㖩Գ䃆䬌튩꺀꯴螷⨂ᮺꆘ歫蝞ꑥᭆ䁭혴웱ׇ燬♞葤鵆䑫댲ꘁ띀ۣ髩ﱱ鹻걐쥤⾡痺놰揇삨㍍턇１у졡馑搏燘뮐軘\\u0007풖ข淇ꀖ뗘禙䲛㠁ꡢ㳟☸ﬆ\\udedc碹泐鏕뀨࿃ᛂ㉀㥀⿁捡嘷섳慉阅道㵎䌟⿉ᄐ䳘⬊⊙莫倀ᄑ౧놘㉊읁ఀ蠧䐠Ձꠘᡌ磹蓌骖ꐅ巚꧜﫼ເꌦㄩ쓩臛ꘊ䭸瞰銦舦䈢掀욽腌֞뭸ꄋഅ㴚氟昙蔜쌠恐\\ude1b뎱潌Ɖ䂬Ӊ眜賜⤼⍈\\ud81d訔帋냍ᄇ\\ud8d8ৈ䀎ಃ★ᒾ怌挊䀈⠅焿迴쀃鏐⼢뾐䂱鲻蕜՝ꞈ̠똜ョ侅偦ҥ裻ౣʑ৸\\udddd쇽⸮⇧⶗烸ఆ띌䤃ꁝ债挞ڰకᣵ橫鎨聮ꏔᠵ蜼鞑୞᪢⍄죏패쾀䲽԰﬘Ꮋ媫ꆘ๒₴ể䁻액榸ᛜ怂 緪뛢軄嘸耀ؤ巄ࣖ㽢攻蝤츻葁霙৩ᤀ鏜乁䧧ദ렴臼蜠屍ꊘ䂏胸衈Ѳ䂦ⓗ豒騩䶱虆䈈苇̤槍㌂뒐\\u0000㥗鸗蹡郂订ơ—⧐좭岐⅊䥖㮦\\udc5e邕\\udc32嗉̿⯒咄퍂壏쀩餢퀋֒됒扴⸍邴䓳橑䙺⁸葲耜ခ옐䆩Ѕ᪟쉪䓾拂隸ᑶ㫟椛፦璃ᗗ☎솛歡櫵\\udeb8뚺累⍐罫䴵脪瘢쒔䨉湌檧냪咿ᐓ≐赝鷁敞\\udaea呀迬碇⨖䓁᧝✉愰㗗堃劼暊륨냺䲻烁Ⱄ䴬넛⌶浴+㾱ᆫ嘫鶏⭱겥䍻悐憅䒗뛖낗埊㪓꤉嚊콜鐋皘ꓩ㫯ꂑ궟횦囒⫬㋷蓗埙쫐쎴풎⟚㠮Î鵠♰쁶虂Ⴟ耆퀓㭀㠋↷ᝦ㖍塐!១婀ㆯ↔Ⓒ′⮽௹Ꙙ膮㧄․舕㠯䏙羀▀君ƻ⮞肔ꃠ醋렕苼౪骛Ꙫ–ˬ坄肴괡ꋫ⩏䊠洌揑㮟ꅀ஌蕠过࠱ș㐕ཡ뜝慡┆ㄱ뀙瓛耂Ꮰ䀋솸\\u0002ᰒ惸\\u0000䣦\\u000b 擒⩅ࣦᦺ᠔銡㵌膐ሷꅜ惥ᙁ偁꜎蝮넊ꍐ쀱ྈ냖໧꽯軠꠾♉연뱅䄂׆䥈岢呪輈䅲礀ꄔ氋ࢆ⣀顓١찆肱షᥤᙔ熄夏뀬럂징㭨섌΀폨㗁猄䁎ᚢ점ɠ꧛䣩搄숃촔ིṇߢ\\udfe1螫쏇ం怊욪䬰⸧Ŵ㵇ﰚ⭵홬૰‶倄渎ঌ䇈᏷\\ud8a4椋갪뺰戾ꊲ嘈邒իŨҏࣝ砒⻦٩ꋃ쵱ꖳ۔ఏ润뛢䗛蜳ꁻ㶰בּꁱ倢쉤㮃풐넁쫆⏠މ⼄\\ud860┋䬠ꪱᄼཱྀ舷豢ꉐ胣ⳝ暗耞ૢ젛σ黶㶅鋨㯨匴္戊袌ᔇ탰妃뜸⇱鹘Ʉ缞艾ᲇ爗䌄࡜䢁夤ᴑ넴ᓢ᝶鴢⨆䨅ᷣ탟满漂랠끆⏉ᇣ넹짂퀉蹰䏄鄂잛䆯⧚폝ᘁᾕ윇愖ୄ灛ᯆ䛪䣂챖ಃ郠§⟂ꭾ桄擣䔉귐Ю옋⃭겫⽨芶퀅㉘。頓ⲩ졉뭪堑Ȟ渊愭∉聠簁ᅘ㼂ꠈḾ⟞姀㻊柠\\u001b೻梪ᙿᏚ⌕ଁ뷄䆂頀户緋㷳隺\\udb89樓숁ᩃ漐௱㮇熸궈褐䭇⇗틔\\udeef먀쀩鷰Ꙩ\\udc1e 敊啞肦ಫ灓੦ࠀᒇ꬚菹\\uda7a辧졀鵽䵵쬭뀋덯㟋ᗂ䴱缫﷿밍砎ﯲ宐㞰䯱蠷酿ဧ缩ꛀ⻰齾悟ෂ齺猕硓ꄩ氂㼓๘읉ᓂٶŌὐ尔썟䊀衵亅霷ۀ㷶舣叴챁㗐爎弆Ҩ栂⑫ꇙ琋\\ud91b္Ḥ豕杠簄⤇叀ʵ⠒蚗娌䡩Ꮉ栦ླྀ㨇ꀞਤ⿅肯잀捻䃤ট润潳萒ߑ䥲螰昍惂Ŷ⬃ꅊ葟⠀Fᓆ삃馇ﵢ䜸緶崆ච܏ꥊ蒰殣⁳࣢⒂낗䞑Ḡ\\udb4bɰ뮄⍗ੰ眊鈻鑁璇剐臈⾁崷钨り끝஀蠇Ὂ詀䃓ྐᒓ᠍Ᏸ玀挍䊄Ⴐ⼅냎퓌笉䱁왲⏲䱯ี倊敠⸏ᱽ⺗㐱耈娆먋ꁖ貱榄具蛨찗酢盨ᆄ飝ģ⨂阈䖋㑥諀娇⣽ನ萎꣣࡯匏幖ᓠꪦྲྀᅞृ\\udf14쌤ᨎ蕠⼈N仕ᣯࠀ瘡谏㜇ေ聘檱䱤Ꝃࠄ袖ᓞ昅䀆锢旤愕ₕ\\ude65눉ⲉ鄵Ꞅ⊂띰嘠犦蠔䭄輖䡜D䇶誨짵ꢓऀ䛱㡪퐠褒䓀⼋삆駔衦萨灊蓎홲㷴ع஁䱫镞ଁ䰙跫傆铘삄㽨佯牢굵ퟀ䣆җ\\ud8c9䧡笁졹䮯ᡗ꒴Ꮉ൉眸\\udd48鐴䞳稅࠶뙁➌ﰃࣜ⌈ᒏ訔漏ʀ㷷ͮ`딒铳䦔띋稾쌘䈌쀊哴릇堹迟A࢏䱔춅㩨䅔胶ⳙ픬ꕊѫꒌ曎ꁂ珄⠂ô쮤㬑瓙䦩ˏﰮ쵬都᤻逽㞑겯伛⨃牨ֈው곱늌飋賩웷㡌佰౉飁얩稉䱉㐠夂풌珈ք鰎㔡詗塌蓈䮿㙶졤蕈Ꮙ偺૬昒灋찀⽀墇볅盎整䍍쥸捻ﰱ㫱ἧ用处☹厢引\\udff6Ⳮȋ\\udf60脀뀍㨐褂潰轟现⛔འ㱗༽劏ᣳ怸Ӳ칤瓴켞⾸ᳰ䙼⋰ኤ૶༶À嫳ꢡ䳂藱슩揂쪣ｂⳢ己⋖̢襁뼪⼦价⣻ఆ缠靼矱옠鋿᳕ﰟ戢⠹᧍튋ܔठ⊀ﬨ褡ᇴﴧ㮰桢Ձ⠨熃ܐ缬⹈䯦빗ɠ堦쑁셾㫋\\udb0f腰樀㱌ͫ㱁꥝莠宆᥈౴矴흥玈ଥ㠇鍫☰ᅠ蚄᜖ቦɨㆂ㑮聨đ㲿ٲᲃ㑽螼䱃蜽燒⠶쭠듔⒧㡤蘪䤄ꍑ縖䫇䉐钠䫺虿⨰䌗Ｊ괃瞁܃궲ꥧ缘灃឵蓫沮࠯蟴\\udc95䘑낰⸄\\u0011䁀胠瞇푭膢媂\\udd36ւ灔步떚䝴찴⣂Ꜭ틌ꋟ䄦ꁓܼ턡꼐Ƿ䮧⤏磃༟獢⮸ᓳ休د礆콑Ⱟ㠆ꛒ꤯࠙⺯礬ᒽ졆耎䚎╆愎戴ꅲ괮ꤲ䨂ᑮሥ䝡矰鈡悯孔芾ㆃ⫢긱㦆쁤㔲쟳\\udb79ʾ䶭뉇꠨쐺럶㫳ꪺ龦ｲꗉ஭ͼ⺖ꑭ뫐㓗咄ḧꡠᰧ쁒∎讆᠙㑺鶭퍀䝒㮇葨ܧ戃儑Ȱఔ뭨ᎅ䠰샊঄歟榦䴎쌒猌\\udc75恋迪粅퀘델摱밻쁼ኮ灍䋤鱇ּἭﰅ傤譖꫻獛廆峉蝤欀呡┣ㄠค沣䖘圔ڒ釔㺁‬㙠┨Ƞ鄊濳죚릯㈿⎨憂涋ₐ聻蚲똧뱙뇼삂ぱܲ䓮仱뺁﹯ڛᵳ깣玎㈜蚧墆ࡃ䞸똡臌咀咘厣␤ڜ㮢舮蚰粅遀爄欂勞꬞쪇㢮粆Ļ蘠犀ٗ㐔蚡᷅캟䐕逄Ȯꘘ婗웞ὶ昃ꗀ⎡㩇퟊ᙅ锏厥打ᙆ嚺寪ꔑ劑烍㋝ŗ깘Ε簆9Ꟁ䕗꘽噶ٔ﨟恶饡੥戍椙晃匦淅㔸퀆獖놕Ṽ䬇ūꓼ俇쁋ᵒ≀仆َ㱋憗컒莾ꜝ똽ᠱ셦ൺ喑팞\\udc3b⦖帅ٗᥕ噧놀ꞌ㍗要ᤖ眜曱ﰅ쎨ଇ쑒莎ত邘뻌荈䠷컿掉겟핐퀶ℙ瑣撍ୡ购ᦉ뭡劀㝥₴ɵ䳗ᦞℊფ⦚⹶ኝ港᧱ﺃ톀ࠃ浞ⅈ៫纍퍢咄이균戇컕漙릤딍摍⌞⧴䔩⧨튶൵饙ӗ⇁䣇쁎퇁䀁Ё깤㕀箂꡴Г乇Ⴊ深몙롃Î⳥逮驹쌙땗飱춛⦟᫹렁龠羞\\ud9e0崅薘宅領嵅껅ⱝⴜ寅鮫쵗썛᫠䉠芩뀋陊괂䝩饜됏ꩺȮ\\ude25馑❡ढ껉蜎꣯誳⢪㍩䫛⟩㜐넌瀰柫W騆繗ፀ輔\\udd37攁鍝砃쏣掜떷弓児械䵛⼼✰ॿ험窨㘌䐠㼶덈㓒䦫ꐎ䂚⟫闹Ϊᒂ鄻艸绦灇숉㼪ढ鐭蚗烳㦔⡺쩮蘄彘ꙟ唫彃⻆뽷ꊠ쉩ꋢ涏㉭浦\\uda6e켆椒苷ኮ⬯๬꽙Ⳇ潽沭샶궭龤⳯煭胤­섴滇ꀢ㪠醲ꀣ늠鉶\\udf2aꫣꭖ釵䒾䭛峯뛟ꐭ뾧荐㋡閷\\udd78鮥緭삾獩빨⻻ꦂ玊㴆䦼༫扺؇厮\\udc4c⽰粆嗢Íꭧ䉨㢤朠흞份ﰰȄ㫶腪ⶼ㰰쪏蝨㰤ᲇ퀐ᥐ瘃눣휄撯蹄覞⍀焃\\udf45큦㕳坼縺Ṹ쇦濴ḑ꽣ൟﰷ慰樽햝䜅娿눐劃륭ﱋᴆ㲟Ꮳꭵ㈽賊蠀啅ㇽ䟟뻂ꚹ謅ࠝ岃厬⼸덄绊⃫ү灰勣鸸㨶쿮搧ဋ牠紾貸⫼⿟芭촋阘䏏ꯙ綔락\\udc70밳뿞㻨᷎锱繐㦩垱指⊃쬀﬩뎃ﷴ᮫猧넉疃ҽݳꡃ묧鎻蟻灒䏺ᙕ⨤斴语쀣䭢㵲쇅⎐믤췯䝐출螉ﲞ叚ɴᇨ쌃脅በ樁䝞酫꾴ꮜ܅Ē⑚抰び䋼㎽富ጘ俅\\ud8ad릣夽Џ⫻峩瀢꓎嬗毤쭓嗰鵈Έ텻루ꔒ腈撣靥ខླ᠘綑䩃畅뵉뢻㷻؅専셽Ǖ﫴䗙풱Ḡ嵓ۀ庿‑恺섏薠猳硩蔧\\ud886瀹拝಑衭Ꜹ⣰⑬۷㈞ᥪ糑̸鼓㤆讗渺ꨄ돕㸽┯↞듔蟦⤷㾾༻膋鼵휣ູ糖㑟قǌ쏲Ҹ袇힜薓྅룻譻쬨盲䠳쿅䯉뻽ﯙ诼\\udcbd䎤립寧楅幕鸠\\udb9f庛嵽䜭ږ痻帘悸ᯍ뻀댪䐣\\udfd9何⚰냹쨶Ĥ䲖㺪냱᤾簭壘玁햃屴勾\\udab3⵱㸶\\uda40氯멿졯眲悁읋㒣ᡍ奫節ଈȻ풂Ѝ㖬㪡⬢ᵨ铳쑯꿫킸齼㗒ꪄ㬍츣뀵⎸嫻髐啃똽춂ᩲｙꁔ臈ﾩ୹ꥲ咇䆤ꉆ﮲䩀瑟ꢄ㨳ﵞᄆ闯큰袃\\ud860꽗Ϊ믞ਮ뎽﷮\\ud9b0진ᰵ䞲\\udc1c꛲橹堔Ẋ☘㯬拡ﭦᨭᾆ欷蘀채橴玣裗ᐷ䙹ꄬ摦ꨑ魋᪘魴⠎䅁踌攛擎웬윦ر왣豎ߪ蜦㰈꘿뀄ᭀ쒛ጛ脜쟶⼰Ц肖鈎쵹䇬繓錅ኘ⁩Мݝर妥妋쵞膳ઁ泟5씢㥠䅨䙒⁌鎐䛗玮泶읧灐⠮ꡔβǝ补ꮜ䯁ょ荵裨絣蚘䙃㌶࣍빯Ф웆⻃偽ꤴᛸ܃ઋ쇘ř꓌襮嫬싀גּꂂ肜⨁霟I荴Ḭ굁⃤葘Ⰰ嘎졲끥౪⨀飸\\u0005鴬셡୨嫂\\udf00㦇ꀘ遑杠㑚癕Ⴀᜁጘ埍轼Ǵ슖ꄈ桛賞手྘勺ᅘ곜휱膉ὠ癀國ζ沺뢟Ậ냱㋘놇㑺蜨㤡☷唚䶘ἐ彛⬁呹ൺೀ騏⌇ཪꬉ唜䗬൴涢䘙廛䌐概谿蒈㿴ꘂќ≔ၪ剠蠶〸እ⍑햁눤⢦꽁㠚槨൴摅劓♡ઐ昣꺋ᡈ䠔쟡ࣂ桕艬ᝠ툠㠩섮ୗ鮂칌艔ᎂ遞㸉透俠ꪒ䆐幷຦⏂鈒ꌥ蘛ᨡ⛂贂ḳ≄逵ꃐ澨㍉郅頒✡⸱ꑋ⏖ᥠ퉚੠ᝠᕁ\\u0007ሑ킎逑z◘لཞΔ焢촜䬋䙬㉠इﺨ〕䅃ᾂ怋衎貙⮁䰍䓴㚖₷ⵡ濋碻⊉ਢł뎹킭둻塠䮤숓ׄ⽡妘⌂芑ڠ貸뚤ॕர厂騖킺醨Ɦᱪ뛑訄홢鄵ꏂ䴙裶슚ﱓᶠ閄Ꞟᇘ덇똓닦鲔놣륔ॎ袱ꤠₑЫᮨ눋嘪舊ჸ咈ᠨ셁ꌂᦱ\\udc13␟Ҍꗞ堈࡞뫅謩 䐮壉࡮♂ꂞ\\ud8ebីꀊ㘵쓌Ŭ槣품ᔍ楞⹌⮈㤠瑾ɠ䐒짓䲑䄆뉀ႄ퀤ꍴᅖ┇떳Ţꤠ〸ꔜ첐䣔͕Ｌ葄뇴ಀރ눇깸。඙┰ᖼɡ艋霤扇ﴋ䁎छ漪풄ꊁ\\t௹䙏累˸ក琂〝喡Ӏ朳矖耗폇ᗀ衢灇\\u0014ဠ䅋澘쯒뎈킇镂秤漞鉝ζⱔ鶈༛沘꿉仛뚣詏モꦣ\\udb7a樳剱俦鱳焧淍秄⥙뱚仈ऄꝆ빌૞㠐拐뱏硼鴢吥ࡈ⦺ڽ高♋蠻쏔驉筧簁頔ꟸ㐏貯踁Г詎ᒹ悙ၤ됃쨜ሊ❠䂁ვ৅듽밃죡굜彞捃\\udb01訐⮋砗舱֐ȑ⊟ꀣ䃌儼鈥郰᯻㦣䷛೶럊䜌嗭砲❹䁩됷⠆얪즄ꗑ喟ꒅ眆鋥廬칎Ṝ剧┋璣쁲៳\\u0011꣟⅕蜂唝槓퀂⿤픲⇠꣯Ȇᐯ菴夂或⍋ꄨቆ₏픫⌭᎘✁ᔚ绦䆚䫂鸒ꌗ蝝ᙦ㪡ٔ춛ڐ뵇錊ḗ̠㓀鰇ꃔ撋ቔ츁锹ゃ趣崘됍ᇏ้목庝ꩱ鯾ἀ\\u0006ꍢ㪱ṫ䟺₡㸲뱧䡀鱕Ḣꡒ覟윸Ǩ烼寊╔裏☛숁赌锘瓩ໆ䱓ᦚథᨓ⒑痶错⠕趣ජ̅饬쳦如䒡Ⴐ턪て⪋衬梱覨ꐽᦳ㞙膢놅곸撪饙툒甚눉闬ꄇ䠼颎㋆㢃ΐ惠᎘鈮䍍ὛÇ㐲턻㚴汑洟耜䝺ⳙ乏㌟ᑒ▧朓ຎ蜘㠈Ƀ쑹㥷탩쌆㩧疮槄漃㦔마앮ᣀ▛⢩旺㕔꒣陜履賈쳉ꒁ럨脅䢭㢙竏☃ꈬ࡬뿂༬ᇗ䏢ƈ暂╄脆먀I耏㳘͝㱦衣ꡳ麈악ﴶ\\ud97d첶㶳㲟枤ⅦỊ繪䍝鵴㇧䰂禋㙞十갡࢐ʑŠろ蹼玵鷌趆ᐭ㤥ண㺹㞒˃槔⮹峋카୹锺憫අ塥쮑㄀薓਱넧魁销膋⇜聢弦餌ா傩ᦞﲗ撏⯹骒芎ᣉǄ䧦笺姺ꆞ椲亭䰩ℛ⭹瑱幹ㆶ臂ꛒ뀑ౠ⫆⡰᎝粈틄㺅癓இ銬챤搯\\ud87f졎珳둖㳶ᙰ떀꺠腄珲ᆂꭅ㥒⣢㠃▐⬬쑅\\ud97e共ﶊ夻䵐Г鲊凪↧诸实Ɍο鱩⥠⹮젲遲暸䝛앃∇龋꾤р隷ᠥ軒ᙫ\\ud978༺γ桤㉋⤅뙒箜़ȥ䉊㲦鳀殈ⱐࡸ锁翮⼄㫼䥸ᰥ帶Ãੈꭊ聚탉疀豝衮뮓\\ud810㕉煝滢큲碹衔牠⨈蚋＠ᩏ䭚勇긗耥਒蚺减湯◿렩튟ꓛ莜䁄鐘壀旐ኃ叞䐋啪궵롎剭櫫䜺䄠쀡ć꧴ꠅ藎ꤛ荒尴ଔ뢽␋㓨ఒˬ殑ᤳ퐦䯆릒権擶⨎⛉鍑僰燅㍔瘴휝鮓朝㬅욘傱삯\\ud929拁嫺ࡗޔ搡伨递ꊞ鈦枂갢ꣷ峔醭砙쟍룙쓛ᯈ殭瘁뎅䏠蚄쐕ź鎐䄦ൂ⨷㴜嵭碐圙脉僎䉃䁦餐⎀᱁❥姭츇\u003eቌܸ胵䜬쩦鏊詰瀟恿ッ㔬鄵䁄≌ꩉ䁆꘵䈁㎌䡚넀봄\\uda69늣䧬⪲셉䄇ͪ뿻줰↡몃\\udc46獮㧴ᢀ⿧︘sè\\ud802뀌恏녛ꚅ邅餞፪Ǆ쥄㬷햂᷀㊲▀អ俁ᢜ넃샚ȶ\\udaaf婲䆐岍闗―舜宅쑛샐嶦ಀၯ䔅╉\\udb4f啽걶蘂㹁状䍊ꎐ瓶쮦䪒豽䒁賁ຼ䌀ঐ輻z鄸鐚﮵ﰾꪀ襚蚤⇉Ś䵭喀ꗇ瀾◎곶쐅啒ቧ䐋斐ભ儃充첛튁背逰㈬幠✨ㄐ챂琲爃㒍ꝭᱠᑆ⨚今윔✶姛虆挋ﲖនጵ悁အण怜\\ude17㬟薲ꖎ亍멨ꋋ柴\\ud945纣鵺讧骚⪃ꚜ飿쉄ⶠ镡곑ᙇ⺑즸췕辣䇥\\udc42Ð̀⦱쨍瑴퐺䶠∄ဴ¨\\udddc\\udc37堼⻮洚䛊柨쩍ো٬᭳叺戒貘蒽⇛㱁溔萪砤롡妯⍂ŀ㱘馸䶖Ⰼ祌\\ud9e0띁稞Έ凱㳝᭨ऊꮌ⁬挭悘ꒁ뜾ゖ貴\\ud9c6䈓䇵我塓\\ud8d0瞐ㄉ볒曁륑쌷☖ᬟ駆ﾈ灼潎ₚ놌쳦撚㈅趹壇寻㼇₌炑ﻅ猚D܎䰀照牼\\udc56䐦\\ud965歇뷲睙囖되뇔揄텛혠⭧ƥ䗁❣勛⃒驪랒㞍韇ꭖ棢泔弶툨풼ବך퀈벦獙ᨨ\\ude48Ḡ틀患鞾枉肢逜ꆨ醎뺴킗\\ud9e2鄲塸생谙蹽뎋몋鵤Ĉ葠┯¢ꨊꑲ숂蚟久㄃춓뚀摈켔㡭Ꙓ㊟ኌ쎵༡㖾캺⤚ꨋ\\ud857꣰ፍ栨㍠訁輪䘶떤궳淛䕚ƈ㮍❭ꭙ\\uda04\\ud93c쇦ᠬ䴗쪦珛ꃕ悾昲벤鎪礧\\udd72嬵벁鷤泸〔鈃쐒䛮ᨧ筣㯵\\uddf0ḁ傶⛲䲚ꚟ䚝가⩬팺魙퓬\\ud99b崛샧涰ᣕ䳓㓳멭훏⁛᫂䆨쇤认ᑢ撻왤훉㔕덭鄋ཌ䍕Ⴖ蒄梶鴯콶田英ᝮྈ搀靑冁ᵎ찀ഇ쪛囚壚图短끝⨉蹼\\ud8e7➪幍떓꺅恦\\ud815㮨투㭒튉풺䆺᫐廳ᙏꨍ䧊끧桜䭷哐\\ud84a錫魻ղ꡸吃⽿ᨫ텐튁耖䀲躡篓獀躝쏹鄩鵐絢ꮀ鹊儞䂠폟ꩀ陝∀핮騀솭➖ꩯଔ瓻岯씉ᒈ⬁ပ陀玠䕅㝏脴讈稃杚ꔏ❄ý칤䁊膠秵釭絔掰੒㖨ḿʋ䟊煏譂움܊蓽䢂আ컿蟻⽪젲뜹ᕥ甠椎ലླྀڢꤧㅈ双殹ꈭ䙠坘匐ถ䢬浔曡༈ꘊﹹဈꅅ航ᄞ⑄䬚㑓蕙鉻ᅤ혩头骘ꮲ罬쯈\\ud989䩱颩鱕磧ጻ侊⡲숀⾈붅숢配౤孃먝묃Ќ㵾渧葌嫥ኈ顩ꣅ戕ఐꤢ⤗쀚䓔榑 葿싥䫚瞕ꈶ兏쌏赬낯ÁḪ\\ud9a9㳄ы✙넣Ȓ̤躆圤쎳繙좣ֹ繁䰀酊踐Ԟ䱁㦓毻켆瑱\\udc0b⩡昂牆犯狼ꪴꀒ丅䞳㉮餰ј\\udf00펲㠒銐砐䮺밒ﱉ⃉㺂诏ი蒠꽋ꘇ鐿莴햕맓äC學・态⣀枸㬸ᝉ倢腲䩈⿥꘼Ⱥഢ鐢꣛蹑ࠍ퐴ƚྃ멢➣檤ጃ䱕؈ᬤᠦ븭﬍㝀饀撌⭡蹡盚쏈곢鸪碯憇❢막ฟ暁⨼㑊꼦䃸龯꜅褾倮簚璮뫱㕬竻밐发Ԥﻬ凵櫕≥裨䎄Ꝺ㔩躐㧔곌Мᎁ操횁蹨꯵錗\\ud8afᰁ鰈᰺鰶ઈ缣끚运Ó㪁젺ጌǵ悂섆ࣚ䷼鉇٠틓㬼樱ᰶ蠪㰏酉Ꮷ鉁헟拫ᶐ옋ꇡꭵ䥂篷팭㉐⸣ᗛ︘ᬙ埒য়ࢢ皁꒝㐎Ꝯᯥ逞ꏥ壁㧅囜ᔇ⋪怨떭ᖟΑፙ횴쮺㧢澑䏃偔듸휙躀ꣂ僿ꗘ䬁᠙떘캡撯ꄘ涜鞌뇊Х凍붚醭殬저࣭荝㋞᫰䶘噫㎫㫌￥蠅큀⽸㥑갆禀㎳垝곟蟁ᄢ걫妇ꁏ黜୧꧛컰ㅭ苩콆㍖포糴̇袛鵠㛧怌뻮竅㚈㦾ď㍁裏帒」鷓Ὁ갍頡ᦀ໽뛩ꅚ싗\\ud968覓焖Ͼ랕慶猌殰뾎겂恃趾ﶃ쭜쌊㜶耡⭑瀂뮚꽇馅慺욯撥毘粇릁쉦瀬韏⍞﷧\\u0019ᄪ塖俦믟\\ud9c1컧⠋᧩˶笈\\udcc2괖䅧䗂ꎂ좗Ⴒ훪璡甹㘯䋔鞏㒄尮ᐒ쑪尢ﱡ袺䖇玑敔⡛㓼\\udccd샱㲡迉퍔ㅴ선\\udd3d㔖䇠㎹籟❽ઘႬ섳餌䬫飄淛뜇錞芇㦳⅟픿ᜲ땙踡⨋돔ⓖ嗣ᮥ繭ɞ恲Ӱ建맅\\u0001ꗢୀ䌂ꔐү幗볲怟㬫㤀\\u0015⥁ꪽ䀽Ⰷ뚀ﬁ靊뱥ꯦ螧涙薗雔䛫ⷌ쵭슠坌҅됔륨ꇩ콂䈂㗦↍揑嫐培覘얣絠済ोฉ簠鴏旣쩎‬ꞅ㕲鿕ᝎ梃娄᳨缭ེ던׼࿨犀襉礃鱘椐ك⃁ᢳᅐ휌檎࠽唂İ඀Ȉ蕓洙ꈷ뙸༕䡊∇⨧䄳淥橃띘椅Þ릭އ䅵㟁陆䨲⡸琁吉䈓ʴ㇑쁏∼ㄑ趈썦Ꞣ࿩轏ᶀ氧犋觝䂅癑栱\\udb9f᳝ᛍט㍀䭼購肰⬘益כ疥瑽閛ﰄ䃀ॠ栀Ⅴᣜ췧㼺또\\u0000಑밡䓌ཐ禋 ϰᕬ焷໤瞣널£渋א∘鎵ᶞ挔活㍄仄睳뎸湕᯲麩㑆稃鷨침뗛컬矣럹㕯촰漩袗ⶹ聉컄ს唃ꆖ蕏ᬀḮ뭤綽쵪㶽9皫鍘鋹ヸ葝읮㬎捷厾鷯텧熻隆\\udec9鬛멝쵸㒂뭈휆줗댂᳈ﳟ䭇⇘映ﱰꀖƮൽ᠟离໢\\udaf3谇㽞듷쭑׵됗ꯛ㻘狈熾뼎\\udfaf費矹奬鼊㹎뜕ꖛ杅匧剷녈ꠜ紦\\ud9ab擴喲溚ⲙ烋鋜㇉꧘狘쯁ﵥ璨䎯玞㐩㗅쇓⨈犂∟牓閥᧰앆㼿∅튍觀뤤枕뷷崛憺莚怌蒶걀ꑹ튽圝Өꚬ炬浒啉〹澤졛ꆉ禑츌饋拙ð첐逪╋ҕی昙ᥩ佝恜횃缆紇૗\\ud968උ浬쏞훗臢㛐㑽됙㭊롪鯪\\udb3a䃚㭩鄥ꂌᄓϔ컒蚈䍞艡錍꤆鬤ꅦ칱ᬞ\\ud90e舰쫁偦쁯㪜Ꞅ襁ꪘಔ疧ꭳⲃ৐。絩ካ碌㱃ᙁ쓝❤\\u0000栱詈֯曧㚶ꇉ突ി䨃冶䬲涳㘫닑랩䁤厢籴⛗끏\\udfa0擶瓜샰⹿㲘蜎帧뮅\\udbac脕舳T¤몚\\uda81䲀攋\\ud968ﳦŬ\\ud83c嚇䑪ꏄⅹ혁繰ᴰ砷\\ude7c뵔⭛뜧둵ᥢท沠쁹윃묵Ჾ콓แ盭泋埙뢣ᡝ죌웓\\udf78བ큓\\ud9f4弸\\udde0跜塖萮잦군Ŵࡈ੡\u0026땳꠽ᓥ\\udb33㍁谋찀쨂n莥囖痲뚰࣎帏凲苭胡䤕駈빠ᯧ兺⛂껈⧋Ἰ\\ud9d0抇寈뭌큦ⱖ⚙៟绽ᨼ\\ud83d櫽㏠꼋뻢頝餠㢞섮ꞵ䩪첒ﮟ凜૝ꎞ깥꬞\\udb74睖㒿嗲廛\\u000b祝㋭뚢莵坮쮁찖깵偫츀륻\\uda46隦뢥ꏦ굩ఘ忊Ѕ欵ꖙ곩枢־⋎ႀ筬ᮭ๻地⭲흠덹볾굥臒醆䌁Ჾ삘櫝쎱ﵨ㻪ᰠ㤂츎᤿動⿥䷴갍嶄鲀럌具蚘㞸ь䶕E菳餿誟懨׷΀䋡ꨂᇳ뿊紋ħ䘠욺ꠈ䌾鲅㤌ʮ䀆ݙ嚨똯즯ъ䵮ꨛ\\udf30앎✩챁郳ᆷ諄⤺\\ud990ﶶᐽꓕງᝃໂ煌㾡塱ഊ䆢嵔\\ud8b6쐘⻻뗰\\udcb0扃ᄸꣀｹ퀀㸚䚥愃ꥨ䅢㷞疉懥笸玥㽼䁣諴波ᜓꆤᡮ⭒\\udb7a㱘ꍁ嘕鏮騨쟩丏ۢ촞鋛ၦ삃媪༗﹆둕熭跫ꑉ삲ߺ䈤뇍ؼ쐂㮢\\ud89d뉘펳蹏飱띾䜹ť⛨⏐孤ऺ\\udd7b졇橄ㆹ겞ⅇ硵깲졻\\uda11㗰㽕䪾쓧ᯮ⇡ੳ㙵℥䀎㌄嬂⇳㖃账懹蕽\\udb44밚߭ꅒ爏嘛ᔗ浬ド\\uda1dཎ䩃꒩짶ᴷ脯ꉺ䯎Ὶ⢢ㅎ쁞辉票뢞쇫ᓉ零ˇ晆⤃Í཭莹祘켦䋝牼㴱⫠塙⠱醺୰鸛枆\\uda6f熶膚们徻綳૊⬄ꀲ昌瓞\\ude6bĐ܀砇藺栻䀭鬌䑎\\udb08ﶿݻ桀胁ᑣ넧ꉱ驢ￗ浬鷧⹹஍묥钱䜡쐑χᐘ\\udb7bꇣௌ~\\udd68἗⠾┌鱈絛ݯ攋蟶牶룐쑿睢ٖ\\udef2ꕟ냺彦햃씫뱞痊䲃猨礝靐歠統ᮈ쾉䉱郬칃柈肕躏끿퀒㟝캍\\udcdb쥧⯡崫⓫〽닢췩湿훷㥷嶁䙲軲矓徏搽෩魰᝔僼뀭䃷㷚⵾䅻搂쾈ϋ胻㛓滐뗘殿内֦\\udfce妧ꮛ砅䈠烢潢䞄ࡸ袧裫尐ᫎ䙸☠욟ྦྷ摕檔㊃阂녹蓤腡촍푲᪴龾壆뺬刽ဓ戔\\udf0d쉮㤡宋쑘샛ꑼꧮ\\udb6bᨠ燆奪忆廬큰ᗾ袥缶⧄矺쾭᝿锡肀뙎뤌Ç왮\\udefd跣ꥏ赽嫣濫鹠䲠䊅䀧림菗맏\\udcf6뷜護됾Ⲍ᧞獴붐迳颽ǵ纛큵룟뿐㯏牯涄댵ﴳ閿磽ᘞ뗘٘﹌罵綂뗇슋杼ퟡ䨃Чǁ䘲ᬉ剀䯴⥘铎ᗠވᚕ︡⒈ȻꄯꙊ᢬僽봗없齍밃펧샬㋨鹵\\ude0aꡡ궰ۧ\\udd80壼ꇰ៓絶픗죫橵፷㫆归ˆ蓿퐀ꬕ岵럛轣밝⪿䛴陸뿏彛懅剟柼⺰碚怚Ɇ㒷섟濽ￌᡎ秏皣᭨⨁Ự뀙ƶ薨开龬蕡蚁糄肏㒽梥욂쌚䶲씕㲼텐⯓ᔧഐ馇㜃쯄꽏╹ꊰ㪯繍氏ꉆ벪\\udb53ȼ\\udaf6꽓⃀怟푡⪸戄ᯛ쩠됄䔛욃Რ哇ﴇဓ⃤⁨᜺枕㾆➑Ё䓄炖埶㺁᧷뻊๨铣㓹ᩌἸ୐溂ㄩ啊Ꜹŧ㸘඲ⳅ朜兖켫ࣽᦒ耔茌䍋䑅꺇⨄䁒祑ᐿ쯳㢐ॳ믁㤹菉胻貐斃\\udf34믕惡⡏䭠赑㢃\\ud835圂굲싎䙘㱄鵵歅ଋ洉\\udfefᄂḌ䟅簾鄖ਐᧀ䦂윢䗗൯큘㒞崹냗砻ｏ艶෶퀐ꦂ☀Я⨩艺ڄⰐ컥㻱䋀齚ⱞว쑏剽嵧䃓္ﴫ퉻⃜ᕁЮ塨䈭䙖ɠꁃ׳䅉肉˅\\ud88d楼㶐ꐧ胐광⸅㖃┃࿄쬽걫\\ud990荼₳ᗍ邂೤㐙湃䩮ﰡ଀ⅎ纽蟳ﮈ栝ﳧꂟ풺䪂⳴栥䡺駴Ȥ㏯ㆂ斆悰Ǿᛘ㇐▃왢鳓쀌綁蓟\\udd11緌琏罛艩඄⾰ᔂ᭶￘萨絬펲ٿڙୗ儇๼Ʋ퇴㙀ʴ\\ude0cˈ僛ﵫ\\udbb9瘃恶ᔒ쁇䋁㵦㥃闷䋏邜१䜟᳽\\udad0시㥇む毁퀂唾鐞ꄁ酷櫵쪇唓䉀খ倷∂＀됵굓舩ൄ厠船ᘉꬖ悫䉄ᚄ㔑硁쐅從䁰\\ud91a蛴ㄐ\\udf43᠌䰼䃤숟㙀ꍽꂵ翔烛䈧ஜⅰ뉁\\udb93弼숻㉂䕃䬉僷֩隀䠃洱耲ᒪୁᄀ讹宂恔ύ杀㕸䰂昃榇à䃰༄ⅿ剂﬉톐䑓ǈ২ኀ적谢恥숑௸㙀穂鶔搫炩əഺ줷஭㢁찣묫ѹ࣎嫠腃皲ퟝ㴘\\udc58ಁ퇿䍼沲濕ｔ≾൜☬ਣ埗칚裴ⷉප㬀ᣅ଍퀯ⴲ䃄訸⬚˜側ᷜ샮ꂢ௄㋄㸰䖷뀌孑䐘Җ\\udad6䵔웱鞛荹뤭ェΏ穭橁戊孌䤞ꀤ㢀媑㎇᠙瑵喡퍹ė绡뒁퉘뵤㑷ṃ璽焥逇\\r☤镸⁉脥ꒌሰ楁䑄采噉䯣弓ሮ䣬࣋섕ᘩ鰋ꓖ༏˼૰✕圌ﰏ烍蜠荷⋸褨䂣⅑Ȱሠ䦎㎤铣梣訹이䤒趼ᚏ堈肥愝䤌Ȥ趥⸐㓡\\ude0f砽㢀⚪㈨꠸餦䒑ꣶ䦚輑졏䦔窍壕Ṯ铒勩ᱨ哑찂鈏豥ꕗ哎谯圑덤誔膡䒵邐∙郋␣砓愷鵏氠ꃚ㔫啳ꂪ☈欀䪍얂ĳ꠶␨襀Ʌ⹢č噼Ⱊ↡썋ж䄧ꁴ䫕㽽ꐵ뷛ጿ∷耊◨窎輞褓肋퓃໅샷蕒썄喠俀ꙍ㰌懇샤㷼ི參扔蔧稭ᣕ贙褤蔰䱢⪐륞꼞贎韨퉈庌ᄄ汶拝㎹艇䦔\\u0007ፀ쿟㭸肂娬ᅳꞢ䊈↩镦䑡볌㑇㐑苖깆ፙ탂Ƥ薸䩀霤쐁텞ŒǺ㴘荣\\ude8a⶟❃ć蒞鼀崽횰콷ч틸檰宅\\u0007荰\\u0004緹벦偃ౣ䔈㼗樳硹ꉉ┒㜝撹勡貚⹟\\ud906낑ᔳ瞁≂齥姟蜹䰛焁浕윕ဠӪ谞桴펉刃픜ᐾ\\udfb8妜直渟⁻㰢ר㯩ᖡ陶寕条興൸师몠괅\\udbc5᜺귻탘㋠﬙叶ꘜ㓏쌗㰣玓㐹腥꡺藝쿀㚄⤥쀉犎壁縅鏳嗄꭮怯୯턟摵聄넌ꄪh䅎क़đ쨒븪ꅫ槂♆핌檄ꠀ㸾缨\\udc37ৗ혷䤂♣ᐢ䉠둞㥸辊￀䣹䈳邾⫽⪄錃縤색敍෬⥿ե눐蟎㼽쳏ឞ㞼폷\\ud823㜐ҿ홸䄼᜴簰䰎삄꠆㠿҃뱃뉥͗␓៳櫁夾䳊ꃀܰへ恂鈴᎐軈嘰⯽䐎ퟌ쬑䍘ࡍ흰ณ蓶怒ǡㅄ䜬㒷激䂙䆰䢒㭨∓崕ꄻ䒹ƌࠝퟰ࣡ᒎ丹㢠쉎㉄⼩頃⸮㶍㏼ឰᒀ촃눑\\ud8e2见燧Მ⾰먰怂ᩏ胑ր\\uda86簁昳⮕㲵蹲ᦸ싌吖Ⳉ惰㓖◗⃜贒烫䎷Ľ\\uded0폼ฉ໊ᄎ殺伞⌤ꑄ稠렰碵嶱ᗄ䒄\\uda14䄠㴣䗋ɢა昈ꒈ텍锸㹴㻁쩈믆蒐Ĉ䑒俸旜詈噎썺拾≄鿣䔍戼僒⌍ᄌ嬀⚓븁簒쀾⊠圬え뭅䨄瑉\\ud890\\n䧁⣠睄ᎁ삉鰵錸怹⡤ꥑ咁섫텄ጦ乪춄ꉜ겈䛑鸮泸䡂ⓠ꧃꺂뀅㈍㑲䥘␻氀\\u0000ᔊᧀ炠㗇熞蓁썾伫妸℩浶ꘂ歞결䤀(壁㌁䰉っ倳΄蜂࿈왈ག撮እై㧨殅쀋胩㼀ੈ\\ude4d紙衏鈭䆩⅑榒颋呗ʽ䆑≐踣Ớ钌Ķ䫻쪈젒蒋\\ud922쀘쒎䢒㤑ཅ칉鄜ꡙ㑣ጅ∔ꅏ䐂䢞ो䅐ر䱓녍씿ᓂ刓ᘱ⾆䅘㖤ꥁŌ䔕伙玁⸅䰵↶鏻飩尘Ć膅놴阘ἳ猒\\udc55憐铿䑀㰔⨇鄕धራ༴췤竔䁄ṫ손〩䈄檥姕뢥볹텛턤醂듑엒鴂㗦䠁㪽抹햐\\udb55굶璃蒸跧ⱝ鉉䦆휪偲զ帄噥ꠄ痉類䪥୮埃ﮏ俀ꬼ馇袩⫠㿇迊㥬쁘䷭㗨ȣ⑉戧炆ﳤ௑岴홃⭎墘吊䤇俻ู〓砏ⰴၲ̨帰䯣⽉世Ἃ薑虘螈㲘꽌ꡞ〙㤇ߌ⮰Ṁꝏ鈤쒫勾딋踁ዘή飐ꍑ赂⓭ሜᰏ⇋⽏偲⚇眂䜖쨢飜唐캦ゕ犽䰡̵ᣰ㈔ଗ嵶犈몉ᣞ⇹袃⑘얌阴칩捿֖╮祢裣簻⁔㧏炘ᕘ졭飂㐜齅ᄢ烖⤄終큁亏씙㢣挶ⱺ䭣嘰㘠ᣏꋭ莶⦌䝣㧡挢쁯煶׫袆丳邆婀䈰ྠ䀀\\u0002﷜ื㨐ហ鼀戳⎏楉쒞ᣣ踍ℎ狀哋렃㒘폼鎍ㄠ⊕젖㤌蛟謌ᔀ༇\\udd3a㉂䡂䍥ᡸ\\ude06䃋섃㎳䯨ㅯƃ\\udb88䤦ല厙䔭⁹翢띎䘃ꔍ펩흧佴ꕉﻄ洲휭尃࿝㺀浴\\udf0a‗╼蔍㊃ᩓ灕湐ꔷ핓亅\\uda9f㩥抃穀璒뉂ᇋ⒈紱횎在鴹琞寝牡௒癎뒤䆊ᶟ㊰끅ڛ4裨ڛᅹ㛒ᛎ燔ࣖ教丶គ疲䫈♲댧譅킭搝ỗ尡裰ᶗ䮯해ꟼ翀㡢⊥㼬髒❍즜璼귪럻㋬購ᔽ䒍ʒ잌㏸﮳蔍餪䓔숅䱙⟬흎텋鷑၏쩴캓玓෈Ჭ⽸芬錂鴰ኯࠐ⁽୒므䝈㓫핿搘Р颃\\ud921\\ud89f胬࡭䈀렀㜝䡨⍿柀׌簒ě्㏠ࣀ셮䂅逎蝚兄뉛许මﳒ㮌ⴣⳗ崙鄠⪠㈃鈃㟙ࢮ⎔䱻阿ǢǏ鲑퍇輷♴쉳癇덒獭췇⨹捐ꝍᄳ弰ᵡ칢⧬鑲廍鄭Ⅵజ쩲㐋ᴪᲡ粹䤗잔릓黋戰咹ቸ萯톸惲퐊锣텯툗䢶䘜꓃ỉ䰭Դ쌀䳢⅀෉脅㲈ሿ䬆ᬰ⨁䧋縶ἥ䎛仮㺤ﻂ敋㦂鈮⍈脌垀Ⱓϐ묭Փ莲䫆ᔔꋵ텊䅌鶻锸㊑⁓귊렽性쿯㸔蝓蠏꒴勲仚ᾠ䝁쐜糇됹䥕ॴ롲坉㲤爋툾岼븂폍ກ怺⎒ᘿ⯜볲鶐⼨咠⎞뛀Ꮌ떩꿎\\ud936ﲅ儕䡎Ρ䛨栥怆ㅭꙌ鳔팃偳ㄶŔ롷ɢ᱖槩醏͹趈҉ଁ᱂븑곭∬쎸ᛩ垩縄躟+砦芵佣ᢀ詴鵔ꝰ◜苣ḁ铁⩖ⵍ⊷헊ᩜᜰ鑄䑶熘ڧ聛ᤍ猐緄創탅₠胒懈鲌뉐拗읔豹È甥刘㉓ꄍ⒲ᰲㄝ銏옱삨㷒覃컃㠽즈䏗⣟ϐ젪ⴏ㩣蔣崟ਥ␪陒⋈휠岁䊠䣽⋔莂⃈ﴀ㒐≒灝诡킌洧︎퉇䦝≰귒燉尯邬䜠़⠌餼㔊ﴃẈ퉀讜耂䵬ཌ굕퀄쀧Ⴤ썑섌斥\\ud801鉋ٜ렫ા㥠귢ᾏa䝌閌屶䈙ꢬ㢑擾파⍁晓ඁ쓢䣚瑧闱䝣舅献杙讀ڂ垬\\ude94렪킆쀦Ć㛵䡻ᚋЧ㈚氧袀즠抨増븎虼ꃺ㽞䡱溊倝ꆜ신ᒞ接訋聯ꡚହ齪崱哐ꑾఛꓧ詌Ⰰ 䄛\\udc2e㡢Þፇẵ㈊Ɯ햠쁨콉బ\\u001e㢯卛ܰ䬴⃦舋갬쎐궲ى涎ࡼ◌蓆⑰⡋﨨Ꝥ艎朖찠崀뢰宎ﭤ䵍ꛀᯪᅄ闋ࠔ鹧趬癢Ợ잋\\uda61Ƌ胪䫪౹កⱋು墲쐆蛤ꆀ⨀爬蔍䈻奈蜸轓✑쀱理瀠ϖ잼㱤욃稵橔憬ȭ䢿ᢊ嬧岁䋘㥭刨됌䃕䀲꬜쀰喇ቝŢㅒ챶挺᥄邓징䚩຀鉭⬀\\ud93c丕︭ᬕ鰛境厴ꐿ 츄颙Ǳگ౵绱몡핮ࢬ칠᜵䬡ᱰெⱘ봑贌Ⴤ㎠芏Ⴟୈ瀦⧀렲導ꇀ癞\\ud990콃✨홌䫰࠰ꣴ㴛쓐鋀ዋ⅓ⲳ᩵\\ud942週ΐ㸱䈭耊桑拕㑀仂뮀碇∘ꄃ桪ଉ偸橸㢣़뢄鞞ᘀᘐ눁잁쓗区玸ꇢ릍碀\\udb88၈᥀ၜ쩈球꫁㒱ٹ୆垍㹮旉怂ᑕ琢ხـ픠לȩ焂ฑﵼ쟀ಀⴥ譱뮍䡭륬魂嚏⨋⎄莹୴㍁䣂梇荇塐ꦇ国吱\\u0003㧜ิ狲泣㖮耬蛩蠂\\uda20虾Ĩሬ䉂硤䊞꤇\\ud882䌒ᛐ㳸퉖툖䤺ꄗⴇர廀燄뻒ⱳ僜阀掄㪂箈䪾섲ǖ验㺁⎎퓄勎끱ǀ㾼㱀韠ྃ\\ude20⇫䑭ᦴ濰碅먄䫭涭툮记㤫Ꝁ鲌튊ꂸ蘼뺀䠤ᮦ꽅쉝Ṓ鰤畓劻⪀蜃鎚泡璬銲屯ꆩ昲ꒌ청袭뉋⪥⦲빩᠙ﱄ뀝쫸⧨껪ࠧ㞐寣䑚쐬嗒뗔羒Ԝ偄ᇇഃȪ郧ʉጧ׷蕓༪㒯ꌿ퐴ƾퟭ埶⻀癢赖젧롥볌㬠忂튶䴝⫘ꠘ닄䥋겯딾쪞ಬŇ针堫ꁠ쫯ꀏІ跤凊ካ䮓쫺㊽̀ሠ⚫롶ꬹ⚗蒪᱁ఠ醼곶៊뒕܄࠘怉Ⴐ꺚뙪란圬㋷郎䱗⻘漜魇ꀗ櫯硚꠺떀孔㪯灊褠䆁覻ӕ凕⮦墴ꪮ䮬깳໊됫Წ찹拷ꪬϨǒ念痠宜ᴶ଒뚗ൄᔥ빔̠᭐炶瓞࿄쒬댭㎛쯬쯇䜴ꕲ⁀듴뎺켥㆙Ή삫恃䭜㗞傟䄜柖먔犌玒᚛㷬ᬫ+惓슠૪著냅࿎䲀с儠鑌勰돌ꭰꃰࢵ䘩ᜧꥎ䤢¯퍚\\udce4ᷗ鍑䴗琙퇍婻妳玖隷\\udd23撩䘳䔽ቂ剏舢櫖⁝क픡ㅫ즀⎅靓귷≐꜀ꋔ뀕푼閟㻆዁㴫郯ﴈ엜唠㓙꺊쁳揻끲딐筍窶气ᔦ틦깹梙瓐ຳ\\u000e屼폯㗼쑳贍㱉橔柜푔귵涱欵ꨝ碁֑墔翎ﯓఙ맫꨸ªﵪꪄ嚺좄⫄쐫峗Ū媳␟毎짶똼薓퀓\\ud84eട䡚닒瞭ົ灱营о걅瑓⣦놯Ԙꨀ稃ﳜ鲲쏇ꦵ⩎ั굑ڶ窆饲퍹ጚ봑휋偱쳇┿箵믐ꜻｓ⭺혻유擠࿓양ꠛ닮죷✼鏳뷊躼ﲎΑ죟⁤폢꒐뜈ṡꨌ췞᷺뛬\\ud800섏骸飹䭆娺똴̀⬯⭷殣펖벘罉岇蠒鑺㔽걦寚Ԏ켳烜ି㝺\\ud86e↱蓭ꃈȳ龫ạ뤀䀄～ᩭꉔ౺쥓伥ㄇ僁௨栶鱪ꎅꈄ⭃ۆᨾ콈䭪좁꾮瘓蛙檥䀑嶈⒡뛎ᆫ竫ﳄ໾㧼ꤛ醻瀪耦Ꮁꑘ緌팗冤窅怖ֿ娽⸵揗頫\\u001cN脰叺\\udd1b䜀우⮌淊ꯊ缫꒩䎌ڋ値蒱ꡬ꥽纮耈×毑᝶굚췫⛋ᄱ袨풎뼼훫摪↤糍嘚눪Ҹ氶禡꾱Ċ缱ầ䚔⼲ɒ䤇ㆳی윑믆榵Ჿ玂浺ௗ笑⦵搥⪷䞵㺢ﮈ⤡ꆾۼة娆ԪꊉꜴ쒠㎰瑁Ǣ鵩췤ࢃ魅⒈Բ杁㼲茫녌벉谰꒘즉䌬슖쩘甫\\uddb2鬋鹨暒‭⳹ꉂ蔴愸⋘ࢁ녹ꄖꭂ\\ude08␂⩺肄ഖ\\udd14ꤧ蠧灍짦섩䂰욇邍鹃\\bꯣч䅅䉏섑⬰\\ud8cc옚릀定鳶氶Ⲓۚถ힛®ᬳ푷聪ꀚꄍⅇ죗魜寗䓕飈⒂样꒩㰮閥殹闵ʫﮭ⌀氊獂鰰浃誯뤻ᆺ殼뉲䔪ꆯ㘧㠑騾Ձ辮㌲潔눎宾汕갢胲ล躢\\udad2냞䃲⁜钰ᗍ褦외銟䍙\\ud950ꬔᅦ\\udaa2 甇萠໢೙叔聊7⭘쁨粌▯༽暖᪑閊ᛆ뤚㩨ᤫ\\udb78䬰@ᯆ所吃ꄐ䰔Ʀ螠㧃ਁ簇ꁷᦝԐ俀ʇ红ﳽ歹ૈ耘됤쨛︱↮ࡸ䊴顪齕ꚽ듘潩ꯝ⟄緒욶π๗᪛\\udc6bꦦ㛲쎻ߤ껠ᛚ∇䀋뀋쥤Ă覃筚豒붪핒⇺띸Ῠᑁ阣퀍혮䨳汰奺헫䟐冑餞ℐ슪୶￠⑖⚚뗎ਲ਼䭺턛䡉櫄⑍䆅ꭁ做侮醼頋晝ꭿ㏼豜びǌ᮰搱䜲섊뚜\\udccb盜ù怺ᜀ휕풏뀋疭푺쵰몍兺졦䙘娻띫ε䄍騥ත뤔頬♩헎劀鎊쉈ᒪ뮧‛騬檦徎驵ﱨ檫暄怜涭㮆㻃䷐䛵死컞ꊬﳤ⿄ꪻң섐ῐ彨ꧏ縖덿\\udbfeΊ㱯ᄻ钦髰栭ꂆ뚚௖Ի桞샻ꩈৎﮇশᄽ㩄œꆗㅵЂ⻮\\udba2걝羓擐筊뫟橛䫣ꑎ胴걮텎㚒\\uda3d醃뜤舒궼䀪\\uda6b案ᮎ㑉怄涹뛖\\udbc0胭봐榠ꘄ쀇ࡈ멱꣚᥹⨺ྔ讧ꀚₘ걎˨㬀ꕡ괝많鳙⦳瓡돊팽Ꜯ饫嫒펰겝㭸ꃎ\\uda9a㋮狑Ἀ撨ꦈᓶ⁤݌ੴ꫘垽뢂鷲\\udf6dö㬲ῶ\\udd34胪쀄ໜ㢪팤嫨⠺놄溩뫵爐ऎ媱㺻⳹鈰荎ᡋ쎧둂㮈멠爻蟌껠¶ꔞ옻ﶆ掦ᬞ㹚교囪\\udcb6謾㫲\\ud84e흐篒⦹亪稥ན뒶闛亳嶱욒敘合ᔥ㾺﷕\\udbb8캫緳週ࣴ଻雪뎶ટ퇮뺦螳灩缷㤷쿳ꐀඳ弎뚂᭩뭂鰮\\udde3縴쀉⻣됳䝀Ề࣪ﻫꞾ溝䦱띁ᙺ\\uddad嶦泵\\udb39ဦꯪ盫\\uddaf溓㪬僭Ꙡ䢀䲮ᲖꙬ泐ㇾ갎㵹鄙챳⇐髀墡\\udfb1飉鋸娡ڗ뷜鯼⑫鞷웯㯼楷ꬎ뼺ᡈ範\\u001d飃ꬊ㵬횧ꂞ슚ⷮ醠Ҳ騪檛㻞樂璘瞠庆䌣칠㕦宬Ꭲﲘⶕꎄ䲑ⶨ栔檮ስ송닭᮲鱒᷇瀂⨤ἠ쮕傆ఖ끄쩰꒵定쑵ꌝ囊颀䋉᧸ཱྀ놲㬂烇扖⎵㚂銜痁㠙Ѱ兟᐀휎寝벋綾좊Ⴛ♌锲㓉꺌첆䋊呢셰듒뜊⬤겔⁠߯ⷳ麲ᵹ켧મ눊쮠찅괨髊㊎カ⢦쭐쯊㋂퐽榊㉞즃엿굾쇉ꐪ袰ǂ쥮欀癲䠆浪뼙爸ـᾐ때쨤鐞졓␰໤捸蜧⁴爘놭欴눌ᧈꬢၭ싳磊ꈶ릁놘䨴饟ఇ䕒ʷ肊ꨡ☄瀝၌㠵⠉ἠ絁밀疣壜ᗕဌ쀲꣒苡\\udb5d➞吤蓻幯朓囥뮾턻놪띑귩閡쨺譺㖩趮ᓊ窧욣㊯邀ꧾ䲵᳡뤅쬎ቪ豇ꢪ⺃Ẑ멎꫗쇥♪갥昀㚬䡰臤蝁앴ꕖ쬝颗\\ud840䇱ߤ⺹駠뿨䏨꜎⵼ⶄ㐠ᨆຂ쓂㦦衖詀홥䨋ꐛ沉譹쫫喛綝ਛ沄褙膑3㘳㝈섆᭘䘪膐쇶　㫽걌ὴ㡝飇謂⊫୼ႈשּׁ䁠ᛔꋻፀ璘錋셪⯒飖쩩諤힚ֆ蚲塰ꉕ螑漬ꈠ╴塤螼ꏍꉲ윲뺨ो뉌蘐심Ἄኸ뻂ꢫ갲렢瑹俈䑁먊솕Ḥ蚥힀ు긃踓렂僈磪㺁闐鑯料ꃘ鳚坃춡ฟ־֊ᦌᦸڇ钾ૅ䨡䙀䠔ᵔ耡좻\\\\헑ʋ\\udb2a侁庵謨ᐊ𥳐걀脡뿫쵗꫈Ȫ譚灇麒ट釗桠槎꟔ფ婌祖飚撊䌑\\ud9d0븛끡쇳겘඀嬸Ꙫ冉䜾ᾝ庞㥇罤Ӈ㊚卲寀₱䜪⑫㛡ⓙⷞ褥ᑆ轥⛞ꨐ둊쒌碇둬ꡃၒ뾅㪮쫓ᨧไ殁鶏폝聻覽쟐ᡤ禪ǔΊ풎䙆釲魓몬謍ၓ簂꯴敚ꃇ轥ﰒ凇榶蟔쀪ힼ낫⡷整ႜ⯡߮岨ṓ쀵ꏩ砋繐严Ⱚ橳萀엑諆묤]⫅愼ߴ晱\\udd68␕ꭎꨥ꟦䍭܌㛾苢䰘⨶컢㣪葢Ợ笲촺쐞蕺ᝫ㚪ꁚ{ꨳ鮂⵻뀀璗끊ꑡ䲬\\udfdb➰쭟默㬟쫯ꦐ떚ﯬ⶷컁﫳咆釁팰拍誛躡뱦\\uda1a㷬ឪ앾곬ؒ(Ḫ蝫駋㘾ၦ㉙砧郮䄽蒀菮藭譍ὒ뇃쟫₮魺諬伫늮쿁蓯궮꺫怚⦮컛⋬쀗뛃鴹熯놉ꏫ➱箹腀㮈齻꺎荻뻯☗ᒌ琞퇴臨惊觲✧뜇곧ㅂꇪ঱晢뭄馾꼤࣫쌘軩氯῵ꉠႺᣡ춙ề蘨ꅋ洭꒘Ꞵຆ㬰țꂦ鼴䒘딈黑興騥툮눧ꉥᆙ懜飻ꕎ苲槬妄溭藘ꧽாᷲ厏鎢摤﨓๙Ꙥ鼚袉⦽瓬㭝ཅ〮\\ud8eb砃뉺ꙓu\\udfae颛෯☎⺹尚呋꺩臘ɭ唰ᒳ稇ㅒ狰邛꜖〴✠࢛ꈄ䁹㗯뉧উ됻溤숦＃힤覺㫂馚旗䨧璘宴ꛢ\\udae8頯墮쫪됢껪\\udad8麫ꎉ諸ꨁ涧觶\\udb3b毗ꎮ뫩牺歪㮀߫끮뱻蛭掭尤顖倎薦撜Ɜ瑾娎蘧㺙䦝䧓웠딎촧㏯퉵\\udefa⚛꺚朎팧츂짮사鯵ꣁ辀↴牵Ị㭜鼭쿩輧뇪牧짜⚛꿲戆鹍驨霽箖鮞▫㖦㡋殱榀昶齈帩轥ኜ푪ꘊ⍊箛ದ늞蜻ڴ﫲鯾㮙ힲ懯\\udcd5廿㞑ʩꪞ⤯庹⚁鬱馗涧㧓艥᧺⌥饙돎糧턔垿\\udce5篺ޫ㻛ᇛ뉬뒹諾嫇\\uda7eꩥ霏场\\udec5ᦫ恶좇㺎饆ꆋಡ뮪쀀窸뻈ﮇڏꙄ榁䛇ᙢ㲜꘼ힾ돇ﯫ鷺ớ箊鳩낾쏩⾸聈ꗥ❖怘⨁돪홮⛭舒椶ᴮ헌澳ⲟ짯ꯎￆ糬⼵滪ሔ櫩겒쬑겚댪ণ쪸䨳ᗙ똻滉暻걭倴翉㯊Ὲ韝㦭҇溼盱覧籾ၚ窰浏ꓙ铧宛习঎湈䝦되聄䍊球쇥␹ꕲ刪ꙭ㦦৤騟ఝ뫦랁矬哑씳ȵꋽତ帍ᶍ桺恤樺슯軈᯻싶ᩛ蠠벼蝦આ飁₳闟嚆屨笐\\uda1eӉ牅߈⪡贠㝠灢㦸ﺜ透\\\"꟱Ẵ梅渝퉴ᝎ㚉⹡튐潇ଢ଼⁠鷪챀㘘菋懊᱁澬갖찆Ⅾ⯊ᚶ쮬⫲庅꯱ᡟ쏀ǭ魡盡\\ud809쬃閫큽谽谱뾁혖ᠵ硷Ꮜ졑息ར\\ude44㑩╣䜁걋鉩壹❲㑳ᇹ푴寐န繰㰔퓣탸쑤玠乬騟鋈퓓渠ố읆캨ⱥ樃⫄꠨횑赂䘁褫熈\\uda77᪠佱Ꞻ쥆㑮ᦕꙒ改셙䙺鵀ᨓ聅柆챷뙹畫ﻩ䦲턔ꯚ斩齥翁࠙칾䚹ᮞ먀㓰碂䰜뽔䋍眆枬퉺ꆞ䡞\\udcb1眞津㉞ꀋ◗兢顝릞ꊦꖩ澸秊᧙탷䷞쒖쑮㙷⦖鸎녹ꏧ퓐ﺹ樂졩绦뿓큷ꩂ骄ㇽ鹡瘪\\ud901湓敓뇝鯚ꖪ릡묑⥐腶づꣷ㇆㠜걬ㄺǕ蜡꺽䝮Ⱀ虡뛶鹄ໆ愂륻뇯튈ꩬ椖룎䶟┪័萖왮弖섨쥛輦硣Ნ稑콇ଚ銰⫞⅋ᶐَ汖Ԙ舃챚잽옏꿅뱗И扄趖껶锁䡗儜\\udc79Ⳮ읒췜浜ﷆ቟婨㒲정窉얻櫕횷恝Ļ䊉맱鴻弜ޯ쁆龂⪨呉ంມᥖ朢餕歉靜璝䥯䦘悝䀤眾떺♙쥠䔚隕ꫜ뽺핪\\udbef㐷槻畫ѷ䇚㍒쵙\\uda98箪澵杕쳺I嚦Ẕ㨴鷵涹읠鵄쎾姴勺蟧Ĩᝣ穄枘竐犠棩泜쇵믒\\udea3ڏꛜ뮾퍦㏭ൠӷ宓徙樛諔ᩚ嫺ඕ\\udd35붙ᆩ릟윈視狞홃돬赳꛲섐䏆ႧỐ䮝똌맔堫馫䰐疠殛膠ꖠ쑶䨗㮵\\udc01筟挅뜫烱鮍紸팀잲㻑馲\\ud8b2䖳阦镵욄Ꭓ䖀ꑼ㉪ီ諭刉쟉导ᥲ푡ꠂ딋胒燃鳢ᠡ댷䀕㚒썷勄㺋➆䕬䝎䘽㛊ࢅ殱騎鉂빟剎铳퓱⠸๬쬌䊳ㆬ攰䠯嘗挓⩏۲럦酛錆┆奞郬崀됬ꠋ죑૨嫼郲ᒀ裵㲗쥋\\uda40ꎼ蓜憀弢芈쁶ᚫ⠰딁ꌋ瘘쁾닦쨄忊㜁鎇眧\\udc8c㟪⬼覍阷⸇捬㝘ᢖ蚍鲁盛푻⁀⥞ꞽ룜厐闂〜Ĺߴ䛠ꮾ㕱䰀㍺첔疆֩貅ष눃﬜ꧭ訪쓰业ꮉᾩ쐑⫠萧ᘈ䴼橀␈ꡓₘᆱꓓ쁟승ꂐŢ᭓䝌晷䚠䜜퀝ސ跄䓜ꄴ˥搰僄\\nꝶ薍⓬\\udfd4辶\\udc63貓킦ಠ學\\udee1沼帗Ӛ쁢싺쪬⯀瞚኷亃⭠犓⡨\\udbb8ཱྀ৊眇詖爫䪅影᫰嫔䃣錣椿㊫俿䧓傲䫏ଲ㒶능줦᫷䳌ᨆ\\ude9a엗씫丘瑞⚕罠삽ᣯ댅컈㳐罛\\udd22孹孌䴾鞐᩠夵〄꿙᠅菨ؤ‘ᢷ橢䴱襺뀳ᒭ㧭妭署▰㔹ꮉ挫皖វ㹫杉쟎㈠䕧롐땺댶쨀ⵚꌻ헍洱餪뎆嵙瑬성蕄੻륵뫲랛㻴ꖲ䐄\\udd1c걣댕黻⥉ꄚ斅竑沌Ȏ쪧缠᩶⠄❠鲂갳쿑蛬覓랚於ퟲ黝縼쭦છ䜯⳨矋ꜰฝ銲懨俑\\udce8ᬪ䩗攵遳쁗亶傄᪮⥁᎒⹜싯쀒Ი∥駞桝뷧陘蝽맷巣䩝魧⠧蝫㦵睇䪷⑸걅川ﬤ䄹퍷袷⑁ݲ㗝竒⁵\\udb06ꄊ껁ꧏ춿ࢦ휤椗疵녗귘靧疻癡\\udd97戠䝶烈㶶䭵\\uda48ఽﰀ㏋龬쓛똁䡻笱䞛諙㰮㟴ⶃ㘘砲꭯憾ᘎᭃ㦭턶냌劒뷘섹詢ò㮀᪷瀣㧒װ́㼔뜩\\udcad를燪ꆋீ严먈⠂쨠℺྾鏼琁瑥ﰏ妷⤬☳碥⤩蠑ꕡ랙칋\\udd92䅹狦䭢鱉⯓ꐷᶦ她Ꞅㅀ\\udb1c⊜糃铡셶ꐘ턵⺰崾埖企ꦇ南靟ĸج沭꽞漃삵౾᭨硱㫅㯕텓ᓝ塈䬹䄩ꂦ쫍砠䜎糍诟뭱ᣇ㕻盘瞶䝛;\\ud920w闏暵岐眅娍퐃턽퉉盧⒕쳁㎦ﺭ儆덩鹲š产哠릭퟊오섡⇨ᷲ啶呥㠻綷େ뜹⯜㈠톖灪鏮ॠ︈⠲匆聵ৢ奃藨ଧù駬侀佃頑莯Ũ滍癞燜㹡㷞ཊ䋇唏崈잳ꃊ暄哗眰돝ཾ휮셼㯄ர縎䘇쐈䎲ǧ騿㨽揝ᕱ뼥简鳍\\udd7d．侘잮欪\\uddd6럇됣쨣ⴒ콲ַ㲏ꨑ都ᇶňꓧᩯ㝿㖃\\udec8﯃롻Ѵ꒤ﴇ꜔뉐悏ཪ셊迌҈\\udff7غ꨹尅\\udf73ꎣﯼ㈻뗞躻鸎쾈䈐쀽渟⎮ﰃ⣿被ᖦ㺨｝ꪧ\\udf28㣢ꁨ蹰⮰멲࠿炅਷﫢辽곁ꯚꭥƺⳊㆲ蚷㡰䗣蘻\\udbe6迣쳀篙뼥䰵ꗆ儓㚙휎б⩐間䨶箢࿜쉪졡뙞踩Ὲу㣯졥츈䍩朸㨲쥃葆䧭\\ud84e鞔屎ǅ\\ud800聙Ɗꓡ즕䛐Ȑ௅䄠䥂ឌ궸嗃ﭛ﷼ལ➷栺陛灲༾\\ud84b柭漏ﰇﭩⳜ퉒쥗⴬蠴芟餽樨蚯ฤ癎࿱죤㬕㔄윐Τᄏ祈㪱B螴﹆ﳺ㔱둛ꣻ텦눒ϖꐄネ㺀ۈ嗣瞆㓣ꡘC㺄ᤵ꘧㩮ቱĤ␨ᢈ坎쭮邖铅蹆᱀戒琹㝰巤㥭猣슦௔೭≠콱㽠ᙾ춖菙཯嶼䤀᫓턠∠Ŵ轎砦븀쓄쾠ٌొ쳼혜쾒∱☂蔣佘뷇熾㰬붭鱒ľ䁻憾㝁橯簓雷뀛潺ᛡᛚ\\udcaf椰юﯞꡜ雭섆\\udb10眺恇湨魷畱㢺ꠈ欧栂ﴉ⠭ᨄ潴縧嗈砟맽趎䆶贄㞑뭮⸞핥瓇陗鿥\\udb4c퍕訉\\udadc헯꒿犛塨\\udbd5൜釧ℼᚥ䃤쿎뎑\\ud9fc膇꺸쾄煸ⱝ鴊坿◕믲ሙᕓ⠍ﶛᔒ녓釖\\udb22祉ｰ䜓酦䇟寁ꈨ⹟ջ\\udef8\\udba8멬櫁酠向룓靉깋酳ꈎﻛ鑉収Ⅲ\\ud954쿦核퓮莭余꧔뵎鉌냥畷寖꿠歩ₛᾷ衺ᘫ꿓쇙逵旷쿰뻼葶㧭쥱祴瘸湥뒝虤㗮軃弖멲꽗쵘햅歪嬹耵\\ud997預浺䵧埭깷䷕ꐮ嶮澭麙덷桵氙짗쩢⥩ท㙨ㅖꇍ꒜ఀନ틻Ư͑柶멦ﭏቶ뫉⟀뜾밺뵦㘻郘聎ꤺ띷꺁Ⱁ㼥☛姪磸℧谀ﱭᱼ膠쩺털ꚻ墧됺꼍饙烹ꭗ뉜듫粐⹜Т㓚ޯ爂쁄ퟓ嬆緙踻힫闇\\ud9d1꽖뽮渫놗㕙虸㖃圡竨ࣖ鷟賠擴朠菊‮耶\\udaec䝣껾汹鲴훍ᵪ¸⺥㡾〯휶ㆳ혳ᓫ쏺캕틁価텊ﷳ㋮⼣\\ud966抉﹗麼ᕥ◜묓\\ud894㧋쁮锅镣盃㕹뗃콲陚\\ud985\\udabc㧘봼삛订৳檨搆滑㎛悙뚿쮗尿Ὧ뺫ﶮ漭턯친ƪ썕넧嚞핢鮲켌初ꗋ镯ꠃ狨溃᝞嶒췑橡偩ࠟ䛌淲熵獜ꮂ흙০ﳺ젅䚪뚍ᯩ뺠ھ뎯䇝䦖뗉⟫峧樽ﭯ缝乫鯕韛壺瑓玘蹹찟妦Ჹ횧떙强릤騧廆⻖縱铄原微粠ဌ耉鮜ᯜ㦷棹▢钡啛ÿꉾꜙ㑩\\udafaⓑ鼞紐륃ꞟ㢞土㵊욛퇥疹秅鮛鸗璳춎嶸伲宓䣛֠晭\\udf4b狞풘┢՟⎸ᵱ胝츉耔銕㑵가ฺ嘠鶎ꑹ釪龫璘곤묯浬ㅢ垄騴筼}谀ሿ矽뱤居與춺䮹⪕夐櫵∟骟\\udf38\\ud850蛒ᄶ⒬⷗쒎ᇀ몶ڈሕ韨ᰗ튎䧜▋唠竔䷄턇뀂耭삸ݖ㊂Ƀ肙ؘ퐧ꓶ氯뀦腣鎌เᬔꝺ┢뙁᭏퀢풮确඲䐛寰ᆵ뉆䭿鰟ᅆꂢ࣮㙹琁ຜ⭪ꯦ荸瀾ˉ⴬䬌㸇䓅挀Ᏸ疐┃\\u0010ꭳ꟪쵨ڵ׎欍狃x蚧腓偑豿ꜰ㸨೐㋰因ヹ쪇ည聆턴왖문ㆳᱸᮌ壙἗䉆ᅠ铣卐䎝遼콸ᾠ獁숨璊栾옵ꚥ㒧ᾰ\\nཾ\\udc61䆑躰膝㔀ʁ삑먤悤Ѫࠀ\\u0000\",\"actionData\",\"errors\"]\n");</script><!--$?--><template id="B:1"></template><!--/$--></div><script>$RB=[];$RV=function(a){$RT=performance.now();for(var b=0;b<a.length;b+=2){var c=a[b],e=a[b+1];null!==e.parentNode&&e.parentNode.removeChild(e);var f=c.parentNode;if(f){var g=c.previousSibling,h=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d||"/&"===d)if(0===h)break;else h--;else"$"!==d&&"$?"!==d&&"$~"!==d&&"$!"!==d&&"&"!==d||h++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;e.firstChild;)f.insertBefore(e.firstChild,c);g.data="$";g._reactRetry&&requestAnimationFrame(g._reactRetry)}}a.length=0};
$RC=function(a,b){if(b=document.getElementById(b))(a=document.getElementById(a))?(a.previousSibling.data="$~",$RB.push(a,b),2===$RB.length&&("number"!==typeof $RT?requestAnimationFrame($RV.bind(null,$RB)):(a=performance.now(),setTimeout($RV.bind(null,$RB),2300>a&&2E3<a?2300-a:$RT+300-a)))):b.parentNode.removeChild(b)};$RC("B:0","S:0")</script><div hidden id="S:1"><script>window.__reactRouterContext.streamController.close();</script></div><script>$RC("B:1","S:1")</script></body></html>