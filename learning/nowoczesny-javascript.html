<!DOCTYPE html><html lang="pl"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="modulepreload" href="/fetch.js"/><link rel="icon" href="/favicon.svg" sizes="any" type="image/svg+xml"/><link rel="preload" as="style" href="/assets/styles-CW_jm-wz.css"/><link rel="preload prefetch" href="/fonts/geist.ttf" as="font" type="font/ttf" crossorigin="anonymous"/><title>Renesans w JS, czyli nowoczesny JavaScript - Jakub Szpil</title><meta name="description" content="JavaScript jest językiem programowania, który jest powszechnie stosowany do tworzenia dynamicznych i interaktywnych stron internetowych. W ciągu ostatnich lat JavaScript znacznie ewoluował, wprowadzając nowe funkcje i poprawiając istniejące mechanizmy. W tym kursie omówimy najważniejsze elementy nowoczesnego JavaScript, w tym ES6 i nowsze."/><meta name="keywords" content="javascript,kurs,wprowadzenie,przewodnik,web,frontend,learning"/><meta property="article:published_time" content="2024-06-30T00:00:00.000Z"/><meta property="og:type" content="article"/><meta property="og:url" content="https://jakubszpil.github.io/learning/nowoczesny-javascript/"/><meta property="og:title" content="Renesans w JS, czyli nowoczesny JavaScript - Jakub Szpil"/><meta property="og:description" content="JavaScript jest językiem programowania, który jest powszechnie stosowany do tworzenia dynamicznych i interaktywnych stron internetowych. W ciągu ostatnich lat JavaScript znacznie ewoluował, wprowadzając nowe funkcje i poprawiając istniejące mechanizmy. W tym kursie omówimy najważniejsze elementy nowoczesnego JavaScript, w tym ES6 i nowsze."/><meta property="twitter:card" content="summary_large_image"/><meta property="twitter:url" content="https://jakubszpil.github.io/learning/nowoczesny-javascript/"/><meta property="twitter:title" content="Renesans w JS, czyli nowoczesny JavaScript - Jakub Szpil"/><meta property="twitter:description" content="JavaScript jest językiem programowania, który jest powszechnie stosowany do tworzenia dynamicznych i interaktywnych stron internetowych. W ciągu ostatnich lat JavaScript znacznie ewoluował, wprowadzając nowe funkcje i poprawiając istniejące mechanizmy. W tym kursie omówimy najważniejsze elementy nowoczesnego JavaScript, w tym ES6 i nowsze."/><link rel="modulepreload" href="/assets/manifest-88d713c3.js"/><link rel="modulepreload" href="/assets/entry.client-D07Jc1yP.js"/><link rel="modulepreload" href="/assets/jsx-runtime-D_zvdyIk.js"/><link rel="modulepreload" href="/assets/chunk-OIYGIGL5-Rdhby1S0.js"/><link rel="modulepreload" href="/assets/index-DJQXGD61.js"/><link rel="modulepreload" href="/assets/root-DtrRPq6W.js"/><link rel="modulepreload" href="/assets/layout-DVWCjRNU.js"/><link rel="modulepreload" href="/assets/button-BMGgmMxT.js"/><link rel="modulepreload" href="/assets/link-with-prefetch-BIs6hVLd.js"/><link rel="modulepreload" href="/assets/icons-BBGQWBin.js"/><link rel="modulepreload" href="/assets/socials-DGthjeXP.js"/><link rel="modulepreload" href="/assets/date-NK96Yl5Q.js"/><link rel="modulepreload" href="/assets/not-found-CGoFJWhv.js"/><link rel="modulepreload" href="/assets/seo-Do91G143.js"/><link rel="modulepreload" href="/assets/course-details-DLJ6fZBl.js"/><link rel="modulepreload" href="/assets/categories-BBucIGjV.js"/><link rel="modulepreload" href="/assets/edit-resource-Bp0MeTOm.js"/><link rel="modulepreload" href="/assets/banner-DCe0eTPI.js"/><link rel="modulepreload" href="/assets/compress-C_V_4BTm.js"/><link rel="modulepreload" href="/assets/creation-date-x1jkwlYO.js"/><link rel="stylesheet" href="/assets/styles-CW_jm-wz.css"/><script>globalThis.timestamp=1760393280819</script><script>let k="theme";let t="dark";let s=localStorage;let c=document.documentElement.classList;let v=s.getItem(k);if(v===null||v==="SYSTEM")matchMedia("(prefers-color-scheme:dark)").matches?c.add(t):c.remove(t);else if(v==="DARK")c.add(t);else if(v==="LIGHT")c.remove(t);else s.removeItem(k);</script><script type="module" src="/fetch.js"></script></head><body style="-webkit-tap-highlight-color:transparent"><header class="sticky w-full bg-background top-0 left-0 z-50 lg:relative"><div class="container pb-3! pt-4! flex justify-between items-center px-3! lg:py-6!"><a data-slot="button" class="button button--variant-ghost button--size-sm font-bold" href="/" data-discover="true">jakubszpil</a><div class="flex flex-1 justify-end items-center sm:gap-1"><nav class="hidden items-center lg:flex"><a data-slot="button" class="button button--variant-ghost button--size-sm" href="/" data-discover="true">🏠 Strona główna</a><a data-slot="button" class="button button--variant-ghost button--size-sm" href="/blog" data-discover="true">📝 Blog</a><a data-slot="button" class="button button--variant-ghost button--size-sm" href="/learning" data-discover="true">🏫 Learning</a><a data-slot="button" class="button button--variant-ghost button--size-sm" href="/portfolio" data-discover="true">🛠️ Portfolio</a><a data-slot="button" class="button button--variant-ghost button--size-sm" href="/me" data-discover="true">🙋‍♂️ O mnie</a></nav><a data-slot="button" class="button button--variant-ghost button--size-icon inline-flex items-center justify-center" aria-label="Szukaj" title="Szukaj (CTRL+K)" href="/search" data-discover="true"><span class="sr-only">Szukaj</span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="size-6"><path d="M10 10m-7 0a7 7 0 1 0 14 0a7 7 0 1 0 -14 0"></path><path d="M21 21l-6 -6"></path></svg></a><div class="hidden xs:flex items-center sm:gap-1"><a href="https://www.linkedin.com/in/jakubszpil/" target="_blank" rel="noreferrer" data-slot="button" class="button button--variant-ghost button--size-icon inline-flex items-center gap-1 no-underline" title="LinkedIn" aria-label="LinkedIn"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="size-6"><path d="M8 11v5"></path><path d="M8 8v.01"></path><path d="M12 16v-5"></path><path d="M16 16v-3a2 2 0 1 0 -4 0"></path><path d="M3 7a4 4 0 0 1 4 -4h10a4 4 0 0 1 4 4v10a4 4 0 0 1 -4 4h-10a4 4 0 0 1 -4 -4z"></path></svg><span class="sr-only">LinkedIn</span></a><a href="https://github.com/jakubszpil/" target="_blank" rel="noreferrer" data-slot="button" class="button button--variant-ghost button--size-icon inline-flex items-center gap-1 no-underline" title="GitHub" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="size-6"><path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5"></path></svg><span class="sr-only">GitHub</span></a></div><button data-slot="dropdown-menu-trigger" class="button button--variant-ghost button--size-icon cursor-pointer" title="Zmień motyw" type="button" id="radix-_R_4ej5_" aria-haspopup="menu" aria-expanded="false" data-state="closed"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="size-6"><path d="M9.173 14.83a4 4 0 1 1 5.657 -5.657"></path><path d="M11.294 12.707l.174 .247a7.5 7.5 0 0 0 8.845 2.492a9 9 0 0 1 -14.671 2.914"></path><path d="M3 12h1"></path><path d="M12 3v1"></path><path d="M5.6 5.6l.7 .7"></path><path d="M3 21l18 -18"></path></svg></button><button data-slot="button" class="button button--variant-link button--size-icon inline-flex items-center justify-center relative z-50 lg:hidden" aria-label="Otwórz menu"><span class="sr-only">Otwórz menu</span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="size-6 text-black! dark:text-white!"><path d="M4 6l16 0"></path><path d="M4 12l16 0"></path><path d="M4 18l16 0"></path></svg></button></div></div></header><main><header class="prose container"><h1 class="mb-5">Renesans w JS, czyli nowoczesny JavaScript</h1><div class="text-xs sm:text-sm my-6"><div class="inline-block" title="Data opublikowania"><span class="mr-0.5">📆</span><span class="hidden">Data opublikowania:</span><time>30 czerwca 2024</time></div><span class="ml-2 mr-1">/</span><div class="inline-block sm:inline" title="Czas potrzebny na przeczytanie"><span class="mr-0.5">⌛</span><span class="hidden">Czas potrzebny na przeczytanie:</span>18 minut<!-- --> czytania</div></div><div class="flex items-center gap-3 flex-wrap"><a data-slot="button" class="button button--variant-secondary button--size-sm no-underline!" href="/learning/kategorie/javascript" data-discover="true">JavaScript</a></div></header><article class="prose container pt-0 prose-emerald"><p>Witaj w świecie <strong>nowoczesnego JavaScriptu</strong>! 🚀 Jeśli HTML to szkielet strony, a CSS to jej wygląd, to JavaScript jest sercem i mózgiem - sprawia, że strona ożywa, staje się interaktywna i dynamiczna. W ciągu ostatnich lat JavaScript przeszedł prawdziwy "renesans". Dzięki wprowadzeniu standardu <strong>ES6</strong> (ECMAScript 2015) i kolejnych aktualizacji, pisanie kodu w JS stało się znacznie przyjemniejsze, bezpieczniejsze i bardziej efektywne.</p>
<p>Ten przewodnik zabierze Cię w podróż po najważniejszych nowościach, które musisz znać, aby pisać <strong>nowoczesny JavaScript</strong>. Nie martw się, jeśli jesteś początkujący/a - wszystko wyjaśnimy krok po kroku, z przykładami i analogiami, byś mógł/mogła od razu zastosować nową wiedzę w praktyce. Czas unowocześnić swoje umiejętności! ✨</p>
<h2 id="spis-treści" class="scroll-mt-20 lg:scroll-mt-10"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#spis-treści">>></a>Spis treści</h2>
<ol>
<li><a href="#zmienne-let-const-i-zakresy-blokowe--po%C5%BCegnanie-z-var">Zmienne: <code>let</code>, <code>const</code> i zakresy blokowe - pożegnanie z <code>var</code>?</a></li>
<li><a href="#funkcje-strza%C5%82kowe-arrow-functions-i-ich-zastosowania--kr%C3%B3cej-i-czytelniej">Funkcje strzałkowe (Arrow Functions) i ich zastosowania - krócej i czytelniej</a></li>
<li><a href="#szablony-string%C3%B3w-template-literals--%C5%82atwiejsza-praca-z-tekstem">Szablony stringów (Template Literals) - łatwiejsza praca z tekstem</a></li>
<li><a href="#destrukturyzacja-tablic-i-obiekt%C3%B3w--wyci%C4%85gnij-to-czego-potrzebujesz">Destrukturyzacja tablic i obiektów - wyciągnij to, czego potrzebujesz</a></li>
<li><a href="#spread-i-rest-operator---elastyczno%C5%9B%C4%87-w-manipulacji-danymi">Spread i Rest Operator (<code>...</code>) - elastyczność w manipulacji danymi</a></li>
<li><a href="#promise-api-i-obs%C5%82uga-asynchroniczno%C5%9Bci--opowiadaj-historie-o-przysz%C5%82o%C5%9Bci">Promise API i obsługa asynchroniczności - opowiadaj historie o przyszłości</a></li>
<li><a href="#asyncawait--nowoczesna-obs%C5%82uga-kodu-asynchronicznego--pisz-asynchronicznie-my%C5%9Bl-synchronicznie">Async/await - nowoczesna obsługa kodu asynchronicznego - pisz asynchronicznie, myśl synchronicznie</a></li>
<li><a href="#zadania-do-wykonania-sprawd%C5%BA-swoj%C4%85-wiedz%C4%99">Zadania do wykonania: Sprawdź swoją wiedzę!</a></li>
</ol>
<hr>
<h2 id="zmienne-let-const-i-zakresy-blokowe---pożegnanie-z-var" class="scroll-mt-20 lg:scroll-mt-10"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#zmienne-let-const-i-zakresy-blokowe---pożegnanie-z-var">>></a>Zmienne: <code>let</code>, <code>const</code> i zakresy blokowe - pożegnanie z <code>var</code>?</h2>
<p>W starszych wersjach JavaScriptu zmienne deklarowaliśmy wyłącznie za pomocą słowa kluczowego <code>var</code>. Często prowadziło to do pomyłek i trudnych do wykrycia błędów. Nowoczesny JavaScript wprowadza dwa nowe sposoby deklarowania zmiennych: <strong><code>let</code></strong> i <strong><code>const</code></strong>, które znacznie poprawiają bezpieczeństwo i przewidywalność kodu.</p>
<h3 id="zakres-blokowy-block-scope" class="scroll-mt-20 lg:scroll-mt-10"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#zakres-blokowy-block-scope">>>></a>Zakres blokowy (<code>block scope</code>)</h3>
<p>To kluczowa różnica! Zmienne zadeklarowane za pomocą <code>let</code> i <code>const</code> mają <strong>zakres blokowy</strong>. Co to znaczy? Oznaczają, że zmienna istnieje tylko w obrębie najbliższego <strong>bloku kodu</strong>, czyli wszystko, co znajduje się między klamrowymi nawiasami <code>{ ... }</code>.</p>
<p>Pomyśl o tym jak o specjalnej, prywatnej przestrzeni. Jeśli zmienna <code>x</code> jest zadeklarowana wewnątrz bloku <code>if</code>, będzie dostępna tylko w tym bloku. Próba użycia jej poza nim spowoduje błąd. To chroni Cię przed przypadkowym nadpisaniem zmiennych o tej samej nazwie w innej części kodu.</p>
<p><strong>Przykład:</strong></p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) {
  <span class="hljs-keyword">let</span> x = <span class="hljs-number">5</span>; <span class="hljs-comment">// x istnieje tylko wewnątrz tego bloku if</span>
  <span class="hljs-keyword">const</span> y = <span class="hljs-number">10</span>; <span class="hljs-comment">// y również istnieje tylko wewnątrz tego bloku</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x); <span class="hljs-comment">// Wyświetli: 5 (dostępne, bo jesteśmy w bloku)</span>
}
<span class="hljs-comment">// console.log(x); // WYWOŁA BŁĄD! ReferenceError: x is not defined</span>
<span class="hljs-comment">// console.log(y); // WYWOŁA BŁĄD! ReferenceError: y is not defined</span>
</code></pre>
<p>Dla porównania, <code>var</code> ma <strong>zakres funkcyjny</strong> (function scope), co oznacza, że zmienna zadeklarowana w funkcji jest dostępna w całej funkcji, ale poza funkcją jest dostępna globalnie, co jest źródłem wielu problemów. Dlatego w nowoczesnym kodzie <strong>zdecydowanie unikamy <code>var</code></strong>.</p>
<h3 id="różnice-między-let-const-i-var" class="scroll-mt-20 lg:scroll-mt-10"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#różnice-między-let-const-i-var">>>></a>Różnice między <code>let</code>, <code>const</code> i <code>var</code></h3>
<ul>
<li>
<p><strong><code>let</code></strong>:</p>
<ul>
<li><strong>Deklaruje zmienną</strong>, której wartość może być <strong>zmieniana</strong> w dowolnym momencie.</li>
<li>Ma <strong>zakres blokowy</strong>.</li>
<li>Nie można jej ponownie zadeklarować w tym samym bloku (np. <code>let x = 5; let x = 10;</code> to błąd), ale można zmienić jej wartość (<code>x = 10;</code>).</li>
<li>Używaj <code>let</code>, gdy wiesz, że wartość zmiennej będzie się zmieniać (np. licznik w pętli).</li>
</ul>
</li>
<li>
<p><strong><code>const</code></strong>:</p>
<ul>
<li>Deklaruje <strong>stałą</strong>, której wartość musi być <strong>przypisana od razu</strong> i <strong>nie może być zmieniana</strong> później.</li>
<li>Ma <strong>zakres blokowy</strong>.</li>
<li>Jeśli przypiszesz do <code>const</code> obiekt lub tablicę, nie możesz przypisać do niej <em>nowego</em> obiektu/tablicy, ale możesz <strong>modyfikować zawartość</strong> tego obiektu/tablicy (np. dodawać lub usuwać elementy). <code>const</code> gwarantuje, że referencja (wskaźnik) do obiektu pozostaje taka sama, ale nie "zamraża" samego obiektu.</li>
<li>Używaj <code>const</code>, gdy wartość zmiennej nie powinna się zmieniać. To jest domyślny wybór w nowoczesnym JS, chyba że potrzebujesz <code>let</code>.</li>
</ul>
</li>
<li>
<p><strong><code>var</code></strong>:</p>
<ul>
<li><strong>Ma zakres funkcyjny</strong> (lub globalny, jeśli jest poza funkcją).</li>
<li>Jest podatny na <strong>hoisting</strong> (podnoszenie deklaracji), co oznacza, że deklaracja zmiennej jest "przenoszona" na początek zakresu, co może prowadzić do nieintuicyjnych zachowań.</li>
<li>Można go <strong>wielokrotnie deklarować</strong> w tym samym zakresie, co łatwo prowadzi do przypadkowych nadpisań.</li>
<li><strong>Unikaj używania <code>var</code> w nowym kodzie!</strong></li>
</ul>
</li>
</ul>
<p><strong>Przykład <code>const</code> z obiektem/tablicą:</strong></p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> tablica = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
tablica.<span class="hljs-title function_">push</span>(<span class="hljs-number">4</span>); <span class="hljs-comment">// DOZWOLONE! Zmieniamy zawartość tablicy, nie przypisujemy nowej tablicy.</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(tablica); <span class="hljs-comment">// Wyświetli: [1, 2, 3, 4]</span>

<span class="hljs-comment">// tablica = [5, 6]; // WYWOŁA BŁĄD! TypeError: Assignment to constant variable.</span>
<span class="hljs-comment">// Próbujesz przypisać zupełnie nową tablicę do stałej referencji.</span>

<span class="hljs-keyword">const</span> osoba = { <span class="hljs-attr">imie</span>: <span class="hljs-string">"Anna"</span>, <span class="hljs-attr">wiek</span>: <span class="hljs-number">28</span> };
osoba.<span class="hljs-property">wiek</span> = <span class="hljs-number">29</span>; <span class="hljs-comment">// DOZWOLONE! Zmieniamy właściwość obiektu, nie przypisujemy nowego obiektu.</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(osoba); <span class="hljs-comment">// Wyświetli: { imie: "Anna", wiek: 29 }</span>

<span class="hljs-comment">// osoba = { nazwisko: "Nowak" }; // WYWOŁA BŁĄD!</span>
</code></pre>
<hr>
<h2 id="funkcje-strzałkowe-arrow-functions-i-ich-zastosowania---krócej-i-czytelniej" class="scroll-mt-20 lg:scroll-mt-10"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#funkcje-strzałkowe-arrow-functions-i-ich-zastosowania---krócej-i-czytelniej">>></a>Funkcje strzałkowe (Arrow Functions) i ich zastosowania - krócej i czytelniej</h2>
<p>Funkcje strzałkowe to zwięzła alternatywa dla tradycyjnych funkcji JavaScript, która została wprowadzona w ES6. Są nie tylko krótsze, ale także rozwiązują pewien problem z kontekstem <code>this</code>, który często mylił początkujących programistów.</p>
<h3 id="składnia-funkcji-strzałkowej" class="scroll-mt-20 lg:scroll-mt-10"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#składnia-funkcji-strzałkowej">>>></a>Składnia funkcji strzałkowej</h3>
<p>Największą zaletą funkcji strzałkowych jest ich zwięzła składnia, zwłaszcza dla prostych funkcji.</p>
<ul>
<li>
<p><strong>Szybszy zapis (szczególnie dla funkcji jedno-liniowych):</strong>
Jeśli funkcja składa się tylko z jednej instrukcji, która zwraca wartość, możesz pominąć nawiasy klamrowe <code>{}</code> i słowo kluczowe <code>return</code>.</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// Tradycyjna funkcja</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">dodajStara</span>(<span class="hljs-params">a, b</span>) {
  <span class="hljs-keyword">return</span> a + b;
}

<span class="hljs-comment">// Funkcja strzałkowa (krótszy zapis)</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">dodaj</span> = (<span class="hljs-params">a, b</span>) => a + b;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">dodaj</span>(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">// Wyświetli: 8</span>

<span class="hljs-comment">// Funkcja z jednym argumentem (można pominąć nawiasy wokół argumentu)</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">powitanie</span> = (<span class="hljs-params">imie</span>) => <span class="hljs-string">`Cześć, <span class="hljs-subst">${imie}</span>!`</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">powitanie</span>(<span class="hljs-string">"Ola"</span>)); <span class="hljs-comment">// Wyświetli: Cześć, Ola!</span>

<span class="hljs-comment">// Funkcja bez argumentów (konieczne puste nawiasy)</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">powiedzHello</span> = (<span class="hljs-params"></span>) => <span class="hljs-string">"Hello!"</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">powiedzHello</span>()); <span class="hljs-comment">// Wyświetli: Hello!</span>
</code></pre>
</li>
<li>
<p><strong>Brak własnego obiektu <code>arguments</code>:</strong> Funkcje strzałkowe nie mają własnego obiektu <code>arguments</code> (który zawiera wszystkie argumenty przekazane do funkcji). Jeśli go potrzebujesz, użyj <strong>rest operatora</strong> (<code>...</code>), o którym powiemy później.</p>
</li>
<li>
<p><strong>Brak możliwości użycia jako konstruktor:</strong> Nie możesz użyć funkcji strzałkowej do tworzenia nowych obiektów za pomocą słowa kluczowego <code>new</code>.</p>
</li>
</ul>
<h3 id="funkcje-strzałkowe-a-kontekst-this" class="scroll-mt-20 lg:scroll-mt-10"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#funkcje-strzałkowe-a-kontekst-this">>>></a>Funkcje strzałkowe a kontekst <code>this</code></h3>
<p>To jest jeden z najważniejszych powodów, dla których wprowadzono funkcje strzałkowe. W tradycyjnych funkcjach, wartość <code>this</code> zależy od tego, jak funkcja jest wywoływana. To prowadziło do częstych błędów, zwłaszcza w callbackach (funkcjach wywoływanych przez inne funkcje, np. w <code>setTimeout</code> czy w obsłudze zdarzeń).</p>
<p>Funkcje strzałkowe rozwiązują ten problem: <strong>nie mają własnego <code>this</code></strong>. Zamiast tego, <strong>dziedziczą <code>this</code> z otoczenia, w którym zostały zadeklarowane</strong> (tzw. leksykalny <code>this</code>).</p>
<p><strong>Przykład problemu ze <code>this</code> w tradycyjnych funkcjach:</strong></p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// Tradycyjna funkcja, która "gubi" kontekst this</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">TimerProblem</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">sekundy</span> = <span class="hljs-number">0</span>;
  <span class="hljs-built_in">setInterval</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-comment">// Tutaj 'this' nie odnosi się do obiektu TimerProblem,</span>
    <span class="hljs-comment">// ale do obiektu globalnego (np. window w przeglądarce) lub jest undefined w trybie 'strict mode'</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">sekundy</span>++; <span class="hljs-comment">// To nie zadziała tak, jak byśmy chcieli!</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">sekundy</span>);
  }, <span class="hljs-number">1000</span>);
}
<span class="hljs-comment">// new TimerProblem(); // W konsoli prawdopodobnie zobaczysz NaN lub błąd</span>
</code></pre>
<p><strong>Rozwiązanie z funkcją strzałkową:</strong></p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">TimerPoprawny</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">sekundy</span> = <span class="hljs-number">0</span>;
  <span class="hljs-comment">// Funkcja strzałkowa dziedziczy 'this' z TimerPoprawny (czyli z obiektu TimerPoprawny)</span>
  <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">sekundy</span>++;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Sekundy: <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.sekundy}</span>`</span>);
  }, <span class="hljs-number">1000</span>);
}
<span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerPoprawny</span>(); <span class="hljs-comment">// Będzie poprawnie liczyć sekundy: Sekundy: 1, Sekundy: 2, itd.</span>
</code></pre>
<p>Dzięki temu funkcje strzałkowe są idealne do użycia w callbackach, metodach obiektów (choć nie jako metody obiektów najwyższego poziomu, bo wtedy <code>this</code> wskazałoby na <code>window</code>), czy w sytuacjach, gdzie chcesz, aby <code>this</code> zachowało kontekst nadrzędny.</p>
<hr>
<h2 id="szablony-stringów-template-literals---łatwiejsza-praca-z-tekstem" class="scroll-mt-20 lg:scroll-mt-10"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#szablony-stringów-template-literals---łatwiejsza-praca-z-tekstem">>></a>Szablony stringów (Template Literals) - łatwiejsza praca z tekstem</h2>
<p>Szablony stringów, wprowadzone w ES6, to potężne narzędzie do tworzenia ciągów znaków (stringów). Zastępują tradycyjne łączenie stringów za pomocą operatora <code>+</code> i oferują znacznie większą elastyczność i czytelność. Używamy ich, otaczając tekst <strong>backtickami</strong> (apostrofami wstecznymi) <code> </code> zamiast pojedynczych lub podwójnych cudzysłowów.</p>
<h3 id="interpolacja-i-wielolinijkowość" class="scroll-mt-20 lg:scroll-mt-10"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#interpolacja-i-wielolinijkowość">>>></a>Interpolacja i wielolinijkowość</h3>
<ul>
<li>
<p><strong>Interpolacja zmiennych i wyrażeń:</strong>
Możesz łatwo osadzać zmienne lub dowolne wyrażenia JavaScript bezpośrednio w stringu, używając składni <code>${...}</code>. To znacznie ułatwia budowanie dynamicznych komunikatów.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> imie = <span class="hljs-string">"Alicja"</span>;
<span class="hljs-keyword">const</span> wiek = <span class="hljs-number">30</span>;

<span class="hljs-comment">// Stary sposób: męczące łączenie stringów</span>
<span class="hljs-keyword">const</span> infoStare = <span class="hljs-string">"Mam na imię "</span> + imie + <span class="hljs-string">" i mam "</span> + wiek + <span class="hljs-string">" lat."</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(infoStare); <span class="hljs-comment">// Wyświetli: Mam na imię Alicja i mam 30 lat.</span>

<span class="hljs-comment">// Nowy sposób z szablonami stringów: czytelniej i prościej!</span>
<span class="hljs-keyword">const</span> infoNowe = <span class="hljs-string">`Mam na imię <span class="hljs-subst">${imie}</span> i mam <span class="hljs-subst">${wiek}</span> lat.`</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(infoNowe); <span class="hljs-comment">// Wyświetli: Mam na imię Alicja i mam 30 lat.</span>

<span class="hljs-comment">// Możesz umieszczać dowolne wyrażenia JavaScript:</span>
<span class="hljs-keyword">const</span> cena = <span class="hljs-number">10.5</span>;
<span class="hljs-keyword">const</span> ilosc = <span class="hljs-number">2</span>;
<span class="hljs-keyword">const</span> rachunek = <span class="hljs-string">`Koszt zakupu: <span class="hljs-subst">${cena * ilosc}</span> zł.`</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(rachunek); <span class="hljs-comment">// Wyświetli: Koszt zakupu: 21 zł.</span>
</code></pre>
</li>
<li>
<p><strong>Łatwe tworzenie tekstów wielolinijkowych:</strong>
Koniec z dodawaniem <code>n</code> do każdej linii! W szablonach stringów możesz po prostu nacisnąć Enter, a tekst zachowa formatowanie z nowymi liniami. Jest to szczególnie przydatne przy generowaniu fragmentów HTML bezpośrednio w JavaScript.</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// Stary sposób: brzydkie i niewygodne</span>
<span class="hljs-keyword">const</span> htmlStare =
  <span class="hljs-string">"&#x3C;div>\n  &#x3C;h1>Witaj!&#x3C;/h1>\n  &#x3C;p>To jest wielolinijkowy tekst.&#x3C;/p>\n&#x3C;/div>"</span>;

<span class="hljs-comment">// Nowy sposób: super czytelne!</span>
<span class="hljs-keyword">const</span> htmlNowe = <span class="hljs-string">`
  &#x3C;div>
    &#x3C;h1>Witaj!&#x3C;/h1>
    &#x3C;p>To jest wielolinijkowy tekst. I kolejna linia w tym samym akapicie.&#x3C;/p>
  &#x3C;/div>
`</span>;

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(htmlNowe);
</code></pre>
</li>
</ul>
<h3 id="dodatkowe-możliwości" class="scroll-mt-20 lg:scroll-mt-10"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#dodatkowe-możliwości">>>></a>Dodatkowe możliwości</h3>
<p>Szablony stringów wspierają także tzw. <strong>tagowane szablony</strong> (<code>tagged templates</code>), które pozwalają na zaawansowaną manipulację tekstem przed jego finalnym utworzeniem. Możesz zdefiniować funkcję ("tag"), która będzie przetwarzać części stringu i wartości zmiennych. Jest to bardziej zaawansowana funkcja, używana np. do tłumaczeń, walidacji, bezpiecznego generowania HTML (zapobieganie XSS) czy formatowania danych.</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// Przykład funkcji "tagującej"</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">upper</span>(<span class="hljs-params">strings, ...values</span>) {
  <span class="hljs-comment">// 'strings' to tablica tekstów, 'values' to tablica zmiennych</span>
  <span class="hljs-keyword">let</span> wynik = strings[<span class="hljs-number">0</span>];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &#x3C; values.<span class="hljs-property">length</span>; i++) {
    wynik += values[i].<span class="hljs-title function_">toUpperCase</span>() + strings[i + <span class="hljs-number">1</span>]; <span class="hljs-comment">// Zamienia zmienne na duże litery</span>
  }
  <span class="hljs-keyword">return</span> wynik;
}

<span class="hljs-keyword">const</span> imie = <span class="hljs-string">"Kasia"</span>;
<span class="hljs-keyword">const</span> wiek = <span class="hljs-number">20</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(upper<span class="hljs-string">`Cześć, <span class="hljs-subst">${imie}</span>! Masz <span class="hljs-subst">${wiek}</span> lat?`</span>); <span class="hljs-comment">// Wyświetli: Cześć, KASIA! Masz 20 lat?</span>
</code></pre>
<p>W tym przykładzie funkcja <code>upper</code> została "przypięta" do szablonu stringu i zmodyfikowała zmienną <code>imie</code> na wielkie litery.</p>
<hr>
<h2 id="destrukturyzacja-tablic-i-obiektów---wyciągnij-to-czego-potrzebujesz" class="scroll-mt-20 lg:scroll-mt-10"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#destrukturyzacja-tablic-i-obiektów---wyciągnij-to-czego-potrzebujesz">>></a>Destrukturyzacja tablic i obiektów - wyciągnij to, czego potrzebujesz</h2>
<p>Destrukturyzacja to potężna i bardzo często używana funkcja w nowoczesnym JavaScript. Pozwala na "rozpakowanie" wartości z tablic lub właściwości z obiektów do oddzielnych zmiennych w bardzo zwięzły i czytelny sposób. Upraszcza kod i czyni go bardziej deklaratywnym.</p>
<h3 id="destrukturyzacja-tablic" class="scroll-mt-20 lg:scroll-mt-10"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#destrukturyzacja-tablic">>>></a>Destrukturyzacja tablic</h3>
<p>Pozwala na szybkie przypisanie wartości z tablicy do zmiennych, bazując na ich pozycji.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> kolory = [<span class="hljs-string">"czerwony"</span>, <span class="hljs-string">"zielony"</span>, <span class="hljs-string">"niebieski"</span>];

<span class="hljs-comment">// Stary sposób:</span>
<span class="hljs-comment">// const kolor1 = kolory[0];</span>
<span class="hljs-comment">// const kolor2 = kolory[1];</span>

<span class="hljs-comment">// Nowy sposób z destrukturyzacją tablic:</span>
<span class="hljs-keyword">const</span> [pierwszyKolor, drugiKolor, trzeciKolor] = kolory;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pierwszyKolor); <span class="hljs-comment">// Wyświetli: czerwony</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(drugiKolor); <span class="hljs-comment">// Wyświetli: zielony</span>

<span class="hljs-comment">// Można pomijać niektóre elementy (używając przecinków):</span>
<span class="hljs-keyword">const</span> [a, , b] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]; <span class="hljs-comment">// Pomijamy drugi element (2)</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a, b); <span class="hljs-comment">// Wyświetli: 1 3</span>

<span class="hljs-comment">// Można przypisać wartości domyślne, jeśli element nie istnieje:</span>
<span class="hljs-keyword">const</span> [x, y, z = <span class="hljs-string">"domyślny"</span>] = [<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x, y, z); <span class="hljs-comment">// Wyświetli: A B domyślny</span>

<span class="hljs-comment">// Można zbierać pozostałe elementy do nowej tablicy (rest operator - patrz dalej):</span>
<span class="hljs-keyword">const</span> [pierwszy, ...resztaKolorow] = kolory;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pierwszy); <span class="hljs-comment">// Wyświetli: czerwony</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(resztaKolorow); <span class="hljs-comment">// Wyświetli: ["zielony", "niebieski"]</span>
</code></pre>
<h3 id="destrukturyzacja-obiektów" class="scroll-mt-20 lg:scroll-mt-10"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#destrukturyzacja-obiektów">>>></a>Destrukturyzacja obiektów</h3>
<p>Pozwala na przypisanie wartości z obiektu do zmiennych na podstawie nazw ich <strong>kluczy (właściwości)</strong>. Kolejność nie ma znaczenia, liczy się nazwa klucza.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> samochod = { <span class="hljs-attr">marka</span>: <span class="hljs-string">"Ford"</span>, <span class="hljs-attr">model</span>: <span class="hljs-string">"Focus"</span>, <span class="hljs-attr">rok</span>: <span class="hljs-number">2018</span> };

<span class="hljs-comment">// Stary sposób:</span>
<span class="hljs-comment">// const markaSamochodu = samochod.marka;</span>
<span class="hljs-comment">// const modelSamochodu = samochod.model;</span>

<span class="hljs-comment">// Nowy sposób z destrukturyzacją obiektów:</span>
<span class="hljs-keyword">const</span> { marka, model } = samochod;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(marka); <span class="hljs-comment">// Wyświetli: Ford</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(model); <span class="hljs-comment">// Wyświetli: Focus</span>

<span class="hljs-comment">// Można przypisać wartości domyślne, jeśli właściwość nie istnieje:</span>
<span class="hljs-keyword">const</span> { <span class="hljs-attr">marka</span>: m, kolor = <span class="hljs-string">"czarny"</span> } = samochod; <span class="hljs-comment">// 'kolor' nie istnieje w obiekcie 'samochod'</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(m, kolor); <span class="hljs-comment">// Wyświetli: Ford czarny</span>

<span class="hljs-comment">// Można zmienić nazwę zmiennej, do której przypisujemy wartość:</span>
<span class="hljs-keyword">const</span> { <span class="hljs-attr">marka</span>: nazwaMarki, <span class="hljs-attr">model</span>: typModelu } = samochod;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(nazwaMarki, typModelu); <span class="hljs-comment">// Wyświetli: Ford Focus</span>

<span class="hljs-comment">// Można też zbierać pozostałe właściwości do nowego obiektu (rest operator - patrz dalej):</span>
<span class="hljs-keyword">const</span> { rok, ...resztaSamochodu } = samochod;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(rok); <span class="hljs-comment">// Wyświetli: 2018</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(resztaSamochodu); <span class="hljs-comment">// Wyświetli: { marka: "Ford", model: "Focus" }</span>
</code></pre>
<p>Destrukturyzacja jest szczególnie przydatna w funkcjach, gdy chcesz łatwo wyciągnąć konkretne dane z obiektów konfiguracyjnych lub z wyników API.</p>
<hr>
<h2 id="spread-i-rest-operator----elastyczność-w-manipulacji-danymi" class="scroll-mt-20 lg:scroll-mt-10"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#spread-i-rest-operator----elastyczność-w-manipulacji-danymi">>></a>Spread i Rest Operator (<code>...</code>) - elastyczność w manipulacji danymi</h2>
<p>Operator <code>...</code> (trzy kropki) jest jednym z najbardziej uniwersalnych i potężnych narzędzi w nowoczesnym JavaScript. Nazywany jest <strong>operatorem spread</strong> lub <strong>operatorem rest</strong>, w zależności od kontekstu, w jakim jest używany.</p>
<h3 id="spread-operator-operator-rozproszenia" class="scroll-mt-20 lg:scroll-mt-10"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#spread-operator-operator-rozproszenia">>>></a>Spread Operator (operator rozproszenia)</h3>
<p>Gdy używasz <code>...</code> do <strong>rozbicia</strong> elementów tablicy lub właściwości obiektu na pojedyncze elementy, mówimy o <strong>operatorze spread</strong>. Jest to jak "rozłożenie" zawartości kolekcji. 🌐</p>
<p><strong>Zastosowania Spread Operatora:</strong></p>
<ul>
<li>
<p><strong>Kopiowanie i łączenie tablic:</strong> Tworzenie płytkich kopii tablic lub łączenie ich bez modyfikowania oryginalnych.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> cyfry = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-keyword">const</span> noweCyfry = [...cyfry, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]; <span class="hljs-comment">// Rozwija [1, 2, 3] do 1, 2, 3, a potem dodaje 4, 5</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(noweCyfry); <span class="hljs-comment">// Wyświetli: [1, 2, 3, 4, 5]</span>

<span class="hljs-keyword">const</span> tablica1 = [<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>];
<span class="hljs-keyword">const</span> tablica2 = [<span class="hljs-string">"c"</span>, <span class="hljs-string">"d"</span>];
<span class="hljs-keyword">const</span> polaczoneTablice = [...tablica1, ...tablica2];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(polaczoneTablice); <span class="hljs-comment">// Wyświetli: ["a", "b", "c", "d"]</span>
</code></pre>
</li>
<li>
<p><strong>Kopiowanie i łączenie obiektów:</strong> Podobnie jak z tablicami, możesz tworzyć kopie obiektów i łączyć ich właściwości.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> osoba = { <span class="hljs-attr">imie</span>: <span class="hljs-string">"Anna"</span>, <span class="hljs-attr">wiek</span>: <span class="hljs-number">28</span> };
<span class="hljs-keyword">const</span> osobaZZawodem = { ...osoba, <span class="hljs-attr">zawod</span>: <span class="hljs-string">"Programista"</span> };
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(osobaZZawodem); <span class="hljs-comment">// Wyświetli: { imie: "Anna", wiek: 28, zawod: "Programista" }</span>

<span class="hljs-keyword">const</span> daneKontaktowe = { <span class="hljs-attr">email</span>: <span class="hljs-string">"a@example.com"</span>, <span class="hljs-attr">telefon</span>: <span class="hljs-string">"123-456-789"</span> };
<span class="hljs-keyword">const</span> pelneDane = { ...osoba, ...daneKontaktowe };
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pelneDane); <span class="hljs-comment">// Wyświetli: { imie: "Anna", wiek: 28, email: "a@example.com", telefon: "123-456-789" }</span>
</code></pre>
<p>Jeśli klucze się powtarzają, ostatnia wartość nadpisuje poprzednią.</p>
</li>
<li>
<p><strong>Przekazywanie argumentów funkcji:</strong> Możesz rozwijać tablicę jako argumenty funkcji.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sumuj</span>(<span class="hljs-params">a, b, c</span>) {
  <span class="hljs-keyword">return</span> a + b + c;
}
<span class="hljs-keyword">const</span> liczby = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sumuj</span>(...liczby)); <span class="hljs-comment">// Rozwija [10, 20, 30] do sumuj(10, 20, 30), wyświetli: 60</span>
</code></pre>
</li>
</ul>
<h3 id="rest-operator-operator-reszty" class="scroll-mt-20 lg:scroll-mt-10"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#rest-operator-operator-reszty">>>></a>Rest Operator (operator reszty)</h3>
<p>Gdy używasz <code>...</code> do <strong>zbierania</strong> wielu elementów w jedną tablicę (lub właściwości w obiekt), mówimy o <strong>operatorze rest</strong>. Jest to jak "zbieranie" luźnych elementów w jedną kolekcję. 🧺</p>
<p><strong>Zastosowania Rest Operatora:</strong></p>
<ul>
<li>
<p><strong>Zbieranie argumentów funkcji:</strong> Pozwala funkcji przyjmować nieokreśloną liczbę argumentów i traktować je jako tablicę.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">suma</span>(<span class="hljs-params">...liczby</span>) {
  <span class="hljs-comment">// 'liczby' zbiera wszystkie przekazane argumenty w tablicę</span>
  <span class="hljs-keyword">return</span> liczby.<span class="hljs-title function_">reduce</span>(
    <span class="hljs-function">(<span class="hljs-params">akumulator, aktualnaLiczba</span>) =></span> akumulator + aktualnaLiczba,
    <span class="hljs-number">0</span>
  );
}
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">suma</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">// Wyświetli: 6</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">suma</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>)); <span class="hljs-comment">// Wyświetli: 100</span>
</code></pre>
</li>
<li>
<p><strong>W destrukturyzacji (jak widzieliśmy wcześniej):</strong> Zbieranie pozostałych elementów do nowej tablicy lub obiektu.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> [pierwszy, drugi, ...resztaTablicy] = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pierwszy); <span class="hljs-comment">// Wyświetli: 10</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(drugi); <span class="hljs-comment">// Wyświetli: 20</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(resztaTablicy); <span class="hljs-comment">// Wyświetli: [30, 40, 50]</span>

<span class="hljs-keyword">const</span> { imie, ...resztaOsoby } = {
  <span class="hljs-attr">imie</span>: <span class="hljs-string">"Ola"</span>,
  <span class="hljs-attr">wiek</span>: <span class="hljs-number">25</span>,
  <span class="hljs-attr">miasto</span>: <span class="hljs-string">"Warszawa"</span>,
};
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(imie); <span class="hljs-comment">// Wyświetli: Ola</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(resztaOsoby); <span class="hljs-comment">// Wyświetli: { wiek: 25, miasto: "Warszawa" }</span>
</code></pre>
</li>
</ul>
<p>Zarówno spread, jak i rest operator są niezwykle przydatne i sprawiają, że kod jest znacznie bardziej zwięzły i czytelny, szczególnie podczas pracy z tablicami i obiektami.</p>
<hr>
<h2 id="promise-api-i-obsługa-asynchroniczności---opowiadaj-historie-o-przyszłości" class="scroll-mt-20 lg:scroll-mt-10"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#promise-api-i-obsługa-asynchroniczności---opowiadaj-historie-o-przyszłości">>></a>Promise API i obsługa asynchroniczności - opowiadaj historie o przyszłości</h2>
<p>JavaScript jest językiem <strong>jednowątkowym</strong>, co oznacza, że może wykonywać tylko jedną operację w danym momencie. Jednak wiele operacji, takich jak pobieranie danych z internetu, odczyt plików, czy operacje na bazie danych, trwa pewien czas. Gdyby JavaScript musiał czekać na ich zakończenie, strona internetowa by się "zawiesiła" (nie reagowałaby na kliknięcia, przewijanie itp.).</p>
<p>Tutaj wkracza <strong>asynchroniczność</strong>. Pozwala ona na rozpoczęcie operacji, a następnie przejście do kolejnych zadań, nie czekając na zakończenie tej pierwszej. Kiedy asynchroniczna operacja się zakończy, JavaScript wróci do niej i wykona dalsze kroki.</p>
<p>Starszym sposobem obsługi asynchroniczności były <strong>callbacki</strong> (funkcje zwrotne), które jednak często prowadziły do tzw. "callback hell" (piekła callbacków) - zagnieżdżonego, trudnego do czytania i utrzymania kodu.</p>
<h3 id="czym-jest-promise" class="scroll-mt-20 lg:scroll-mt-10"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#czym-jest-promise">>>></a>Czym jest Promise?</h3>
<p><strong>Promise (Obietnica)</strong> to obiekt w JavaScript, który reprezentuje ostateczne zakończenie (lub niepowodzenie) operacji asynchronicznej. Możesz myśleć o Promise jako o "przyszłej wartości". Składasz obietnicę, że w przyszłości otrzymasz wynik - albo sukces, albo błąd. 📦</p>
<p>Promise może znajdować się w jednym z trzech stanów:</p>
<ol>
<li><strong><code>pending</code> (oczekujący)</strong>: Początkowy stan; ani spełniony, ani odrzucony. Operacja asynchroniczna nadal trwa.</li>
<li><strong><code>fulfilled</code> (spełniony)</strong>: Operacja asynchroniczna zakończyła się sukcesem i zwróciła wartość.</li>
<li><strong><code>rejected</code> (odrzucony)</strong>: Operacja asynchroniczna zakończyła się błędem.</li>
</ol>
<p>Możesz "podpiąć" funkcje, które zostaną wywołane, gdy Promise zmieni swój stan:</p>
<ul>
<li><strong><code>.then()</code></strong>: Wywoływany, gdy Promise zostanie <code>fulfilled</code> (operacja zakończy się sukcesem). Otrzymuje wartość zwróconą przez Promise.</li>
<li><strong><code>.catch()</code></strong>: Wywoływany, gdy Promise zostanie <code>rejected</code> (wystąpi błąd). Otrzymuje obiekt błędu.</li>
<li><strong><code>.finally()</code></strong>: Wywoływany zawsze, niezależnie od tego, czy Promise zakończył się sukcesem, czy błędem. Idealny do czyszczenia zasobów.</li>
</ul>
<p><strong>Przykład tworzenia i używania Promise:</strong></p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> obietnica = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> {
  <span class="hljs-comment">// Symulujemy operację asynchroniczną (np. pobieranie danych)</span>
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-keyword">const</span> sukces = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() > <span class="hljs-number">0.5</span>; <span class="hljs-comment">// Losowo decydujemy o sukcesie lub błędzie</span>

    <span class="hljs-keyword">if</span> (sukces) {
      <span class="hljs-title function_">resolve</span>(<span class="hljs-string">"Dane pobrane pomyślnie!"</span>); <span class="hljs-comment">// Jeśli sukces, wywołujemy resolve z wynikiem</span>
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"Nie udało się pobrać danych."</span>)); <span class="hljs-comment">// Jeśli błąd, wywołujemy reject z błędem</span>
    }
  }, <span class="hljs-number">2000</span>); <span class="hljs-comment">// Operacja trwa 2 sekundy</span>
});

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Rozpoczęto operację..."</span>);

obietnica
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">wiadomosc</span>) =></span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"SUKCES:"</span>, wiadomosc); <span class="hljs-comment">// Wykona się, jeśli obietnica się spełni</span>
  })
  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">blad</span>) =></span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"BŁĄD:"</span>, blad.<span class="hljs-property">message</span>); <span class="hljs-comment">// Wykona się, jeśli obietnica zostanie odrzucona</span>
  })
  .<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Operacja zakończona (niezależnie od wyniku)."</span>); <span class="hljs-comment">// Wykona się zawsze</span>
  });

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Kod po obietnicy nadal się wykonuje..."</span>); <span class="hljs-comment">// Pokazuje asynchroniczność</span>
</code></pre>
<h3 id="łańcuchy-promise-promise-chaining" class="scroll-mt-20 lg:scroll-mt-10"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#łańcuchy-promise-promise-chaining">>>></a>Łańcuchy Promise (<code>Promise Chaining</code>)</h3>
<p>Jedną z największych zalet Promise jest możliwość łączenia wielu operacji asynchronicznych w jeden czytelny "łańcuch". Każdy <code>.then()</code> zwraca nowy Promise, co pozwala na kolejne <code>.then()</code> wywołane po sobie. Jest to idealne, gdy jedna operacja asynchroniczna zależy od wyniku poprzedniej.</p>
<p><strong>Przykład łańcucha Promise (pobieranie danych z API):</strong></p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// fetch() to wbudowana funkcja JS, która zwraca Promise</span>
<span class="hljs-title function_">fetch</span>(<span class="hljs-string">"https://jsonplaceholder.typicode.com/users/1"</span>) <span class="hljs-comment">// Pobierz dane użytkownika o ID 1</span>
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">response</span>) =></span> {
    <span class="hljs-comment">// Pierwsze .then: sprawdź, czy odpowiedź jest OK i sparsuj ją jako JSON</span>
    <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`Błąd HTTP! Status: <span class="hljs-subst">${response.status}</span>`</span>);
    }
    <span class="hljs-keyword">return</span> response.<span class="hljs-title function_">json</span>(); <span class="hljs-comment">// Zwróć kolejny Promise z danymi JSON</span>
  })
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">user</span>) =></span> {
    <span class="hljs-comment">// Drugie .then: otrzymaj sparsowane dane użytkownika</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Pobrany użytkownik:"</span>, user.<span class="hljs-property">name</span>, user.<span class="hljs-property">email</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">fetch</span>(
      <span class="hljs-string">`https://jsonplaceholder.typicode.com/posts?userId=<span class="hljs-subst">${user.id}</span>`</span>
    ); <span class="hljs-comment">// Pobierz posty tego użytkownika</span>
  })
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">response</span>) =></span> {
    <span class="hljs-comment">// Trzecie .then: sprawdź odpowiedź i sparsuj posty</span>
    <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`Błąd HTTP! Status: <span class="hljs-subst">${response.status}</span>`</span>);
    }
    <span class="hljs-keyword">return</span> response.<span class="hljs-title function_">json</span>();
  })
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">posts</span>) =></span> {
    <span class="hljs-comment">// Czwarte .then: otrzymaj posty</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Liczba postów użytkownika:"</span>, posts.<span class="hljs-property">length</span>);
  })
  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =></span> {
    <span class="hljs-comment">// .catch: Obsłuż każdy błąd, który wystąpił na dowolnym etapie łańcucha</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"Wystąpił błąd w łańcuchu Promise:"</span>, error);
  })
  .<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Pobieranie danych zakończone."</span>);
  });
</code></pre>
<p>Promise to podstawa nowoczesnego JS w obsłudze asynchroniczności, a kolejny rozdział pokaże Ci, jak jeszcze bardziej uprościć ich użycie.</p>
<hr>
<h2 id="asyncawait---nowoczesna-obsługa-kodu-asynchronicznego---pisz-asynchronicznie-myśl-synchronicznie" class="scroll-mt-20 lg:scroll-mt-10"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#asyncawait---nowoczesna-obsługa-kodu-asynchronicznego---pisz-asynchronicznie-myśl-synchronicznie">>></a>Async/await - nowoczesna obsługa kodu asynchronicznego - pisz asynchronicznie, myśl synchronicznie</h2>
<p>Mimo że Promise są ogromnym krokiem naprzód w porównaniu do callbacków, kod z długimi łańcuchami <code>.then().then().catch()</code> może wciąż być trudny do czytania. Standard ES2017 wprowadził słowa kluczowe <strong><code>async</code></strong> i <strong><code>await</code></strong>, które pozwalają pisać kod asynchroniczny w sposób, który wygląda i zachowuje się niemal identycznie jak kod synchroniczny, jednocześnie zachowując asynchroniczną naturę. To game changer! 🎮</p>
<h3 id="uproszczenie-pracy-z-promise" class="scroll-mt-20 lg:scroll-mt-10"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#uproszczenie-pracy-z-promise">>>></a>Uproszczenie pracy z Promise</h3>
<ul>
<li><strong><code>async</code></strong>: Musisz oznaczyć funkcję słowem kluczowym <code>async</code>, aby móc używać w niej <code>await</code>. Funkcja <code>async</code> <strong>zawsze zwraca Promise</strong>, nawet jeśli zwrócisz w niej zwykłą wartość - JavaScript automatycznie opakuje ją w Promise.</li>
<li><strong><code>await</code></strong>: Słowo kluczowe <code>await</code> może być użyte <strong>tylko wewnątrz funkcji <code>async</code></strong>. Powoduje ono, że wykonanie funkcji <code>async</code> zostaje <strong>wstrzymane</strong>, dopóki Promise, na który czeka <code>await</code>, nie zostanie <strong>spełniony (fulfilled)</strong>. Kiedy Promise się spełni, <code>await</code> "rozpakowuje" jego wartość i przypisuje ją do zmiennej. Jeśli Promise zostanie odrzucony (rejected), <code>await</code> "wyrzuci" błąd, który możesz obsłużyć za pomocą <code>try...catch</code>.</li>
</ul>
<p><strong>Przykład użycia <code>async/await</code> (porównaj z przykładem z Promise Chaining):</strong></p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">pobierzDaneUzytkownikaIPosty</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Rozpoczynam pobieranie danych..."</span>);

    <span class="hljs-comment">// Krok 1: Pobierz dane użytkownika</span>
    <span class="hljs-keyword">const</span> userResponse = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(
      <span class="hljs-string">"https://jsonplaceholder.typicode.com/users/1"</span>
    );
    <span class="hljs-keyword">if</span> (!userResponse.<span class="hljs-property">ok</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(
        <span class="hljs-string">`Błąd HTTP przy pobieraniu użytkownika! Status: <span class="hljs-subst">${userResponse.status}</span>`</span>
      );
    }
    <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> userResponse.<span class="hljs-title function_">json</span>(); <span class="hljs-comment">// Poczekaj na parsowanie JSON</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Pobrany użytkownik:"</span>, user.<span class="hljs-property">name</span>, user.<span class="hljs-property">email</span>);

    <span class="hljs-comment">// Krok 2: Pobierz posty tego użytkownika</span>
    <span class="hljs-keyword">const</span> postsResponse = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(
      <span class="hljs-string">`https://jsonplaceholder.typicode.com/posts?userId=<span class="hljs-subst">${user.id}</span>`</span>
    );
    <span class="hljs-keyword">if</span> (!postsResponse.<span class="hljs-property">ok</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(
        <span class="hljs-string">`Błąd HTTP przy pobieraniu postów! Status: <span class="hljs-subst">${postsResponse.status}</span>`</span>
      );
    }
    <span class="hljs-keyword">const</span> posts = <span class="hljs-keyword">await</span> postsResponse.<span class="hljs-title function_">json</span>(); <span class="hljs-comment">// Poczekaj na parsowanie JSON</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Liczba postów użytkownika:"</span>, posts.<span class="hljs-property">length</span>);

    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Wszystkie dane zostały pobrane pomyślnie."</span>);
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-comment">// Obsługa każdego błędu, który wystąpił na dowolnym etapie</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"Wystąpił błąd w funkcji async:"</span>, error.<span class="hljs-property">message</span>);
  } <span class="hljs-keyword">finally</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Operacja pobierania danych zakończona."</span>);
  }
}

<span class="hljs-comment">// Wywołanie funkcji async</span>
<span class="hljs-title function_">pobierzDaneUzytkownikaIPosty</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Kod poza funkcją async nadal się wykonuje..."</span>); <span class="hljs-comment">// Pokazuje asynchroniczność</span>
</code></pre>
<p>Widzisz, jak kod stał się znacznie bardziej liniowy i czytelny? Wygląda to prawie jak tradycyjny kod synchroniczny, mimo że w tle nadal działają Promise i cała magia asynchroniczności.</p>
<h3 id="zwracanie-wartości-i-obsługa-błędów" class="scroll-mt-20 lg:scroll-mt-10"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#zwracanie-wartości-i-obsługa-błędów">>>></a>Zwracanie wartości i obsługa błędów</h3>
<ul>
<li>
<p><strong>Zwracanie wartości z funkcji <code>async</code></strong>:
Jeśli funkcja <code>async</code> zwraca jakąś wartość, ta wartość jest automatycznie opakowywana w Promise, który zostanie spełniony z tą wartością.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">zwrocLiczbe</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// Możesz też użyć await, np. await Promise.resolve(42);</span>
  <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;
}
<span class="hljs-title function_">zwrocLiczbe</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">val</span>) =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(val)); <span class="hljs-comment">// Wyświetli: 42</span>
</code></pre>
</li>
<li>
<p><strong>Obsługa błędów z <code>try...catch</code></strong>:
Największą zaletą <code>async/await</code> jest to, że pozwala na używanie standardowych bloków <code>try...catch</code> do obsługi błędów w kodzie asynchronicznym. Jeśli Promise, na który czeka <code>await</code>, zostanie odrzucony (rejected), <code>await</code> "rzuci" błąd, który zostanie przechwycony przez blok <code>catch</code>.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">symulujBlad</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> {
      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"Coś poszło nie tak!"</span>)), <span class="hljs-number">1000</span>);
    });
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result); <span class="hljs-comment">// To się nie wykona</span>
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"Złapano błąd:"</span>, error.<span class="hljs-property">message</span>); <span class="hljs-comment">// Wyświetli: Złapano błąd: Coś poszło nie tak!</span>
  }
}
<span class="hljs-title function_">symulujBlad</span>();
</code></pre>
</li>
</ul>
<p><code>async/await</code> to obecnie <strong>najczęściej rekomendowany</strong> sposób pracy z asynchronicznością w JavaScript, ponieważ znacząco poprawia czytelność i łatwość utrzymania kodu, sprawiając, że złożone operacje asynchroniczne stają się bardziej przejrzyste.</p>
<hr>
<h2 id="zadania-do-wykonania-sprawdź-swoją-wiedzę" class="scroll-mt-20 lg:scroll-mt-10"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#zadania-do-wykonania-sprawdź-swoją-wiedzę">>></a>Zadania do wykonania: Sprawdź swoją wiedzę!</h2>
<p>Czas na praktykę! Rozwiąż te zadania, aby utrwalić to, czego się nauczyłeś/aś. Po każdym zadaniu możesz rozwinąć sekcję <code>Pokaż rozwiązanie</code>, aby sprawdzić swój kod. Powodzenia! 💪</p>
<h3 id="zadanie-1" class="scroll-mt-20 lg:scroll-mt-10"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#zadanie-1">>>></a>Zadanie 1</h3>
<p>Napisz <strong>funkcję strzałkową</strong>, która przyjmuje dowolną liczbę argumentów numerycznych i zwraca ich sumę. Użyj <strong>rest operatora</strong> do zebrania argumentów.</p>
<details>
<summary>
<span>Pokaż rozwiązanie</span>
</summary>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">sumaWszystkichLiczb</span> = (<span class="hljs-params">...liczby</span>) => {
  <span class="hljs-keyword">return</span> liczby.<span class="hljs-title function_">reduce</span>(
    <span class="hljs-function">(<span class="hljs-params">akumulator, aktualnaLiczba</span>) =></span> akumulator + aktualnaLiczba,
    <span class="hljs-number">0</span>
  );
};

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sumaWszystkichLiczb</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">// Oczekiwany wynik: 6</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sumaWszystkichLiczb</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>)); <span class="hljs-comment">// Oczekiwany wynik: 100</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sumaWszystkichLiczb</span>()); <span class="hljs-comment">// Oczekiwany wynik: 0</span>
</code></pre>
</details>
<hr>
<h3 id="zadanie-2" class="scroll-mt-20 lg:scroll-mt-10"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#zadanie-2">>>></a>Zadanie 2</h3>
<p>Utwórz obiekt reprezentujący produkt z kluczami: <code>nazwa</code>, <code>cena</code>, <code>dostepny</code>. Następnie użyj <strong>destrukturyzacji obiektu</strong>, aby wyodrębnić te wartości do osobnych zmiennych i wyświetlić je w konsoli. Dodaj również zmienną <code>producent</code> z wartością domyślną "Nieznany", na wypadek gdyby nie było jej w obiekcie.</p>
<details>
<summary>
<span>Pokaż rozwiązanie</span>
</summary>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> produkt = { <span class="hljs-attr">nazwa</span>: <span class="hljs-string">"Książka JS"</span>, <span class="hljs-attr">cena</span>: <span class="hljs-number">49.99</span>, <span class="hljs-attr">dostepny</span>: <span class="hljs-literal">true</span> };

<span class="hljs-keyword">const</span> { nazwa, cena, dostepny, producent = <span class="hljs-string">"Nieznany"</span> } = produkt;

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Nazwa: <span class="hljs-subst">${nazwa}</span>`</span>); <span class="hljs-comment">// Oczekiwany wynik: Nazwa: Książka JS</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Cena: <span class="hljs-subst">${cena}</span> zł`</span>); <span class="hljs-comment">// Oczekiwany wynik: Cena: 49.99 zł</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Dostępny: <span class="hljs-subst">${dostepny}</span>`</span>); <span class="hljs-comment">// Oczekiwany wynik: Dostępny: true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Producent: <span class="hljs-subst">${producent}</span>`</span>); <span class="hljs-comment">// Oczekiwany wynik: Producent: Nieznany</span>
</code></pre>
</details>
<hr>
<h3 id="zadanie-3" class="scroll-mt-20 lg:scroll-mt-10"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#zadanie-3">>>></a>Zadanie 3</h3>
<p>Stwórz tablicę ulubionych filmów. Następnie użyj <strong>operatora spread</strong> do utworzenia nowej tablicy, która będzie zawierać wszystkie te filmy plus dwa dodatkowe filmy na końcu. Wyświetl nową tablicę w konsoli.</p>
<details>
<summary>
<span>Pokaż rozwiązanie</span>
</summary>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> ulubioneFilmy = [<span class="hljs-string">"Incepcja"</span>, <span class="hljs-string">"Matrix"</span>, <span class="hljs-string">"Interstellar"</span>];

<span class="hljs-keyword">const</span> nowaListaFilmow = [...ulubioneFilmy, <span class="hljs-string">"Pulp Fiction"</span>, <span class="hljs-string">"Forrest Gump"</span>];

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(nowaListaFilmow);
<span class="hljs-comment">// Oczekiwany wynik: ["Incepcja", "Matrix", "Interstellar", "Pulp Fiction", "Forrest Gump"]</span>
</code></pre>
</details>
<hr>
<h3 id="zadanie-4" class="scroll-mt-20 lg:scroll-mt-10"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#zadanie-4">>>></a>Zadanie 4</h3>
<p>Napisz <strong>funkcję asynchroniczną</strong> o nazwie <code>pobierzWiadomosc</code>, która symuluje pobieranie wiadomości z serwera. Funkcja powinna używać <code>setTimeout</code>, aby po 3 sekundach zwrócić tekst "Wiadomość pobrana!". Użyj <code>async/await</code> do wywołania tej funkcji i wyświetlenia jej wyniku w konsoli. Dodaj również blok <code>try...catch</code> do obsługi potencjalnych błędów.</p>
<details>
<summary>
<span>Pokaż rozwiązanie</span>
</summary>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// Funkcja symulująca pobieranie danych (zwraca Promise)</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">pobierzWiadomoscAPI</span> = (<span class="hljs-params"></span>) => {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> {
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> {
      <span class="hljs-comment">// Możesz zmienić to na reject, aby przetestować obsługę błędów</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() > <span class="hljs-number">0.1</span>) {
        <span class="hljs-comment">// 90% szans na sukces, 10% na błąd</span>
        <span class="hljs-title function_">resolve</span>(<span class="hljs-string">"Wiadomość pobrana pomyślnie!"</span>);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"Błąd podczas pobierania wiadomości!"</span>));
      }
    }, <span class="hljs-number">3000</span>); <span class="hljs-comment">// Symulujemy 3 sekundy oczekiwania</span>
  });
};

<span class="hljs-comment">// Funkcja asynchroniczna używająca async/await</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">pobierzWiadomosc</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Rozpoczynam pobieranie wiadomości..."</span>);
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> wiadomosc = <span class="hljs-keyword">await</span> <span class="hljs-title function_">pobierzWiadomoscAPI</span>(); <span class="hljs-comment">// Czekaj, aż Promise się spełni</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Sukces:"</span>, wiadomosc);
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"Wystąpił błąd:"</span>, error.<span class="hljs-property">message</span>); <span class="hljs-comment">// Złap i wyświetl błąd</span>
  } <span class="hljs-keyword">finally</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Zakończono próbę pobierania wiadomości."</span>);
  }
}

<span class="hljs-comment">// Wywołaj funkcję asynchroniczną</span>
<span class="hljs-title function_">pobierzWiadomosc</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(
  <span class="hljs-string">"Ten tekst wyświetli się natychmiast po uruchomieniu programu, zanim wiadomość zostanie pobrana."</span>
);
</code></pre>
</details>
<hr>
<p>Gratulacje! 🎉 Dotarłeś/aś do końca kursu wprowadzającego w nowoczesny JavaScript. Masz teraz solidne podstawy do dalszego rozwoju. Pamiętaj, że kluczem jest praktyka - im więcej będziesz kodować, tym lepiej zrozumiesz te koncepcje.</p>
<p>Co chciałbyś/chciałabyś zgłębić dalej? Może:</p>
<ul>
<li><strong>Moduły ES6</strong> (import/export)?</li>
<li><strong>Klasy</strong> w JavaScript (obiektowość)?</li>
<li><strong>Metody tablicowe</strong> (map, filter, reduce)?</li>
<li>Głębsze nurkowanie w <strong>asynchroniczność</strong> i Web API?</li>
</ul>
<p>Daj znać! 😊</p></article><div class="container prose"><h2>Quiz: Podstawy nowoczesnego JavaScript</h2><div><p class="font-bold mb-0!">Pytanie <!-- -->1<!-- --> z <!-- -->5</p><div class="prose-p:mt-2"><p>Jaką główną różnicę między <code>let</code> a <code>var</code> podkreśla się w nowoczesnym JavaScript?</p></div><div class="grid grid-flow-row gap-3"><button data-slot="button" class="button button--variant-outline button--size-sm w-full text-left inline-flex justify-start transition-none text-wrap! min-h-min! py-1.5 cursor-pointer">Obie są identyczne</button><button data-slot="button" class="button button--variant-outline button--size-sm w-full text-left inline-flex justify-start transition-none text-wrap! min-h-min! py-1.5 cursor-pointer">`let` nie pozwala na przyjmowanie wartości domyślnej</button><button data-slot="button" class="button button--variant-outline button--size-sm w-full text-left inline-flex justify-start transition-none text-wrap! min-h-min! py-1.5 cursor-pointer">`var` nie istnieje w nowoczesnym JS</button><button data-slot="button" class="button button--variant-outline button--size-sm w-full text-left inline-flex justify-start transition-none text-wrap! min-h-min! py-1.5 cursor-pointer">Zakres blokowy (`block scope`) w `let`</button></div></div></div><div class="container"><p class="button button--variant-secondary button--size-lg w-full p-10 text-wrap flex-wrap h-auto text-center gap-y-4 text-wrap!" data-slot="button">Widzisz jakiś błąd, bądź literówkę? Chcesz coś poprawić?<a href="https://github.com/jakubszpil/jakubszpil.github.io/edit/main/app/content/courses/nowoczesny-javascript.md" target="_blank" rel="noreferrer" data-slot="button" class="button button--variant-link button--size-default">✏️ Przejdź do edycji tego pliku</a></p></div></main><footer class="prose max-w-full border-t"><div class="container flex items-center gap-3 justify-start flex-wrap-reverse lg:justify-between"><p class="xl:text-sm">© <!-- -->2025<a data-slot="button" class="button button--variant-link button--size-sm" href="/" data-discover="true">jakubszpil</a></p><nav class="flex items-center flex-wrap -ml-3"><a data-slot="button" class="button button--variant-link button--size-sm" href="/" data-discover="true">🏠 Strona główna</a><a data-slot="button" class="button button--variant-link button--size-sm" href="/blog" data-discover="true">📝 Blog</a><a data-slot="button" class="button button--variant-link button--size-sm" href="/learning" data-discover="true">🏫 Learning</a><a data-slot="button" class="button button--variant-link button--size-sm" href="/portfolio" data-discover="true">🛠️ Portfolio</a><a data-slot="button" class="button button--variant-link button--size-sm" href="/me" data-discover="true">🙋‍♂️ O mnie</a><a data-slot="button" class="button button--variant-link button--size-sm" href="/search" data-discover="true">🔍 Szukaj</a><a data-slot="button" class="button button--variant-link button--size-sm" href="/handbook" data-discover="true">📋 Handbook</a></nav></div></footer><script>((storageKey2, restoreKey) => {
    if (!window.history.state || !window.history.state.key) {
      let key = Math.random().toString(32).slice(2);
      window.history.replaceState({ key }, "");
    }
    try {
      let positions = JSON.parse(sessionStorage.getItem(storageKey2) || "{}");
      let storedY = positions[restoreKey || window.history.state.key];
      if (typeof storedY === "number") {
        window.scrollTo(0, storedY);
      }
    } catch (error) {
      console.error(error);
      sessionStorage.removeItem(storageKey2);
    }
  })("react-router-scroll-positions", "/learning/nowoczesny-javascript/.default")</script><script>window.__reactRouterContext = {"basename":"/","future":{"v8_middleware":false,"unstable_optimizeDeps":true,"unstable_splitRouteModules":true,"unstable_subResourceIntegrity":false,"unstable_viteEnvironmentApi":true},"routeDiscovery":{"mode":"initial"},"ssr":false,"isSpaMode":false};window.__reactRouterContext.stream = new ReadableStream({start(controller){window.__reactRouterContext.streamController = controller;}}).pipeThrough(new TextEncoderStream());</script><script type="module" async="">import "/assets/manifest-88d713c3.js";
import * as route0 from "/assets/root-DtrRPq6W.js";
import * as route1 from "/assets/layout-DVWCjRNU.js";
import * as route2 from "/assets/course-details-DLJ6fZBl.js";
  
  window.__reactRouterRouteModules = {"root":route0,"routes/layout":route1,"course-details":route2};

import("/assets/entry.client-D07Jc1yP.js");</script><!--$?--><template id="B:0"></template><!--/$--><script id="_R_">requestAnimationFrame(function(){$RT=performance.now()});</script><div hidden id="S:0"><script>window.__reactRouterContext.streamController.enqueue("[{\"_1\":2,\"_7\":-5,\"_8\":-5},\"loaderData\",{\"_3\":4},\"course-details\",{\"_5\":6},\"v\",\"㞂⁆⁜⁊੠㬸ᧀ蘎䀈໩腈ಠദ̘נ➀㘂婠胶\\uda31䨊循ƺꁩ栀瀂衒偁큈톘ŘꙒ뀦―Ö든ִ찠挀倞準ꨒ㭄ٸ᧍牥쎛✧ᒀ଄経ཆ搛์\\u0013䙌儖ş⃔棊Ы娊฀챺娄儸䭇䩬泿ბ匄岂ꊤ兦䨀耺䰀甲婀偀㌀坌パ呑ₜ깞縡ㅌ牴고렖樾魀⅀ቬጛ⣲吕滒٦㡌3㺄ᵒ㕜ፔ氻⎓\\uda0f₸石茿缭鲀撡딺ꉊᆇ䟐ጡ芌̓闢ࡢᶰꡀྠ㟅䏧㧁ꢆ䐄㓢썣ₐ晘鲚梣፬찀ᑀ考恹ㆰ뢖蒄Ԓ老둀⩹㈖鸤鍃憼鶩鴟둃♟ଊ␑탊䤅\\udaa8偃Ӕ₃むº鉋搈刭曢ᭈฃ 　᤽\\u0016-㞵逘̳稀⫞ᨻỴ떣\\ude80ᚯ╅Ԁ䆠E㺭ᲉӀ\\u0015ᡑ་펉쵢柳灊品䋭樌考찠Ǳ존\\udd4cᦃ撈䀎юⱦ卉耲턴פֿݴ詛荶ঢເẙ甕幠剋闷瞀⋜帨躀䜄ͪL䉳鰉㪾쑧匛䨀㼖챢ਠ\\u000f☃ӈë䋮Գ䂰窒\\u0000溻섌ぅᢉ│ꍘ쎂骍ⷪ䏐ㄈ⽹⃩舒笡葧쨳⸅妒ᰑ衂ꨍ碠領ൂ〺ፉ耀ᓰ悚샨Ⅎ샰䀉䳺ⅰ⢏ݚ鈁蔂蚒ȃ⊩윊ꁑੀ燱堔鈧悔उ硐ꠖ١䒜㰗䓎፹恗්䋡ᰏ 蘿涧揘Â넺ḹ醏၁裸鰈锐ﺛ轠è⁝跭\\uda1e뮙ĳ⃈\\u000b즔胾㔃詠ጅ꟒ꁦᰀᨺ乸ꅗゎ脕乙兕唸聣ꇀꔣ!䐝狡聮鮗広盻肀≠ꕦ(盳䵊䌕ﵥ嵗 與퀘怑䇔宖\\uddd8邛睝뛭퐷ᶧ秒Ͷ麵탶\\udd98㷓퓭絳\\ud836ᵯ姐⁵ꆏ킵娀㜶倎㷀샐眍ꍂ䤶緓䞃ఠ譀꽢怤᠅檭䭀肌潒咃棉১ᵟ툵瀀ྥ㘰ᠣI譄軓筨〚袴⢀䩜휩Ĭ▘˘鑍肊唶礞뾞忺ė昊᫲麑믋岻藏釀儙뤢ᮞꚒͩ놞錠\\\"ȟ䙣탸ꄠ动쬸詁䝆鋐㉣䦂᯴⡢ᖅ※洁盝둙芘ꁠ켦墍૕퓞ꙸ遖긭᥽껮\\udda2麕ﺒ\\u001f梀ᆂ䕀銜ᅪ拎제ሃ뭰ກㅻ⾠₣ꕊ聬\\udd2f⠂ਃᰭﭰ詼瀀้䋲〣ຆ퀢ꘇ큜䪂ঙ✆놀㠆쪂醴଍縌ꁟ稡쮻ꒀ充@顰ᅴ⌸턈ᬏꁢ七ဳ꛵碡컁촑Ⱑ栄䎰므鏯朋膆ㇰવ侣齆ýᰟ䁎㥅⨄懇ⓤ糓迊\\udc1dሄ⤔돌嬣ꀶ࿁雾䕃큋쎁젙蚠쏽珍\\ud944㾄핰흮쾬ᮀ̖뢴㳣킃膰油쐢﬎쉟⎌ꒀr섀삤ਖプꒂ凜┡꣆፠璬ꉄ䧔ᴁ㰐醟͋壥ᝰ䝑䰥ৼᒍ脯굧곞㉇‍⛩徛뚀㘥䙔ؑꋎᡎ㉶ೋ铤⤬䖉븳\\u0006梎䇴ຈꀃ麳遁裐\\ud832䈡䧂⫶帠㧑⊀ᰐᖅ앞Ꮝ栒兮꥖䘣濯闏ࢷ꘵喘㔦ꋕ䔻哺싈᧓呤㑆飐騝䧉ꑒ-ﺍ㝙ꋍ᭬챡퓼鲰䄹乪ﵣ郴晦찺ዊ宜殟Ⱀ⊷ᇪᕙ겧ꋲ̷咰ؙuŬꖀ⏌ڀꗪᴋ鸴놷憼俌턜聒跡凑㨐쎨Vŧരご䘧⸕謷鴭㹭짹蔗ᯜ薦└邷╘늖䭪嬬빝⿰蠟趝謙釶雳㶘ﲜ柌땥伴쎫끳萠툕歭쎬㊞뎮聟ល䍇­鈂㐠ź睳谀㬕욠囚耒⢍\\ud90b㸮઼老੏繈銠㞦䤠ᔦӽ첀๼셸뢟ꚠ刂逭勱₨ᩚ쓄ಅ沼ࢍ崷Ꙡ籒ᒭ⡑¨ف넚쇀陓꜔벂ⴎ㏥벯࿃эꕐ禙蛬䖽臖⩏⁦ኃ䖴婮쀁र \\u0001篸໱큌\\u0000␣\\u0005退㉱ᘠ߭鐽০癟牠䢠䀈᫬ส܂偁᷐ꈉڎᾗ뗌眍몊⤁ᇴᄐࣽѡ쩁煸瘄聢唘㮘栏䐤Ჳ\\udc38䴹䘨ႌꂤ爦進ᙅ䁠订萰䘘삨ጙ䇞葫⾂蠛ᬈ밝᭥々冼䠍`દ퇝ꕌ큺܂䒑栀윬蚔텄ƌ\\udbaa᭩撬職৅꘤餤呝\\u0010廷⠟䅵鞠≀邨犏레䉯챑ꞇ\\ud94f譡츪倘렐莏ඎ몟˂贋ᔈa넮Ω瀜菀뼏晾ѯꁠᾎ哎ᱫᾩ䉀䋃⭶ঝ\\ud823∂⌫ᒰ樰탽ሹ쒊侗ɞਘઇ䒓蟍倜蕙꾔濰น샞ᧇ탡྇飩ާ우ী퍪ϩ䉵랶柳✀⌮鱌疶艣쉷䷀遤膨篏䄟巤砵㑃䉷襁㜊䜩岊聸ᄮ穅ⷢࠨ髳६끷ꄉީ⪒莰팡逞㨀䷦ໂ츒楁漌䎓獘⇌썭ꖇ â葰躈逸ⓩ唼荎಻ޚᰃ梑䀞恫藖𛦠紹°箂疘ꚅᢌ᫺軀Ŏ䯹⋎埰ꛒଽ⺩跦븕姤聧䟍ꠀ怰ꈀヺ媦愠㌸畬嵯䄊刂ꢪ؀䉳펀ᠭ酃ꁈጃව訤֗Ȟ屼혍嘃㜄ᦙꮣ冯궈䏶狈㠀쿼෠룏䀃ፓ힗仈蝖䕯瘯붠宜麓軇춃\\udd07쨩ᛟ᫇簽ဒ\\fャ๻䀃֑3夳耙腣\\u0000꒑弗夔䛸槷庚ຬ饧ᱻ肅蒹긵ⴢﺳ繏淡鐉솳㣥⯀Ƴş舽乯➍뾥吉༝鈽\\udbc7獂垱藸밀๏䦢̩ꎔƆ铳䎪鼲㾃低冡ϛઁ珵ꆄ뺆្ꀃ⩸ꂔႣ偬䇕̈́ᬄ莈ྸ鋉닓〦Ø跊龪髤เ΍蘒꫚怵᯸㰗똡測葉㳸אָ둸唓렜ᒐ隽௤ᦁ㾋ﭠ㢲ᠰ臡덑퀌ᠦꇐؖﯧ껸调棢ǃʥ荆镺ᐇ訔ƀ甁Ɛ傒䐥њሣ褌堘⌄谹쌮꒳Ｕ̠㊓钥㌐䌼㑫찜䇷ނ᠎׏괁螵蔯ꊸ꾉ۮ㴉સǂҸ늊Ꙁ羀懠뺂㠍޺ꡡ큀拙ᤒសꅰ縪辶⌁➯艒ṻҶꇴ㮃逇勷㎆롥θ仰悝|㷳ঔ맩鄯䄄᧪㐉ư㵡砊䖀ᩄꀹɘ帇塂齃儇\\udb89З࿱䐏蓹ܹＮ玍⹸ؾ⍟谑〧Ѐ✻ꡄ圄;⡅뎭茈ὀ䰝슧馐焭H矱᜽π➉Ď瀀諑褳禗㡙袶蜠铅搾㧴긁颐䁬囄䎠␠ޗ뮴䶄䞽蜐䠀㮮쉚臻삏藠눂灮ﭻ㷻\\u0004㕂搂쀗酻양⹹㰳ˤꇀ؜䧧㺂葭뤁쉧ꁢ煻找왽Ⱪ眦ˉ酠$菀쉰ঘੁ≊┌鏅\\udf39䧢毁嶙磓숑ᩐཱྀ妵曣成瀤⛲䯂ꀤ닧蝫鈽唤≰튖ὀᾈ欢涻ᄤ瀪簹ʚ䇈婘썹鬺倜잺ꬹ驟┺矀甬驺䫛ꈤ놔亥愧␢䨇ᩰ栺樥搗榔婫풯☺娧簉ɑ㔀萴晚矃쩢Ꜫ呺ꩃ렜⻅\\ud800惄⡄嶏㇟聠ﺶń✇몬飖昺ⱶﯢꡇ莢워泆힕\\udb24㑂쐛ॖ牂ᘗᵦ\\u0017ꀈ䉣頸\\udb04㬎깤瑝쪇ꈲ\\udbb0箓깁䐳틇ꣳず鄧꧸ꞕ繁♻勧냻鞱饗觠㎘뤳ꂀ뎀멳랣环㨾缻뎀愋袺㎄륋錀쮱멫ꊻ⮪뮫蠔尶먝ẹ숡롁榹省⁛錁‍렸栤稧뉸碆陹ा挀辘וּᶦ\\ude67큻ꖅ히፹袺鷑袧祪ꕳ瞷鋷肑ᅖ䤏ꤕ幡၏颉侇ᓈꁺ稰磶❃阬∕蕀ྫྷ₊แ毌㵺䇷ð\\ud81d˞ਢ\\ud924㧀ᰰ犰ã―鮢ਅ갅Ɯ㵢侩ꆷ鰸䎨䍡Ể咕颞렉砈⁰貓퀕䇴㪣㐅䎀鬊렙Ⴄ᠀氼მ⎱櫵轪ᆬꉹ䩁䐍陲⪉砸䄵뚗ꄠ䚗텘唷軩ຳ笱碖箥営菃떕喱懥란\\ud90e류렩阬㞚㰳삊纉鴇鯨ᬂ\\bꀇ肰πꨊ쉁⥀⚓˞Ὂ馸奥᤺蘦眖ᴿ窞傒逎胖岓守ȳ鼺뎗딀휾俦겨맂뿦鬠ᐡ䊹⮊렛렫鐖逎뫁䆸ሗ헋ꈗ鮇㪡燔ꩌ祭愗ओ䇃绖ᵟ贕箏቙⼗썕ᥜ墉䤾훉῱랢鈇ꡣ䥴嫄㽱铙䖊搪ʎ鴔㞘櫮ᅕ쨺ʙ憄∅隈釠하訵䭔촗禘뺉㕛毡嘴\\ud925ε孩쎬䍇⶙羗ထ⭁서㿪饦镡⌓戹쁂㔁涮Ǡ肂栃뇰貜枋督夀슙겵ﴗ龜뫛䩂\\uda30ⵄ씺䂨䆓㳢貄쁋鍂츪₊娃蝳筂跄銋钓鑘阺昌̡᠈ꃉ㫫줠䫿迃\\ud92b莢⣂炴햨ꊡ됞Î봁慁耀祷ꏨ덎霕䄐䒊슎ぉ䭠馈관尋ᐉၷЌ䁸⚃ࠖማ熵ꝗ疴㭱㠿騣ꠋ䕩ᦕ䅸᪣㑀酺魀䘬䅺紁ꖴ涳鶷兞ᡶꈔ䂵럁᠖ᖅ橶ᐙ朋ꐖ⸃ᆐй\\udf32혧乐랷⺂弔䉀Ꮄî劮ॲ㎨㋕㨁댢쪵㎡⠄⨊駉沆ㄢ蝒쥜䘎⪂箨斃倇包䲪㊾ㅂ뙒怌⬣Ⴉ謢⫬銲랕อ⵷錦⨰\\uda33茇퍶Å냱⭰ᴲ⨈甦☂烞뜱ƴ퀱랷睂睡䏖㶶瞰태ྜ똌냷掱䷒性ƭࢍჟใ⟑஑⧨﷥謸蹈䣙豧ࣣ⋤ៀ⣃ℛ惤꣚跆綴ମ蹘퀨誳〠ﵐ䪷㋳㼳냜ꫂ묩ꌕ⡼뜪튚ꮘ⪲흦뀸씩ꌳ贒ᒌ죻䌽荩䬭º뢓ཨ芏刀錬䃍膖瀮ϛ䤴ʒ딳쪡䴍ㅌᐩ䶐⧻䪋䌫ᢑ⦸נּ\u0026뭁Ĵꘃ몴ࠠ㮲躼\\\\ᅂ​㠆絬賸⠥덛ᑁ蓯䲤켌ೂ₸룔ꠒ㣏領鉐㹌쳼츬곆쵬톾츜瀯뤰᧏᪅최\\udb54뮰㸗莎㰛␫ᔞᢔ୙謜ꃨ䭖핰귂Ԍ뗍⸮䦉ᢡＢ酻惃ꭑ、꥕잗銳準띳韆㝝䰴쑉逄蜮퀼歋ᨐꐇⰎᜭఏ⸎႓羚ﯨമ㝄⤘袃榬ޗ㌢⍠ጙぽ抱ቕ블⊖⁘鮐⻠Ԍ䀑ぃ尤煘⋢襳雕厴굺攸톄㍒݂뻦祑槔繹푳ꗗ嵘滝炻\\udd5f돗쑫힜㯗腰᚛鿔;믁穬⮒ᗸе宺ᒂ䎹퍋鳣龜ᘞ侅兇릣泸쀷깤ῂ囋獕嬍袺⹗㬔୽Ĺ槠뫦ᤶ⌦옂呚\\udb47滍ᢉ㭄౅飯倠⛛潱덖睁㭧哞᧨暳쓎ₔथƵ뵗瘎㩁㭳\\udf30焁ᤒ쎀♴睢⺁꼾섇塰\\ud81e혠ꐚ膞鞂爰隙㍷덋앏呶㈦趉ȃࠛ䍎괾⬒뫢ꇌ獺ᰱ瞴狅嗫勾㖂ǣⴄὋǑ፴뻮\\udad1மổ䬨ﻒꝘ䀂ꢁ굫仿璹᭏腫甞暖ᙰ頂ཪ裙ꚕ\\ud81f䠡툞픊晇㏣࠮㧐⬜⩒㣮⌦鱎甩ⱷꭕ໩瘎黾껀涷阤쨄喧৮喜℞짮鋙ꡤﶪǽ闯⤟鰓姴맮\\udd95ᎀ乶⎅鹧塛읚统ᛙ㟭哙䩂撴䃦沙삵맰ᑔ㡞७姹\\uda01ୢ㿒ᠧ堏ꔡ渧弔揱쁓૟숵쓺黵芹ᖱゴ屪䴞ⵕ嗁ऍ힅悼鶴ు餰㭕‟䇭\\udef1ሇ켡킴㊀떘ᝋꀓゝ\\udbae켢仱褗⃨⨂◤猩㠊귓嘛\\udc30쎽졁堑〦隋Ѕ倜Һ截3请혯\\ude10鬟螗᷍姫᧰뛕䤃鿮\\ud89d麡ၯ埵\\ud8b4鲏Ⲟ䴇ԓ㶯領耋茾ࡧ븱Ɛ㾀㏊䀲썄ꖓ䞤楞긿㔞㉝槦쨽槐ພ샮싙鵀⾩꾑ⵞ\\ud891鼌균볕\\udaceꍶ諁ⷜ㝀槊延ၲ帶ᩖ㯮鋒먱ᔇꯥ⸣梤Ῡ괁ᇲ콗틹삲郫朊㝅卍玿逕搳阑砼\\ud9f7ᡪ够䃒쑜祧ᦣ襟簴᧦R榃劻ꈨ풋⺩ᕡ⎖黺꼉⦁ㄟ빁춀ꌢ쇝䊬賦˨擔熩鉔襝齩鍋党餋夗쒾ᧄ顱욢횈্罤쯭圳ꔠ堮䤬䦛ᶋ틮ꝯ路Îቝ궲揥\\udd1eআ﷡莭琼싮Þ勀ᴌ䴠ꃊ쩵὎ꓖ೬눨飁煈᫐㚈䌠単틨˃머α䤀쾣紝蘰৿귌솋詾ᭃᶆ쨰Β惃儛謓鐙㙄輨㪁녤ϸT⠈⁼λߨ൐ᓗ﹢㞹襍屣⍷愁ᤰଶ崐ႌ䓈䙨직홡ꝳ齉蛧먢磡ഴ촑䐎喪↷偀싖Ţ슉颩ၠ뉎揄\\udc20褱먞ϴ搴璙炚˟⛉誱\\ud866①ߤ숦\\ud8a4ᦨ膆湓竓ꚅ耔א䠉˩ጀ纂됕쳉䵀ꈘ\\ud838曀༦¡䁖䏃ጀ弰妒챖溳䶚怂ゔޒǍ䰄猿䧂ᑼꠡ㴲祮ᔅ㻋Ꙗੱ謂虦샢쎎ྞ앶殫姦ߐ礠氐袠☉꜎ɇ㩰釮䂱塮趔㼄\\udcc0臌　䦝䱦ၭ箓ᨔ씋䘈삪ஃ竰ଂ꫾ਅⲄ찁퐊ꋉ鑸烱4̘᪀菲蠎憟䁭ກᘗ낚ޠ⛆彆\\udf11즂蕌熇聯䄯㊨訊ꩣ蟸䣤ᘲ偯മᇔ佂챞웓ஹ蒍堘ٰ㮁및겐䌪弚쏩ሽň⧌⸦\\uddf0䓼庆ﴀ懸ਡ腂\\udfeeꃉ劌\\udb41뽂硿䵞䑀쌆逩堹㌰䏃倉悟蒂⇦㌰ꦣ苨ࡘ桒퀞벅胘囂⪍끿ਖ\\u0011⋴᳀큅鐼ᆃߊ蠃」਷ᤀ≆ᑈ䍠ᴀ㎎଩럍戗飂졶錥岀臗ⅎⷈ唃阛Ꙉ߀繰৐岖柠＀䂯젎␋豕ɯꘅ︓ꯞ䛪᝕粕헟⩠俊஖㙀鞼鏕ꗌ魐⡽䐚㽒휿푠궛恫꘿㘨刭觔ପ븀醨ڲ⺏\\udf21輦౾䲚龇숗戄浯縇ߠ↊ꀖ֘認䬈Pఙⓑ⠄㴙Ć쑠ᘂ៣ിꋛᙑ⃆炞股辕迁⒮䵁잤萤夤嚫솴ॼ戸솝⁰擊菠ꨊ摦脒유芰氂馷湤ⰳ⪜抬돡䓆퀂\\u000eႈᏔꚸ૦戸᭗蠌따ᛱ먇Ꮙƴ㔅\\ud816걌⛢ᄋ顈샍㈁ﮨɰʀ騇犈⃨ن壻逕䚋昸ϵ瘁怌聸Ī倱ᶆ퐪薨뀛␞뇜╏㶉崓짂許ᆱ豔淣ḛ濉☮숩衍驣獢鬰⩽崱馳챜ᐋᘤ덳⅐뙨唬䘔鷌罆☊쪱쎋㠊腑ꧮ姰ဝ䥈⚼欓㑂ꁒ殓䣄梃鰇褈阚痀ค징詨แᮭ㢭⻄䙊☺Ⴂ乀䜣䐉ᚦðϵզ\\udbe9픸뛔邃㶒蘚㓓複쁵ተૣʖ⬊읍蛘聗霂ࣂ⿠䔡\\udfd4雙䟋골㥥᪓򬎉゚臕ࢸ馡笖葂녳讁첍聁ࡄ颈켓䲸\\udd83辐満莗▲門瀘஼늗奬굍䣸聙벨ꆄ᷈쑎ᓇ\\uda64켊쀸ꦐ沲ᝃꃙ懖ന涃쨑ᡋʹܾ塃⩢芎铃䌛⊜阘ꃤ崣\\ude40좬驽ݮ蜀‰섬Հ솅Ⴤᑖ܅⟑행ਵ䞄엩ﾇ冖麊瘛Ôɂ꘏䵥ᶴ菈⨴蠀遉뒓攱⊠俱ⷀ㠚椺某ረᓃ೐泑䱬ࣗꕲ蒁὎폌邌떠჎숆堨䱰暕ᅨ⤆䙘µ蔌퉆䇘쒤攌琐쳂ֽ㲖㼧唙舕遠甍駿䪦専︙ᣝᤁÈ聾뎻ঀ鮢⤝釜쳤堣뤐⇲㌀㜉鑥㋥ᦌ깄죗ᤵ䫊挡䴏큔ႈ豈ꑱ辢࠴죩듘䡎̣㾲亄䠾莓ゑ滈왍㉥閏穥䌣夓觹ㄽ蘃餎朗ਙ볉ٷ愅ᾠ䅦ⴁ妫࣪㰑砆뎜⢆蝳\\u0007耺耀በΗ⸀鍏憰葊瑦툺뱂ԕର퐗፴⹙풏噽⌵铈팄\\udd0b餦컅㙳馐갲ߢ弹ᗋ噔㉫駴ડĂ怕䒅㖳垒催旘➑軎ꦁࢵሃἡ骾ॎ烳Ȟ僯攍䥨Ǌ␼蔉鐲⼰⮜膅鶀䍄鲅ꄏ⦁탌뤔郲㧥⬧㥛졭㻀蠡ⅼ⢹㛊唀糹骲瘛⤈奍쥘啀꠮낐`ꇔ谆ᴩ洂ﶆ䬢祍䂤䉌析됚䓀뵹䘉噳⎗钂Ꙧנ嘊찕泡᥃⏹䪏끥䲝阢\\uda16娶癰똏⹝곩㭓\\udbba颠ោ⤜撑滁융Ҩ䶪ꅒⓎ㣮ᄎ⭱‗஡섺䔒⊓蒆⸱儡䱐ⵂ摕鎀܀津聰ಔ䶳Ѝ씇욚믜฀깰ሊ얔펠⮽䔘࣑暉ু窸䝋部蘭鱿ᔀ뢹灘䩫碨샄㍘ዤ霨ᮨ붎߲텎譈寣씎繋탎ꔵ༨풼ꎬ頇ﶄ嵪윿㺑㤿ᦜ✁㱁욅옔色Ǻ뽷邙铼ꏍᦤ\\ud94a騴톶颈逍耄쭾ꉧ걀Ө괤\\ud8b9ꣷ妄㧂蒎╢讉⾓粍쫮겘잨褥䵍꒓ⓝ珦ㆼ薏ڥ릔鴍ሊᲴ줹估႑犸釩ⁱᖎ녰׎ʐ㎖衐씨䶅裭즧뵀隩녧ꤏ듲싦Ԫ㰍偈脠ᑀἎ蒨ꨩ垾ﬁ䂝ᦸꆌ䲼䕀쪐ၭ腵⏎졋褗砎H倒ఖ\\ud8cb炛⼐跣뱆րᬇ龪ᤒᬐᩕ祖⃠⋂䡒爋ᕸꭠᓬԢ䩙镰ചݓ烈檥朒ܫᒦ㑙向ᒉ⥧ꤗኢ窸⧗Í⢀⌈⢸Ȱྠ㎷㾗烈ؙՃ찌젩攚蚜ⳣ\\ud80d쒂ꐂ⁍砘ዒ‸͂櫅Е唥鶋锞ᔕꙵ▛䁸謸毲顒逰ഥ躈褁싲ꩄ䯷꤂䭟ڋ柂励邑辊⃦초臋㒖်ლH༐嶇帨ꯥ䬝횕ᓓ\\ud880심怶䵡臾츴널嫨₺䗣珥碊욕鮥啖\\ud964즟뉇댔둭䀺櫉ꑒ瓡鮝㳱坏䩭裯ᵆဃࠌ枈獑䲅斧㮰佈䙠讈ᰢ쾠窿^ᚬ疞袅჉꠩அ䩨♢꠶⚬⼡飫峓ª銀ᵂℍో匛簷Ըꝺᗃ봈㲸㐫⦢됆ꀨ耹辐尵ꤕ鉵\\u0010⼁ꠁ۔⫤ᎏ솂늠\\ud842쭦솮虴ざ䲊\\udc61᠟囖饸⡎帶䠒옐榥㸇蠘〚訆ڔᄐ૦≯荥逄銸ᢰ䓚뵠뛣聼荚앎⥤봈機䲤䵺㝖尦ꆶ㏠ꨀ콠茯ኂ狀㶮莦鄴⬹蔨準碉탛㳌㒌巡\\udd83썅너\\udbf4䑦〉䔤漓䲍ㅞܝ၏Ԡ䃳ᕌ邚쫓発㻎胫溛苘蚱딍収锬꧿廴췦⼳跃줋篽祃媌㒑뗡\\udd21썧탢큆赒⡺淸夛⺄頡띴톅Ћ䭃V࢐콖膳㠨♥㓌쩡ᤄ髰鱲㄄밞঄궯⿲햊쥆⟛脝⹤傫䗥ፅ꒰\\ude28ሢ帾ॖ奙짘ֿꐌＭꘞ꩙➭䆘脎酼茘쌳곎䤚硘죨넭꒰ﵐ婠倦몪ﴆ虔梖敛ꉥⲎ뚘ꮭ胩硖᫞៖\\ud8b5ⷘ⡖洂⣐싔皥답鿊\\udd63⭝ᦕ䂳咅렲殉Მꛐ㔼ᱲ鄃ላ뒫곢뾺玦ᴼꁛ꣗頺㐱ꄀ䱭ဋ᩠컆阝䙥⫐釐둡㔅괝ꏈ읋ૂ퇺좷疿ᶽ橣縛岀Ⱔ땓Ჭ㫪䍸훂햫㧳쥁獚䚃ḈІ❁᪖ᮎ쎠뜭릟䓮䕛痜蛶떡뎭품᭫酻鍴ǥႺ\\udd24꘶溲얋䂡獆੭㴲ﵷᬾ膲莾醧⇹セ맒瑈ꔭ臨뉤滪䤹鷁Ш锁퇇⊎厽鐄Ⱛ茰௮î෈⢀ꈀ䢨ᚭ㭔횈㎳ᡬ鐕秔䪮ᕬ䤈Б眏㔿竄֥䠠㕂榨౪犦灪䔬⦫晛耾甫萜섃楉﬚૤䅷졟ᖔڶ뱋⩀蠤ၲ蔄罵樼广㞹ׂ硸⚷ꆋ师桦̓嚢ⷃᬷ蠒援뤔혁Ž㉊辈햎ꁚ林\\ud83b䯜䧢璁䐑⃳舊㔓洚륻䕓詂뮢퉕ґཁ┉じ蚬ᓐ룅믯ꅾघ廼皐蕡肮吪ᮖ䛎ㅏ鋼菊蒔⤦헥ቊ챤ᖠꗲ\\ud924ﲾ䥅詒吴쬛턚౐岅爓ꂘ薔⡐ᘌ桝舁胠셙쇡ஜ뾃푗퉷뢴㧀喇Ｑ䈆ᵐ褌\\ud82f焳෰僂ᵉゟ،ڸꢲ䡔咻ꝉ㴇땞왶櫒ꅜ렅ግ傒촁戋䒦肇㥪䫮㊔돶䊢昃饺䁴࿼꜏怆┼䄞蛅쫵퐫飊屢ᱸ䛃乥刀ค戗ᆮ釡ᆕ㓁胬큸·嚡ᅷ᭤臂䱝嗨郳鋢笖ᣧ覴ഞ䐅金尰䜣바싈궶ꇺ▂櫙쎫픀祑洅솮었䊁搗䙯㿑歑逢핸ᚩܢ╦봯඀✀溢ꃿ停ዊꢝ늽鐺␀큢⠗脾⽾哱埇⤪Ʋ㏄з됡ೱ⑃ঈቯ锡ꀫ組੯⮐왬ᐸജ\\udb22氚詏梁蝔鯱脃ﱰ㸾ᘄ﹁랆৅ꭂꯜ㄃㉍呒鎍꣬犀꽉穏쎬뒚⓽⚃佽ᲃ퀖좖\\u0003⣔睖\\uda6cꊗ쀌땦\\udcd0ྰ媅觟渷뗎맩䔸ꠔ膩习䍒ຨГ㸕慟먡阿䓓℄Ⴥ鷉뢯狖邪몱\\ud990衽à챔䊨舿礡陰윙절逌ݫ瞹ꂂ痻꫻匃꫑ｽꖠ\\udcf5⑮ﵠ̵\\udddc긛䍫ా䠁擈儑䏐ꛨ賾箌樰螐鰩㌤涠硡⣓㚀蓓ꥑ㽍㐣蛲ꜽ䋀᠓䀵ⅽ᝼꠺軨盩뗫賡易む⠪홲계涯垺⪆ﬣ˫债辪㤲㌓㲌꙲蔏̱ᆁ댰朖煳즚စꁗ㞆 湡梹鶯孛줙ꂺ딤솭ோ尿୾蘤粁๷ܾ空詭姻柈껹鎝䐮䁧㆙첀ȶౢ䘉㻼援〫ⷹ魞ꊨ엔め콄숆ᜠ뗘訸塥잵\\udb6d綊腊\\udc9c볷Π댙졹Ꮷ᠏׳芎緳䍂ᅿ㴹ꟃ圧С❳뮐麲⹹उ﯉拶㌻鉰츮殰≮軈皭和흹ꗤ㹼讔孼﮲⋞䓾琋豞鰠ᚃ䈅ꌃ蘁ڢ҂쒼璫㩓앶윋䔜諗⺱ꩤ厘蓔췣씇罂ⵃ⾳ꑜ흋赅枡ゆ췺⧦械詼쿆缘뤂መꁋ㭞\\uda06‬䬰忘侖᥊捁௸᫠૆㋨뀀椰莐᥀ᙇꡟ䀃턕髉맀߲쩀\\u0005䬕낂逈䬱张ۀ娊▰걙祁鉟띔穤뇂ﱡ炿愐檳鞕閜골ോᣈ틍ᦀ⊬ꮼ䜪ඁ햳⻩악돨龍\\uda24촼Ḉ᭙뢝饘瀄즊䲹㿀ኝ✑垾ɰ窑紦혢♯㓻㢮ɷ롢ᝰ枡쩭Ň䬥ⴎ骨ꌀ皨披芗艼᰹첅捼栮뚵肂㢊ਂ̱⍀\\udeb2慩鞇䜩ᤇ⺐熣螪뫀ꔢ䅔̲ᅴꔨ㡄Ĕᄄ̃퐣児伡א꺀䣮揔솦興㥷Ⲻг齩尜ꈣ㯶꿹観㘜ﵦ邶B솀܈垆࠽ƾ୤䩁픧덕彊숋㗟\\u0018᪀쎚ꋤ㌽\\udcb9듌\\f臜뗕త僡蔐娃瀒Ⲻ㌶얶궿ꍶ᪴쌇싣뜭뜌懚뭳⠎\\udf36笉誩埨ࡈ₞隒㙚׭꭬⻛⠱\\ud9f6춶秼慓ឫᾚ닒ꏠ뤭㙤⃵ਨ࿵뿆ᢸ\\u0011橽䑛腉ᘲ냲浮謉媪\\udd16δ滛璜멨介뛝덚佮ݶ㭝\\uddd1鴌Ꮌᶪ穸髫ꂝሄ⫚້田ﰋࡸ\\udf73䭼ᵤ恞⃬猠暴軟白몵⇭潳灉\\udd27㝖伽װꈳ軪볎㪪븵ꚶ⥵墵\\udea0⪗㕇뗫뗜轾묨욾釭㝄㒦徤ꡬ率࿜끉དྷ씪扞嶉랪졪䤘黹娦欖킲\\udfdf\\udf1f彉站\\ud87d\\ud867\\ud8dcㄈ튀᱙⠣ป࣮蘂姦䬀周आퟭ婊\\udb4cお䀑ᕄฝ쥒蓔ᅔぉ舀Ხᄝ⥞瀴⁡ễ羘㠆ꕹ聄ǁ뱄䂛៓ᕓ갲劔닛ീ㔎벌Ϫ뎮\\udf4dꀶ嶫֬ꅥ춽롲\\uda70所ꨋส萣誰앉뷓垈⩇樕蒻熓\\udcaf訠ꟼM쐟찓䐋᧩⑰䑛⭵␃㓭\\ud818§㆗쑣勥崀첍넷㌍䠅熒樒Ǚ꿙᙮꺌䢤첫뜥ࢀ\\r⏓⤟함\\ud8c6쥕瘦ᔾ湭⁛\\udb4aᛧﳏ巿嫵춺症紁ⱸ퐄햿蔻쇦杁\\ud882靷₣秆೺㵂玄꺂أ땡적‍엘ퟐᐃ茸\\udb69\\ud8b7」켠ํ퇆ࡄ⭉厳閜ꀀ탛遼쪠ၱ甌㕕ㆭ鄒운֝耴덦좧䷑뀕仞켌ﱨ籯맥眞病벯༼鷶㞠ɷ驕鼠ᑫ猹㝌娉Ũऒ䋩⴨珏铨貵ꆜ豈ʅꀕꀑ瑃ᯮ䳼䒌ã낀玉ᐧ⌍箰櫮䙛쿨ι辟趶옂쒈梷㎶힓\\udae7쳒숀頙拁⊀▪絴㇩ꢚ腳荏ꇃ⻤伸踎腑鉽饝ᣚ⮋䑌\\ud82e恞㦐\\u0015槈瘀᧸埝醭ꎓᙻ埻੊ퟎ窺閂ޞ特嗜뻑뭫홋븕⥩铓㨨ዦ駯矗ㇹꍭꋍ坃헜﫱땤璘ͽ굙颺\\udcfe⼀။䜣쌗뵃᫵啡欎쩚ﾯᮐ嗹㊲噌ꎢ跽䤮ꈰ璢纪뀳렡ᤎ癣漢첩蘬ヸ钁蟒䅳蘘̹\\uda15ꆞウ恠嗒鮥fŞ輊딽큘勼낎ꭍ툩옌਌ۉ앁誡㡘⨹Ꮘ뷹蛭़䐰眼愑䗟죐҉皙⊼䙄⌙쓨\\udb46⻥瞼䱼✤㢛⑎荖ޙ辁ᐴ൥ೀ⠹Ⱡ⭁⺻캔숗∤駝⿞ㅃ\\ude54嘢ꞻꢼ䑹⪄녞蛮텁ޠ팍쎒箽쀚\\ud99aѻꪉ꺆ͱ酃툨ᆹఏ渐擴瀚⒑\\udd68ऀ⳻퍲둱≶Ꮫጯ풐쥔啹뱘䠐⚊敭뤀ࠓ몄숟䢝巎鸹桡䗶⑄âﺄ稳呁쭗佸࣫䇺ࣧǕ끙ᝫȹ\\udb9e듇鸇꫄咰鱣ᇄᰟ踂쳄䊨༄悡撄Ӫ븼㲸䜏宼ࠡ㕎䟞\\udcb6ㅠ㹽鹝⇿\\udc66ⴶ煼復⛤霗픍ގ⃱띪仏謏౽쏾䐶茸阝࣢篼쀇㮚蟴揇˫၉岼牌₹譂㍀稕͐찴ﯭ﫮ᛋ丫묫ꫮ武⯪朚㦍획ᖦ涀ȁ怇\\u0006皞ⳒᏫ滃替릴콼Ǹ媏꒧⻓뭫꫌宿䲳햾ꗭ鼧舲䉀အ냖褷휀ਛ탰솻ﳖ礇뾍ᓘ⽻\\ude5c᧷흧狠췙\\udf5e钶䰥鞀뿩鄵᭴盕爰\\udf2c애倴㭶酗Ỷ䪯惻ᬟ봊壈聏脁錐ᾏ粠ㆮ㆟殚똺⍟鋄컝窬䱿└齳彾盏㒻糌⻸ᅯ뮢ﯫ寺빽쯌㏰塌ﰃ巶찜䇯拐Ο榽믹\\udfc3覛Ꝥ淰彠犿ꔺᲐ㯠숾䄿놉ؤ䢟ⱺ橤䆸ሠઔ⾘ᚚ蓁 ㇉ꡦ枻潮זּ牗纊람斖磯膿鑁鮓궼℆쯧\\ud846ﻈ墑㴉ʨ⺝ᇨ᫴韩ｋ鉝ʕ휦ൖ㪱㧻׮縭槙蛀뙲珓뭬악룇弾ᣄ冘帠힁쮦冦臀⮉\\udc03胄弘ﰑ벶תּ푗מּ迚ུ뗁͵獏⨡淫ġ৛㘒럀﷐睯酡;꠆珳폭喳ᵢ﵏⇙㖇췷ꝡ쿾숳緹싂ﳎ뾴䔲䯴Ὼ䬭䋐胸뱀ꂔ办侎␌钴漸谈逷쐚惛訾듉ᲁ达肋笥ҳ饰㹀镪耩㻌»锾㟸輦綆﹃嬻걞룎勺쨛㹔ğ鹾꫹\\udf20랒\\udee2맇麺໪濧聋꺮馂蠇ం聱䚊ﭽ輾䭘ਅ༘皻ꆊ⣺뻞艱吏芗梿楛蝠㹹껯䞿黠稅衞瑉藪Θ廢ᡀᐎ녻뻮⒧⠠鈎z莊鈥닃䤦\\ud867莲臙礆腾꥞꧃闦⎟笄§肺ث肅膥莖Ú⨠쁁倭됫⢷૷∢摃惮䲞櫋孊覦㻬瘩㩤툟珺꤆с쬩\\ud940瀝乓⏵迚촻䙪펺뛝念ᑴ각⮋氚큓ृ⬰闂映ࠎ쉓祖ꂢⲮỸ醮큇偓珢ϐ滦獺⿯큮抳ⰰ岮쉃谖쮞⠈୺Ŵல꘱\\udc2aꮵ㫊攏깶흻耓끁髷穴ỷĀ嘂㐙ᤫ캗ң愾駁ꠃ㇉殺븧۽庶뜅㐐」쇖ǜዐ㯁伇៯ᾥ阐憎ࢅ臁ヸ렗ྱ뱏ҏ鴁ဇ삤爴⠏ӵ⮸٤셃錀큝쇔﬋ꢾ렇幦㎐註ﯞ擊ρ搅鷠暀腎쯴ᄴ❾皸诣聊绌ݟ櫀愁撇ᲊɒᐊ৾婚ᘍふ墯쮃蕾蕳埧輝﫧䄶╴먩ꧡ纵༈惎禛ᅡꮚꉳ﯌ᷘρ月᠀㸫䄏놶诺㤆核ﺛբ᧰楠밅珬꾲秉ꊨ纴ƫ﬎컘蔴ဖ釁枙㈟꺅獵묡ꒇ뫥졑ꅿ砈߈䠡矸툗粝↶셚ᕿ逡抅韣⌄ꇧ눍⺄㓠ӱ銤劗吠灶ᘢ튄ꡦǶ滛쫐僁蜈琚样䇬㈖ƨꨀ澱琜풜속蒌Ꮘ姂ႃࠊ强℃ɢᏰ嗁儂ʭ㹡欼얿넡j䘚갻憝藨ͺ㉂쎇鲣ꆹﯰᾟ뉡䢢䁍Ԩꄯފჿꦄ\\ude33逄ﾟ䠯⢨扁뗀∥ဌؤ῾\\u0014㸐į它슠᠁켆標嶶ꇐꊘΠ㰁ⴂ瀗쀽ꄂ悒蝨濁䴅且슐憌ؒᕽ뮲᧻뮥㖰郱蟩ꢘ绡銉갑끗阤棎መ糡鈑㖧ℌ륁ᅰ䈑욒鶵℄䓪ჰ亢⦅蠞ᇐ刚Ⲣ賺꿚꜀垊膌礆裝ㄶ뤚ꔮ瘅㘳롊꩖฼迪ꁬ圜ꛥኑꛚ籂卫넩钰虭ꕬ㽀舑늯뜽䣘렔殀ତ겓秬뮂膫뤳衱Äꧡోᎌ䰱萠ʐ넜踟Ꮋ왙࿄뎀栐擄໷롅砎≮颪♟륦칠濊嘅ǡꆨ⑽ኙ࠱㪀칅撪磮䝌䳱㞑⣭넿酻ၡ붑ༀ鱌ꀙ쑙䙜䞒귄䞃\\udc4b鑧量胹ᑔ埄㔹汬㬔鑑惕ᨱૐ瞎悎ဨᅡꞠ㊐跒픧笞⪇ϸ駨皱⥆耮鸕Ȍ轓ᘠ࿓ꐂ䆎裼筵蝻㚦Ꙛ᜼ﱮć୭㿾袊鑅\\udaa7돭카䮑㞃邇ﰝ插*鰀境ꧢ숛쏒Ɲ₢墫⠃잢爨ᝤ慰̐崙⸔㄁草꓊䅅䉠ﮈ兏맆삉꯮텅샪恷秾䊒ֳꗣ恡擗䙥῔失ᜒ쌙밮쀮斄掓괃퇢䅃ᄂޘ橩팺⩑怀ศﺤ仑릭⾒肴\\udb42Ҩბ兞쳟ꥄ䵺毊ꞃ쀘ꨜ跆좒ᾩ\\udc69鄢ࠨ꜀넃\\udd1b呺뇗䚺촺⾎ꨃ誣䘦态蜧낂뗺콤풛䂀ð渀믗뜦䎢鑪\\ud89d។歆쯃뼆訆狛䑕밈麘㰃冹훃珝梐꺎ꡂ쪠똴⋐Еۜﭱ䜐쐆ꫮ懹갻ꑰ║䷣䀫䒔ၺ륁荺吟晿㥪ᏟꋐŁ㞻캉妛╴ሂ珹╨か燬뮛ⱷ赡딇坩꺎咑䌎ࡂ㜐㜚뻠릛⽀뭱擩鬪ᖬ〻蜟鷚倠ꐂ舞ওข㽺ꏪ砥촘萃釤蹰ᾠ␁⼐衩ᄨ䘍拈儡鑆⸝䑔愌묏ᨼ䟌⯇逗롥ǎ௯ᇠ褀暃⁵ﻀ蟝⭜嵁\\udffb䚌빆\\ud8fa뛂巆㝡桅偠¯僂χ跨됰Ȁנּ阹鈉刂찑あ﹫몠鿜堉菄앬䦽鑈FƷᔖ\\udc4c¿窌╜⫾뛫꿬ᡓǷ쒰၀勡昉備Ἅॴ┱᩟똲徚ਞ됅僛࢐ಂ墁ᕂ透≟⃒߱ᥜ⺰咨ꤔ벤놇ᮔ놘釄癨䐅缾쒖̐᠀葀杇캏掃歖♆䙉釴Ô汻ᑁｭ簩煡骠ⓓ鑦嗇吒殆े⊲⤰꺡붆納\\udc92셸⛀隙ꛂ႐\\ud851식肜ⴒ啖䥛ᄙ꺖선┃간嵱쪋毌頏ၪ肈苐昀㜒눭㱌੺蛸꩘ᩉ死밹ኝ셶舲\\ud927퀕▃깳蚲ᆄ䑡俆ꬊ좑䤯®`⢉럹昒꾩︺蝷⎨뱉㈦妧\\udc24ꋛ舲砌辩㒚ਣმ୊Ⰲ䣞ꑣ홀潂絡뗩怦ꐜ檶᜿꺮ꠀ\\u0000✀⵴嘂かุ貉⑜鄒濈ҁ䅀ꮯ킕場鬒拾ᝂ稊᠀恾菢舘ዄ\\udbe0퉦셨┐쭘䏈㑡⑔銨萑䜧芫쐩줤ꈢ邟똁尥ꄜⅼ␌逢䥶‎㉝窓┦Ὲ뿦度첚⢄肋ⓨಲ䤀圦톣ꢣ짏⚼鋳߉Ფﾌ樏〺誂鸊搩킦슗쑬脂䟈Ꮨ॒橡ᐕ✱˽↭㝀蔫阄쐧刋爍⵽⟀寑砂紐䃝Nꦢ圦蟲ኼﳁ⠈௼腀ો᱁軵⋆ꨟꢂ᭳万纈䫄膅⯗뼶蕂㓡偿觘쯬飴꼚羨⸘횹⺇瀆滌肊엋岺낵Ꭼ赁쑛쫤爈눂䉠ಌ꤀⪸＞䧠▷ꁕ⠂௄挼Ꮸȉ䅙鬮妖Ʉꐡ꾈猡㴤䩕ᆷ\\ud910ᗈ盾Ⳋ⚖鄪뀷ᅖ釳㴩獫꼚Ὰ큂⟪᠖믇꺂琚䑢䈮鈾닩ᇋ搷ʲ൫륶ᖹꢮ﶐焊ٿ泴᎑ツ쌙쁟婀㪈淄눱侥쉦豋䧅瘱煆ﻡ恁㇅蠂겔楬᥆\\ude90ㄭჅ꽛▄啇㌛呫ㄬ쟞鷌符꧃쀠넢匋숬秼拄组ﾲ䁍怰ಱ㑂㺭உ༬䉁鸧씂洞≄獪쎬橴難걐쓆쑗䩬斉僳ꀃ㡫ȥ샽ङ坚܎ꠀ엜ঠᭀ老\\u0005﮶뒞잌✸같织撠ᱶ쪜體ꩋ㉠籤⊤爮ꛠ۪嗬帆嗭碹\\ud878䀷옒㕼㎠㠕槓耆鼡ၔ끠\\ud99f瀝遲獉鰚絎ꆤ෪ᚐ\\ude55Ն鏆蓎䗪㩂椧䃤ꇮ굺裪亖褓塙꛼뛎쯁亞캓︁⡭蒜䢎⥣蒡詀業぀馠᷎䁆跧驂㉓ꖆᇊ┩럘ᩭ䴽⸖㧁괫褚⫪紂법嚈怙鸘蓻榄ﰼ풨ƨ䅀㾘闋࠯夗ᄖ逶䍐뿣඘陽肃\\ud877᧳ꁚ髃攋麇ऌ۟ᯚ稑ᣊ愝⾊椏쟆鏲≩ㅥᶝ\\udc4a쇝膷ᑬ諙䶤뚗楧졿ᕈ縑ޥ覀ᡕ噤䝰鞶烲ݥຐ쮈\\ud99d鬳閌귇ẟ谕䦖륻筸趥嶞\\uda6d\\ud9b5ꕝ韨ⰹ鈩쿠⡯㻘狃鮵ꊩ枥槅ꉻ녭ꉴݠ梑弑褉扫쀺竐ࡖ똀⣣戀я橺擀ᾢ淡쌂쪣逈馟蜠ꘈꟀ⺲㰟槹鹰ᡩᗄ䚐ຎ椕ꑐ遌ँ箣蟬풍쑐䛐韎䮾췇꒞ใ\\ud933씶鬎吹ᜈ蹏빷撣鮮熹ﰳ๻ৗ읶驊己뽧炯퉠䖉ܮ䳩ᐇ䲟婠ᆁ蓛骄嶹噹⸀®容忇䲜\\uda67\\ud9ee쭽陊岖熦\\ude6cṲ맲ই鋄䇩ʃ蘏ﱲ醘戡捻−쩜\\u0010䕁ᐄ㹔鰁踕꺏應╄魲潁榛㼢랶槮짪᪒浹䄷醌麡薪萏剾囸➴੨Ƅ㞝팧楽壻鎶沲봧秎⊞寙팧㼠졉∷윧羹௦ޒ쾇Ɛ暠ਫ਼栆ꯦ㊚쑴⠧੊☐賠㐃ꢈ鱗偪伪祮爇ꊸ밽胱ʋጀ䌗隃쀟蟁鸄ᡈ嶂⬜뛘掜ഴ뽔漀考ⲩ䈃ᖐ潔獆Ӭ枞祡枺ґꓚꄊ堣遘Ę䏢萉흣퀋㛤᧚⭄蠀⼉ह኷◉∤麓♀⤎Ⓒ錓쨩ᄤ豀䩌퐲Ḹ䃊䀃ꈱ娇䉩ុ祅ጡ要襹頗既冄의ᰇ頤᷀ざ붮刚䒙౤ꌙ灜Ⓖដ䐠₅䩁햨薶ᩘ䣉㧀ᙄᇭꅷ⑑鎚䞡䋔੃셞䢊婡橴街⤷凤퀝ኁ嚀먂纄쎷恓䜰ф顴칱築및볂炧쐹܀筳售䙦䪂ᅨൻQ붴莊꺫㧀ⴘꓨ簞肮䮊ꗠ㺙\\udf11榇檫ᨍſꡁ佢영퀆摌ں잜亾ῦ﹢髃厱突Ù䤄裰㿑㤆퀚ᤅ傄候覐摡뀎틮⑙ࣀ⣔\\ud905ឞ鈋頴࣢Ŕ串䏋見´ɟÎȜ섂ᜊ쎶娅兡࿜⑰䄀뙣遴퐛쐱ਠሜ报⚮臙药Ҙ먗晌뇦搾˸阐퉻嘀䔽ᐙ辺㩀攙鍣鹼坢赆袨륶Ꟙꉰᘐ⬕걛冩萠烀Ặ࿀洀ᕥ刧ÿ᝺䳂㐥镈⟊녗廔騄쐍薹≥䛁㪱읢퀂ᦷ뢿䬥Ѡ㠡砠袆ᤄ绔钦产鍘늪䑘檁祝ꇨຯ̪녀⒧䩶ōḪ骪챹䑥ࠊ툰绺蟪⮉芩얞扝蟋ᆪ쪗實儁쀱ၽᔐؠ因隧呎⪪ꏘ랱画萜蹶砉跧闩ਥ邂퐆凴ᕷء䨱﩮膑䑣ᬡ䉞◨莒薀柢扛៸؂䙑蒋샆彌垸㈈\\udd2d藩䃳ሜ哪㉆␈ႎঌۈ鋜⾅嗎昰鹊ͮ지෠\\udfc1␇眙䕺Ꞥ䄥毀⹷쀛킚짙느籍⥬搪Ϩ멤瀀ꈡ傱旚雱ʷ⏪︔畦庌怏걿᎐疨㼄쐩̉씎Ԥ늓씀銠敧鞞袖㥈ড耆멭쀨̊쇹直垡됆㨠g㭮웘帍鎦뻐\\ud99f遙ᦾ짟䟮⾀㤂蠹鳁䵧ᓬ戣줈栃뱋૸ㄒŃ␑☡急菍褝꼘쒢\\ud80e봜૜螺┕ꖂ␍䴮ǻᐚ⋥뙡彀騟루茗싻㨕䞂\\uda8f樣ꡃ䕵൅圶ᰂᅑ혡悬哯໅帥㮔቙䀾؝엹坰䘁坊쥙ႏ譲ꏒ⼕桗䯆∎냛д䌕罣䴆⺋텃ꍉ坉玅ߐꆊ㥗唾প껠؃렪ᖩ쁺鞹楠ഠ츓ꉚ韌ֆᣰ튪〉簃纸幻㓤伛輀耲ᔑ䧱塥炼ሢ‌쨬벤눖๓ಪ❄⤖\\udc3d斦内哚ᢈ艖톬╎ᗳ镹Ȥ⊕吣ꕡ耱⤁ఒ␠寐蠯툚Ў旅轒ⶅ鹖⯄朚틑ꊈ\\u0010ᙕ릩ᅞ᰾嗖ꨕ妹斨ꅖ啑嗋੥丕뙀砍퀼ࡿ镄˕孕䦥鑗袶脋陯㼕闀됉ꎃꢔ΍劢馜卖䕒瑰苿譼໴繘슫ᚩ癳唯ӥ唀摠ꥒچŴ屵箕폘澧伉屇毹⤲賢砠籮穎餒恴붉湛艹윿撶ᙩ鄚衩ꋤ֞０夁⒅针䈲镲幚ꢩ㗭ꂬถ罩ӕ薠軖怹ꦦ芊岏遼삫艀૕頧Ⴁ꺌嘛㢥钯膚Ѓ땖뀅懳霹黁殅΀妫克㧚⃼䀐Ȿ쿣䚔몌毵ꚤ㪚\\udeaa悙홻뉬햫ꐬ눡쭧卝ꡪ镨ᠷ怞環ꗨ甆﬚⹽ꗛ壼絙儊갲違쮷鹆譀巤붟졶컋ꂩ銪龀鐁צּ努瓖픜勌¹湖֊ﲍ뫥攘잃Ȳ所읕ꄖ뫉푅雭礮\\udcd7倂긋㗘ꋪ䢎ꛐ抗ﻺǐ꼊爺臔☙㉊ꦍ喠涰▪툊耏㔺䚙᧺⁚銹쿭諭⁝쎛勖皺읦\\ude6f쵱疠♗桞걩읤㭙䈀뫅颂瀩ᕃﻂᔈ؍囔奠⭜꫗磠㎺㦙螈錣㍵띓⪇甙쎷뵈湔塅팮驒몧ꙮ嗂㺃枬麆㧛㣉厖ꋞ⤂鬇ậƤຶ䲺斤셍빷䥳徾摙蟤嶖뵤섕䇝ꁄ길⭳䉝♙灇풝䭥먰햖錢寮ꏲ誽熵ᎊꮯ욚椝䂊䅄ୖ⌢ⵎ畟敀흏껹燤佐ꖰ祵ܜ՚䔂젤³𢡄\\uddcdᢠ齞᰷╔⏊ၗḍ㕚╍ᖁ檀큃倹赛玙ഘ좛啃朵ᵂऊ搃൵葛営坉水샟湘후㑵ѐᩂ폕ꌋꮹꋂ㗗傴रጀ侯욒⺄ɔ㬰ఈ齝粴跣户㲍옒뚣벙䗄ᡙ啙ઍ詁꣟Ṃ陗坐ః况㨴僑홠떣휰\\udd1e欍뎆壗빟\\ud936㕡ჹ輍䟉\\ud95f襵ऩƜ廦㠼낊摢片骸\\uda9b럵箇ӓ昸梾τ퉷ꝉ䧻䃞슼暈㐟黀戍䂧⃗ꮋ࡞ϵ쥹疼晀晅ե擇䆨ͱญ߬␛廷ǉ堉䊩樦ꢪ뤘攠ɟڱ甴ᳱᙑऴ旍䀄঩㦠ꦚ㺛শ腱锦庌柩纟ⅎ㆙钨标這ꩊ鳟䂙\\ud973䌅뜷鉠뾴ᥞ晳瀭㽔㙜\\ude28ᖑ䈂ऋ概眐砜꩖劽ᣥ耱뉐菌ꀨᖍ텠♱믩ᆕ酻볶呰傰ƞ扦얃腣랜\\udc79纮뽚恡畆唈˝广ⱐ冡䲪␭蔴늈跅椄⮍焷ⶼ뙱䄕呕萉圏車͇ऄ࿰犆จﺎꕔ떱圭癤幂ફ걭끍㜷ꉆ╊箩᎝\\ud82a㕅삲\\udb73䈭뮙圥耪퐴峉ᬤ賦濌⹩䇾林᠖敱醦鸙㉎첣埸ڮ둰\\ud801㑍欔不먐ú뼭옓㍕Ṝ൹퓼谛嚍ྞ뵥傇ଈಀ␀툰찲萯ꄫ赀㟔ⴂน逊Έ옯ᝰ낂渁琑㗟㉘뾄⮇㼏䫉㮰㇂֨䍾舥㞅ꩃ䙭쏊쵰㊰좠ਇࣵど魘썩跇ڶ퉉䑨ᖵ长樂恎䨍羕\\udb05㤣瑀䀕惰㳐낁ꑊꀄ갻韠@⼂﷖ཟ馚疦ㆉ఺ྐ玵㻅ᚶ᨝䈬ጆ錍멪㻜䖄衲臓吒焖珕莫鵈뀿⌯堻㣭㪸娟Чꡗꏎ脘Ѡ䖂躋妓뗜鰛鬖쀃뻚縬㡺ꝕ踛詮嗀ꞩ⮲왗楖晖뎵ᇔ㭣㈩둵࡛翉䲠䣜㌲悬锭䄫兕宔쏠ᑽϞ퓽䤨व솤읢닰㖡꘻奍僊仝횵൓㯖\\udc63䏈ﾶ떕뎲뺞쇋ۭ蠂ᘈ陵ࢵꎞ\\uda13龼ᢥ盓搌ﰏ럴큈徹ᰵ䇐鹳맥㞚腝摀陷、ꠋ趻୕葐ᒝ㵨얮逿쀾矖\\udfe7瞍똵颋䚔\\udab9㕱ꮚ媐⭊臜魉\\ud957↩ປ䏦쭦槔荂ﻰ䍫櫱幭ַ萈蜖쑰ʖ\\ude5b敭훐蠆偃̠׸⾝Ȃ뉅뤌溬婷⽗䭀遁釐ﭧᷥশ팀姘䌂瀌뜊䫝럚켓才鰵뀙ⴎ㔍ࢧ屙쩴ꊀ읆ô뭤풻壵脵鴬侰䃺畮\\udb59ᑀ厓芔ᚏ饻滆쀷凕⹨\\udecf됼諻愝쭵藝ᚡ㪿딉ꆧ磵㑶跬ݔ۳푽푣Нꌸ⽛됌ᶇネ퐞ꈝ졶\\udb00먺ᶘ県ඇ怩陵\\udcbd\\udd5d살ɇ爀鵷➬뙋疁\\udb47籝퇘薃\\uddea㓼蛇垵⧪꣙❉㶲瞱\\udc3a䊝餷더Ꝿ趟䋬涎눺姊﯃膚ẝ\\udcb6᧟땭棧瓙홣䃍ᘵ೛͈촲皔퓊஝⍥帕촥훃留\\udf6b㞝돘㊢꘽灪受䌔鴇晨힯簝쫨㏞鍰튽傚讴飞띠涒㓖툰@퉔끒ȊҘ舿ꅽ䭒揄浚‖헇ᗾ檩鷬橁꽮瀭궀芋\\udd6e䤩뻧냘쾒䶓睶୯尝삙㍹䲛埀虆㧚쾃䟐『㖳獵혃撮ትᯝ佈㫹ϯꚓ䊲⛖귘嵸蟇\\udb3e撽嘴ု鵄❏嵅茔吅卐覰\\udc36頍낳\\ud828ᗌ窄ᰰ㙔蚳䒅䠱杨吚껍ퟂ⍫㶮糬앥꾄雍ಱꖈź䑬αꮞ頍簟䣓裯ꡐ꠱홄湏늺ꒁ遳趩˽じ⨂揚䋡癤幋椯ﴎ场亙൤妓穏왍⮈勺氦꼴纝·쵘야\\udbfa嘦ꗢꅰ᧏䫿斸ɻ뀇ꤧ뷜鄚䏿岕\\f\\uda43δ뙗蘀\\udead透ᵍ୬逜耙⸃솓뿜숱ρ鐌เﵠ䏢\\uda43䭫蔝佀튜鐱ޅᘢ諄Ë⠕ꀗ頁\\udc1d针躐ઠ七᫘禮\\fપ馥䑬腋활鎗◟⨀炶ȍᴚ틒뒲荠↴쫗렊䔕፸씗➥ꅓ䍛䠃√궰ⲁ⦄네䚞傇풲ꈪ䔅撎番鍥兢ꡜ䍕ḁꤤ낱ຽ`祵ᕸ䰁Ҕꇈᗉ屖砡珐稝騈憆芍똀寓紗ᕪ띁ɥᦱ㉃⁖⃱웲螪૸⨸鳑鐾힜閟袌̈㒙躛牏㲈ㄔ਺⎱老ퟯ儬獅ﷅ宬倡ᑨ駡\\uda4d獬斯Ꜽ\\ud899䑑漵‽颼廯⪠㌤ꊅ뼶┟氳༓楞अ嗣ⰺ奬믃ằ礘堡啇臚敄㑢Ꞥ⤌\\ud959᮵墂ฤ坦ᮉ昹瀔‑໙҄颈ㄏ描렁咈肜ओ된㞄郯ꨗ噘ꭂᭆ闂䈰ⴭ뒾⡆輛䱨켏奖\\uda3d尯Ʃਓ暕̢햊쐫黠ឰ角⺕攐葚耏ꨈ聹폀禙툽괃囘䚕昣⿶簶\\uda28剓䨈褎਴뼊籮൶\\ude34ꧬ핈྆倪賀ݞ⒈쟃ፖඊ➦ǒꍹ狍逸ꨱࣆꌭ뮁輨蜙㹔耳鲻椸ۆキ羛㚣ﴟ瀘轄㔨희\\ud922䓟ꉃ鰍உ姀ᢐᕔ㪃氤镃ꎒ奉維訶悔\\ud844⏮辟셬䞘㮗鐶ꀃ㣪㨎䃈嗻阝ꥀ܇첹汊뎢앚啴䶌噙寿귵뿩ᇄ裬掜偕ȩ薕耹ﯔ䫧靨娂᳜贘仭骫耓얻힯嫒㬨庝ꉊ㕇ꎾꮣ뀼裐퇈낎୚᧘ꎌ䇋ղⶨ럜퇫䝘빧竐쵯觡ꖖ谷鹹邎䇕睑谣㩫ꕟ睠䫕ᐎ䀙甜烶⪯篜겐阂ᒨ㷀ꀭ\\udc96丽녶坡㴟買\\ud9c2䉽蔴㧟䵲嶲\\ud99f焉뀃匝堷ꚏϷ큽嫍괴凝ֳ綻萙ꁕ頑㇃ᅔ淧y홐⣝扶︷澰䤈쯕퉱߭뛖縺㞴省㭹驭曷ꗖ㵑ᏻ૪湭禮渆읱津痳ٗ牂営坁聵디ಀ⍭̻ⶖ彗㶸\\udda3௭쎡鄴띊㵞㔽폻槂羴旘ݗ鉬ꭄ罶퍟ꓒ嶋흶ଇ檰婌넼㾸㵞ꊡ\\ude87唶鞏㫝옊붞矚쌏潃㡷㗗ᮒ鍄횏䘽敨ǝⓕᵎ媏貹ݲᝦ桵㋹飑㩣ྒྷᾷᯒ㭙㷕\\ud932䤕\\ud896Ꮘ愨螺쒉푢ⱽ\\udee6럓빠ፉ퇈珱围⇕魛淎랡騂ࣝ岦쿦흪鏚蕠㴮ᄺ藒퓁㨑睜锶ꗝ拕\\udfee蓡\\ud89e腡㻛熐쒁෗蓵鶄佩㨷뚡곷鄴䝥Ꮓ쭾꜔쀽蹷ⓚ靣ፌꅩ㏃九㦷쓡崼井ퟧ祝햶훚콝巵똵\\uda54ន땙뗑흀냤畉㥇峓꧗줻睰伩㧻熺橎紂㵯留㒊繦彵磁鏈ꏽ홸\\udc69ꙏ餶悥鍷ⓙ㊇吽䖀㤴茓䴢໤\\udc3d롶웫喯펾休\\udb0f椝⽌㻗䌰匤ꀍ㕄쇉돒등Ꮔ宭㦮褳襏鸲铲甪↔쮣奏᠃铖㙹䰕㋃䳹앏럔千릣㚁㣏䱉錴⯟㴮웲ፍ㚯泾髷町溎뵦̻奬觞⡏ℑⳠ쵎팬첽蝤某계ᏭȄꮖ絅╕뚫ӳ귥ퟗꣽ۴細揸㊗\\udd9d婓鈴脅ｷ붿墄윕蔎ߜὙᡂ뤹渟烀鹡謷鍱댒㇟椮⎵꟒껙\\udb9f仕支敺붷斧햯体齂耓僑痁ᵍ䩍쀷כּ杏椥䱋祓\\ud9cfﵬᏊ픠耿忕喐듛峏䱨졀탊撍祖䕘棑率貑ᦴ쩽蹏帱촭㪀⏣ͷ鏙职秶皕㼼읳\\uda37༫ꮑ嚧퉯ݺ괈΂앢췩挬\\udcd1ȓķ㯜㌉惡⥯亿欦濥ᘵ栺⌤ꥢ捃㕗톰䃨ᚹꢐ๸姢괹䳅ಞ蜁盥凁꺥璊倬ℴ㝋婤㈎⁑ﴜ䃒섐旅滽腔뢶媞䃻ωᨋ渔੕ロ׸蹗迠嚅강枎᳒‫഼턡硑养ល๼\\ude99䊅氹胒冪䫐멉㴋큻瀴싖꩹筶෇䝒⷏ᐅלඃ咈௃ឦ᎔ꙻ刂똨뉄⊞䚎␲棶ꡦ猕₨䍮᲏쪎识ၧ䷐௘∈\\ude80橦梍팲㣐ض팓숃➓䁬닠è펣庎ᄄꍟꍾᯒ㒢콀\\ude25鐓룸륻輅選욣탏팽ᩘ姆佋틇某逄곓奺㝎\\ud826蠳㷥㨐暯閅͸젲뻠⿵㪦퀲⌼谗劮ᢐ纀쟨ࡄ깞쳎횊ⴽ㻗Ⱏ쌣䮔橭陔餯撵厲캎퇒ᛴ䳩䍔⬞᪝쟟絩콋㵣棋쇧놬絓ल闠랾➧뾛뼁㤶ꚞ쐜樮虥瀞櫶㈛傣캣攅撮堶䣸௑ꄭ嶎房ጂ툷䍑ᘋ⯓砕萏Ṡ䋸㿆ⷖ勓졌蒏捥슛헞ચ踕歷싨馫ꅂ힞֏퀀엞⬺㰏㕣렏ዼ‱㔱寎뼵솏盆⭋胘쌸䶎䫞姰埸ؑ⡆퍓\\udf54䔡詰껕䤒쾭턭𣏕⹵燇輢謼뽷⒴悢嵩ⲁ㬖꒵椓멄捡㦤䤯郊ⶓ塏曄쨃䔽訚퍒踤몴﹦烌애횩鎉랛큀鳝嵤⷗勆앓퐮퐭拐ꃎ歙⺽ᨺ픓껪Ɦ۔븰\\udf47㶩⾛㺒樁쬂깴딇戳⃴ꪺ쓾৑䂽螕▅\\ud921ϋ嵙靚據﫷㽓䳳玶훜ｋ咥䵢老ꮼ챉굦㓠ﴘᨲꍮꯆ・㺝徳潴隰Ӕ덀亻圪홳䦯夵魲悗쀽ߣ鞨◍ᮖ峖댱楗㿣埵᭶좪쑈ᮠฺ헨薂ꚼ搆歟諱ٝ鱾⅍볤㨡ꋵ颪잍寎絣̡쵯\\uda8b엾団鎏≆샲䍋ษ椀葂\\udb43蹸壟忩ꈀ况忣\\udabe䏧삐剡㫽ᔐᢅ\\ud95d 䏨ޖ⨅윀⑧Ũ렓᫿辻உ㰓ᥱ鷽銙蘆㈛৉慛ꔊ傊蔋聣裯遨௅킥芠ゅ蔁夓䅾쫅鍖乙⩅햑㤳撌ĜǙ᳤騂낿쒚쏰౬㢀밬ꀿ싷췱䘜㲡䢋▲놸쒻ᬆ踱◆켛籭ꂡน兲ⷶ䟜ꩭ\\ud80a㤿哻睎䯆ﬂ栎뼤茆珃蓤ཱྀ탠曦sꝴ෣⠊䩬膢㣃ᛩ訠韕䡸㕞逼퉊嗞ʶⷠ㏒千橺氌˘בּရꤗ蚔馆⢿㦈ɛ㴀㶩䌇ꏞ淭\\ud952㨸輙麊鐤孪艌꨺ᣨ老哯傲웞鯍䄶\\udd00뀍蔒鯒ᒦ嗺咛\\udb0c晛⛪广㓦塙➛畮좳쐉擧Ʒፙ橰噈♉ᅠ⏑ꩮ쑈\\udfd0钪埫萁픃銬ؼ᎙㿉ᦚ儛큢뫺檴摨옓丨驿䍨쩻々﵇鶓\\uda90䇚脹㏉↙䳘̮ˑ검⃎❂琙䀆ꄋ䆥뷣ឩ恋ᦉ梢槟潉侍悶뮎麧ዘ厐چ뺲얳杦\\udb33陕䗾ī㶂蓋猸ⷐ陨\\ud9c0㘋奞幹瑴㲍噹撾腤뗨㪹ڂ\\udd3d搨㱨㩣추곹\\ud9ec탲ᴻ絤괌貾⥳枤ˎ턀瓏殕癎㥰榀\\udd92盳路鄜㍘歲꽰\\udedc짫텧⎾㯨랚헙㝥ᮜ蹇祚꿯鄊떬죄Ђ씷샼䋹摰薀綕덅䲛㓫꽫䥵㧑哹㪮⾏է껴㤺뾮䈹ꛤ炪㧏搇㰳঻皥鮹ဩ酽卮目ꜰ䵰\\udddf䕫샥⮾㑮ꛯ媡滗⦘ʋ넿悑ﯘ䟞\\ud836䉬胮싋宜ⷭ`伋⢚疿↌鬇໵둰｛ヒ趸\\udef5쎺溍눾꘭\\udd80燏ဋ胧钔䍽罥৉ⶁ颎ǁ⑐䙀豑Ḏ\\ud87f琝̖䞣췡퓇\\u0018뀺敤밥뚲肎盙橐蟘ᶱ₹칳离搃ᗦ큑쩡㒡﷏锃䗺礊湺━鑳悶舂陠ྃ鞅뿥磎䜘\u0026㾖⢍摃帹谢ॿ胠ᯗ昲\\ude1c꓎蝪骴㏉堈୊啓쮻㎊辰亪줟涒藶\\udd66뽯孀⹛꠻谜䲁໘륂껄뉍幹୎頊뻡ꬺ蕗镰軻淧脻\\udf41噰膹및℀鼥啧꡽嚃뷒ⴃ癏౺蜟멾\\uda87〪諪䌖ꮫ㫜⟓悇蠟ꨤᜨᡤϯ둘禄꟯椢ߌ켦떛烘㠜\\uda10称Ό틋\\udb66䬺닣뮲꼻맜夡垼㵇츣\\udc00㭡ŏ흞ỹ䊑ഞﴼ幵ᴓᇲ홲ᱢ¡섀鯧ኜ닰䜩뱺囍旛狻玫뱇蛯〆샤琗뚑\\ude80엮잰稝䝞੨緙େ䔝皔黁䴽꺧럚邩ᇾ໰霏ꃴ졮靖瀄釂탭ᴗ빮댟퓊绡怔ㄌ紾䣇틭鬰軸毲筜苰ࠝሏ凫Ᏹ᷸碁쫇洶⺶䜙Თ뱅炇赤ᐈ堧蜕핺ﭙ垶蒵썂憁㞺ᑂ斢涷보ݻ飅졝⛚̩硠㟖왞␐㞺ᠰ\\udbb5洛ा쿒輛\\u001d㡧싑啸괚\\udab1ඍ縃䱗꫆歆￧笸࠺㡌ꛥ겂ဥ뛀᫸ꋎ䯄㧬ᭁ⟍憬րᙔ饐ტ㢽꠲৙堠笠鈁䙡䒐ꨁ헮艿䇄豜ṓ╫绽객斲ໃޮ΃눮搻ㄯ䎰⇬㭺갼覱จ뜡쀀ꈨꞓ\\ud942謚⾣ࠈሒ蜓㑁㓭傀뗒啕魤춼鮘䃪൸行ﳦ䉴릘⒒¶祠⺟倏萸쀺稄ᖸ䦜舋髴잓㔖঱む递搅杇쿠靈䙊별鴌\u2029ৠ㕶늲\\ud947⌬嬼ṧ 鼌֙ꢫ읝ᴪ蕐麜龳⤓餀ᭀၧꎜ耆᧏섨龙薜면悒褕鴇ՙ튄⨧竐✴᳗덨렧㕯ྷ⟏ꜵ뺰ﰧ炴觚敝氈뚉킋ᢟጔ㻵麏눶ﺉ珄䶳\\ud814\\udb82໛䠈垰牓懒햕숯㵚⦐戶ᲅ࣏➧갺罰⎓都裝思⏖풥㲪\\udecbᏅ낊䩻犺Ɬ䁫㺫췫凇ꩪ걐沖蠮犣巐퇧⻵띢흝ㆵﮮ⭼던\\udee0ᅒ媭㨲澟鮖呰髛耈ݼ솀焁倜紕ⴊ⨰꿘㖣梱뢊⊸ꀹ텩蛥䟆ᙱ꧵ウ鳽둈膧㽙᩼໥\\uda9cᶚ緁얧밝፟릃乌鷬鰗勗ᰅ촜ፚ揤섣宗ꭓ᧼폹➞㸅停夑軮䮳⹗⁎護뒳⫋㎳픙㙪㚮ሷ櫑೔⢎뎫糔嘰닰땂ꖭ侫㋪삁굌綊に殩쟙蛵⮘䧨悔嘸혳堩插覍굂銗丁ꗔ㏉적틚췝髪掱鳛튦䴻厴们⥬딒⩠ܚ욹㷄★껪쟾츛㧼䆚댓稏鸈䀑⥠ք♵␁ஃ뗖ყ楓㌤퓗⧷㪱ᇖ綁岡獸宝峑묺嶇돽幢ᵍ烵굱痘䟓彥繕쳵ꍺ욷㾁舉꿘퀍䏘䁄ᓷ㿼㽤졜í髡믯䲅㳽乧竈ᮐ嫾댩᳖悪액摜〺위斉\\uda03樲ĝ槐暷뉲咤ٯ뎗㺹艏靆㎊땪\\ude79ꞌ獹黹⸁幁絠ᢠ⾎⎮︻춖듙᧯嬻\\udf6aැ䴅\\udf0d펓ῑ\\udd70΃겶뷸\\udadd茾䉜杈\\udfc5摪泞骱듚笋콡㝅큗沓鏗跛賵쮽슠㱨\\ude33젴䭿ህ㘌䄟\\udbba᡹Ὃ祂脀䃔ꀉ㫛趖毳狕뒓ࡶ\\udacb귥瑬㽥겹\\udf66玉겥箙춳䜳땈瞐ࡳ㥳\\udacf耵猫琷垄擉⮮ᙼ⦒ꝧ従狚썳㪯홺减뜊眯箧榘捈쥐覐\\ud9cf䆪弙ᄣ⭵ힴ콍ꝙ\\udc88쪫娀᜔⿍낞勹䍠럕늜℞䵻緁땔ㅠ퐁઀ߟ餅뛈ﾀ﷦砍뺗뀨\\ud8c9쀰ᤒꂡ羠聈\\udc79쳊띡༵팸ﶧꛩ춥\\udd07擣夓\\ud82fㆹ쎵ᩝꘀ軆\\tιǂ䪦聰譸㡛╱한愔ꂇ猄㧆ล熐ᫀ䃏堼\\ud928ྣ돥갑ꅶ◝到\\udd84ᑩ䠁뢃혋᪯ᮄ⌖Ɛ⸸蜃ো၈蠆벁1뮋ꁁ✹檵报ß㫡䘀ሉ丠䧙杢䦘㳁穾븠ꗩ슠殢Ś\\udb83ᔥ毌и㦴ⳓ됶嬥凉ꚋ粎鋌㡫ꚜʉ躯₢좲蠉렳짖㽗Ŀ⡱앂ᆣ\\udaa7攴肺ૌ帢嵢ⵀꦖ똮詾ꏺ썱鰎꼙裂ཪఘ奝屻벼업䫜몱읁琑᱋ꪧ뎿㈗݀\\uda81뫚줺偈퐢켸ﵘ\\u0005޲丯⃾Èະ巹읃蠌ᐐ\\u0000\",\"actionData\",\"errors\"]\n");</script><!--$?--><template id="B:1"></template><!--/$--></div><script>$RB=[];$RV=function(a){$RT=performance.now();for(var b=0;b<a.length;b+=2){var c=a[b],e=a[b+1];null!==e.parentNode&&e.parentNode.removeChild(e);var f=c.parentNode;if(f){var g=c.previousSibling,h=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d||"/&"===d)if(0===h)break;else h--;else"$"!==d&&"$?"!==d&&"$~"!==d&&"$!"!==d&&"&"!==d||h++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;e.firstChild;)f.insertBefore(e.firstChild,c);g.data="$";g._reactRetry&&requestAnimationFrame(g._reactRetry)}}a.length=0};
$RC=function(a,b){if(b=document.getElementById(b))(a=document.getElementById(a))?(a.previousSibling.data="$~",$RB.push(a,b),2===$RB.length&&("number"!==typeof $RT?requestAnimationFrame($RV.bind(null,$RB)):(a=performance.now(),setTimeout($RV.bind(null,$RB),2300>a&&2E3<a?2300-a:$RT+300-a)))):b.parentNode.removeChild(b)};$RC("B:0","S:0")</script><div hidden id="S:1"><script>window.__reactRouterContext.streamController.close();</script></div><script>$RC("B:1","S:1")</script></body></html>