<!DOCTYPE html><html lang="pl"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="modulepreload" href="/fetch.js"/><link rel="icon" href="/favicon.svg" sizes="any" type="image/svg+xml"/><link rel="preload" as="style" href="/assets/styles-CguqvXB_.css"/><link rel="preload prefetch" href="/fonts/geist.ttf" as="font" type="font/ttf" crossorigin="anonymous"/><title>Renesans w JS, czyli nowoczesny JavaScript - Jakub Szpil</title><meta name="description" content="JavaScript jest językiem programowania, który jest powszechnie stosowany do tworzenia dynamicznych i interaktywnych stron internetowych. W ciągu ostatnich lat JavaScript znacznie ewoluował, wprowadzając nowe funkcje i poprawiając istniejące mechanizmy. W tym kursie omówimy najważniejsze elementy nowoczesnego JavaScript, w tym ES6 i nowsze."/><meta name="keywords" content="javascript,kurs,wprowadzenie,przewodnik,web,frontend,learning"/><meta property="article:published_time" content="2024-06-30T00:00:00.000Z"/><meta property="og:type" content="article"/><meta property="og:url" content="https://jakubszpil.github.io/learning/nowoczesny-javascript/"/><meta property="og:title" content="Renesans w JS, czyli nowoczesny JavaScript - Jakub Szpil"/><meta property="og:description" content="JavaScript jest językiem programowania, który jest powszechnie stosowany do tworzenia dynamicznych i interaktywnych stron internetowych. W ciągu ostatnich lat JavaScript znacznie ewoluował, wprowadzając nowe funkcje i poprawiając istniejące mechanizmy. W tym kursie omówimy najważniejsze elementy nowoczesnego JavaScript, w tym ES6 i nowsze."/><meta property="twitter:card" content="summary_large_image"/><meta property="twitter:url" content="https://jakubszpil.github.io/learning/nowoczesny-javascript/"/><meta property="twitter:title" content="Renesans w JS, czyli nowoczesny JavaScript - Jakub Szpil"/><meta property="twitter:description" content="JavaScript jest językiem programowania, który jest powszechnie stosowany do tworzenia dynamicznych i interaktywnych stron internetowych. W ciągu ostatnich lat JavaScript znacznie ewoluował, wprowadzając nowe funkcje i poprawiając istniejące mechanizmy. W tym kursie omówimy najważniejsze elementy nowoczesnego JavaScript, w tym ES6 i nowsze."/><link rel="modulepreload" href="/assets/manifest-1aebbe92.js"/><link rel="modulepreload" href="/assets/entry.client-D07Jc1yP.js"/><link rel="modulepreload" href="/assets/jsx-runtime-D_zvdyIk.js"/><link rel="modulepreload" href="/assets/chunk-OIYGIGL5-Rdhby1S0.js"/><link rel="modulepreload" href="/assets/index-DJQXGD61.js"/><link rel="modulepreload" href="/assets/root-Cvi6AeB_.js"/><link rel="modulepreload" href="/assets/layout-DYpV2se7.js"/><link rel="modulepreload" href="/assets/button-BMGgmMxT.js"/><link rel="modulepreload" href="/assets/link-with-prefetch-BIs6hVLd.js"/><link rel="modulepreload" href="/assets/icons-BBGQWBin.js"/><link rel="modulepreload" href="/assets/socials-DGthjeXP.js"/><link rel="modulepreload" href="/assets/date-NK96Yl5Q.js"/><link rel="modulepreload" href="/assets/not-found-CGoFJWhv.js"/><link rel="modulepreload" href="/assets/seo-Do91G143.js"/><link rel="modulepreload" href="/assets/course-details-DLJ6fZBl.js"/><link rel="modulepreload" href="/assets/categories-BBucIGjV.js"/><link rel="modulepreload" href="/assets/edit-resource-Bp0MeTOm.js"/><link rel="modulepreload" href="/assets/banner-DCe0eTPI.js"/><link rel="modulepreload" href="/assets/compress-C_V_4BTm.js"/><link rel="modulepreload" href="/assets/creation-date-x1jkwlYO.js"/><link rel="stylesheet" href="/assets/styles-CguqvXB_.css"/><script>globalThis.timestamp=1760891955675</script><script>let k="theme";let t="dark";let s=localStorage;let c=document.documentElement.classList;let v=s.getItem(k);if(v===null||v==="SYSTEM")matchMedia("(prefers-color-scheme:dark)").matches?c.add(t):c.remove(t);else if(v==="DARK")c.add(t);else if(v==="LIGHT")c.remove(t);else s.removeItem(k);</script><script type="module" src="/fetch.js"></script></head><body style="-webkit-tap-highlight-color:transparent"><header class="sticky w-full bg-background top-0 left-0 z-50 border-b"><div class="container pb-3! pt-4! px-3! flex justify-between items-center"><a data-slot="button" class="button button--variant-ghost button--size-sm font-bold" href="/" data-discover="true">jakubszpil</a><div class="flex flex-1 justify-end items-center sm:gap-1"><nav class="hidden items-center lg:flex"><a data-slot="button" class="button button--variant-ghost button--size-sm" href="/" data-discover="true">🏠 Strona główna</a><a data-slot="button" class="button button--variant-ghost button--size-sm" href="/blog" data-discover="true">📝 Blog</a><a data-slot="button" class="button button--variant-ghost button--size-sm" href="/learning" data-discover="true">🏫 Learning</a><a data-slot="button" class="button button--variant-ghost button--size-sm" href="/portfolio" data-discover="true">🛠️ Portfolio</a><a data-slot="button" class="button button--variant-ghost button--size-sm" href="/me" data-discover="true">🙋‍♂️ O mnie</a></nav><a data-slot="button" class="button button--variant-ghost button--size-icon inline-flex items-center justify-center" aria-label="Szukaj" title="Szukaj (CTRL+K)" href="/search" data-discover="true"><span class="sr-only">Szukaj</span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="size-6"><path d="M10 10m-7 0a7 7 0 1 0 14 0a7 7 0 1 0 -14 0"></path><path d="M21 21l-6 -6"></path></svg></a><div class="hidden xs:flex items-center sm:gap-1"><a href="https://www.linkedin.com/in/jakubszpil/" target="_blank" rel="noreferrer" data-slot="button" class="button button--variant-ghost button--size-icon inline-flex items-center gap-1 no-underline" title="LinkedIn" aria-label="LinkedIn"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="size-6"><path d="M8 11v5"></path><path d="M8 8v.01"></path><path d="M12 16v-5"></path><path d="M16 16v-3a2 2 0 1 0 -4 0"></path><path d="M3 7a4 4 0 0 1 4 -4h10a4 4 0 0 1 4 4v10a4 4 0 0 1 -4 4h-10a4 4 0 0 1 -4 -4z"></path></svg><span class="sr-only">LinkedIn</span></a><a href="https://github.com/jakubszpil/" target="_blank" rel="noreferrer" data-slot="button" class="button button--variant-ghost button--size-icon inline-flex items-center gap-1 no-underline" title="GitHub" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="size-6"><path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5"></path></svg><span class="sr-only">GitHub</span></a></div><button data-slot="dropdown-menu-trigger" class="button button--variant-ghost button--size-icon cursor-pointer" title="Zmień motyw" type="button" id="radix-_R_4ej5_" aria-haspopup="menu" aria-expanded="false" data-state="closed"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="size-6"><path d="M9.173 14.83a4 4 0 1 1 5.657 -5.657"></path><path d="M11.294 12.707l.174 .247a7.5 7.5 0 0 0 8.845 2.492a9 9 0 0 1 -14.671 2.914"></path><path d="M3 12h1"></path><path d="M12 3v1"></path><path d="M5.6 5.6l.7 .7"></path><path d="M3 21l18 -18"></path></svg></button><button data-slot="button" class="button button--variant-link button--size-icon inline-flex items-center justify-center relative z-50 lg:hidden" aria-label="Otwórz menu"><span class="sr-only">Otwórz menu</span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="size-6 text-black! dark:text-white!"><path d="M4 6l16 0"></path><path d="M4 12l16 0"></path><path d="M4 18l16 0"></path></svg></button></div></div></header><main><header class="prose container"><h1 class="mb-5">Renesans w JS, czyli nowoczesny JavaScript</h1><div class="text-xs sm:text-sm my-6"><div class="inline-block" title="Data opublikowania"><span class="mr-0.5">📆</span><span class="hidden">Data opublikowania:</span><time>30 czerwca 2024</time></div><span class="ml-2 mr-1">/</span><div class="inline-block sm:inline" title="Czas potrzebny na przeczytanie"><span class="mr-0.5">⌛</span><span class="hidden">Czas potrzebny na przeczytanie:</span>18 minut<!-- --> czytania</div></div><div class="flex items-center gap-3 flex-wrap"><a data-slot="button" class="button button--variant-secondary button--size-sm no-underline!" href="/learning/kategorie/javascript" data-discover="true">JavaScript</a></div></header><article class="prose container pt-0 prose-emerald"><p>Witaj w świecie <strong>nowoczesnego JavaScriptu</strong>! 🚀 Jeśli HTML to szkielet strony, a CSS to jej wygląd, to JavaScript jest sercem i mózgiem - sprawia, że strona ożywa, staje się interaktywna i dynamiczna. W ciągu ostatnich lat JavaScript przeszedł prawdziwy "renesans". Dzięki wprowadzeniu standardu <strong>ES6</strong> (ECMAScript 2015) i kolejnych aktualizacji, pisanie kodu w JS stało się znacznie przyjemniejsze, bezpieczniejsze i bardziej efektywne.</p>
<p>Ten przewodnik zabierze Cię w podróż po najważniejszych nowościach, które musisz znać, aby pisać <strong>nowoczesny JavaScript</strong>. Nie martw się, jeśli jesteś początkujący/a - wszystko wyjaśnimy krok po kroku, z przykładami i analogiami, byś mógł/mogła od razu zastosować nową wiedzę w praktyce. Czas unowocześnić swoje umiejętności! ✨</p>
<h2 id="spis-treści" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#spis-treści">>></a>Spis treści</h2>
<ol>
<li><a href="#zmienne-let-const-i-zakresy-blokowe--po%C5%BCegnanie-z-var">Zmienne: <code>let</code>, <code>const</code> i zakresy blokowe - pożegnanie z <code>var</code>?</a></li>
<li><a href="#funkcje-strza%C5%82kowe-arrow-functions-i-ich-zastosowania--kr%C3%B3cej-i-czytelniej">Funkcje strzałkowe (Arrow Functions) i ich zastosowania - krócej i czytelniej</a></li>
<li><a href="#szablony-string%C3%B3w-template-literals--%C5%82atwiejsza-praca-z-tekstem">Szablony stringów (Template Literals) - łatwiejsza praca z tekstem</a></li>
<li><a href="#destrukturyzacja-tablic-i-obiekt%C3%B3w--wyci%C4%85gnij-to-czego-potrzebujesz">Destrukturyzacja tablic i obiektów - wyciągnij to, czego potrzebujesz</a></li>
<li><a href="#spread-i-rest-operator---elastyczno%C5%9B%C4%87-w-manipulacji-danymi">Spread i Rest Operator (<code>...</code>) - elastyczność w manipulacji danymi</a></li>
<li><a href="#promise-api-i-obs%C5%82uga-asynchroniczno%C5%9Bci--opowiadaj-historie-o-przysz%C5%82o%C5%9Bci">Promise API i obsługa asynchroniczności - opowiadaj historie o przyszłości</a></li>
<li><a href="#asyncawait--nowoczesna-obs%C5%82uga-kodu-asynchronicznego--pisz-asynchronicznie-my%C5%9Bl-synchronicznie">Async/await - nowoczesna obsługa kodu asynchronicznego - pisz asynchronicznie, myśl synchronicznie</a></li>
<li><a href="#zadania-do-wykonania-sprawd%C5%BA-swoj%C4%85-wiedz%C4%99">Zadania do wykonania: Sprawdź swoją wiedzę!</a></li>
</ol>
<hr>
<h2 id="zmienne-let-const-i-zakresy-blokowe---pożegnanie-z-var" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#zmienne-let-const-i-zakresy-blokowe---pożegnanie-z-var">>></a>Zmienne: <code>let</code>, <code>const</code> i zakresy blokowe - pożegnanie z <code>var</code>?</h2>
<p>W starszych wersjach JavaScriptu zmienne deklarowaliśmy wyłącznie za pomocą słowa kluczowego <code>var</code>. Często prowadziło to do pomyłek i trudnych do wykrycia błędów. Nowoczesny JavaScript wprowadza dwa nowe sposoby deklarowania zmiennych: <strong><code>let</code></strong> i <strong><code>const</code></strong>, które znacznie poprawiają bezpieczeństwo i przewidywalność kodu.</p>
<h3 id="zakres-blokowy-block-scope" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#zakres-blokowy-block-scope">>>></a>Zakres blokowy (<code>block scope</code>)</h3>
<p>To kluczowa różnica! Zmienne zadeklarowane za pomocą <code>let</code> i <code>const</code> mają <strong>zakres blokowy</strong>. Co to znaczy? Oznaczają, że zmienna istnieje tylko w obrębie najbliższego <strong>bloku kodu</strong>, czyli wszystko, co znajduje się między klamrowymi nawiasami <code>{ ... }</code>.</p>
<p>Pomyśl o tym jak o specjalnej, prywatnej przestrzeni. Jeśli zmienna <code>x</code> jest zadeklarowana wewnątrz bloku <code>if</code>, będzie dostępna tylko w tym bloku. Próba użycia jej poza nim spowoduje błąd. To chroni Cię przed przypadkowym nadpisaniem zmiennych o tej samej nazwie w innej części kodu.</p>
<p><strong>Przykład:</strong></p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) {
  <span class="hljs-keyword">let</span> x = <span class="hljs-number">5</span>; <span class="hljs-comment">// x istnieje tylko wewnątrz tego bloku if</span>
  <span class="hljs-keyword">const</span> y = <span class="hljs-number">10</span>; <span class="hljs-comment">// y również istnieje tylko wewnątrz tego bloku</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x); <span class="hljs-comment">// Wyświetli: 5 (dostępne, bo jesteśmy w bloku)</span>
}
<span class="hljs-comment">// console.log(x); // WYWOŁA BŁĄD! ReferenceError: x is not defined</span>
<span class="hljs-comment">// console.log(y); // WYWOŁA BŁĄD! ReferenceError: y is not defined</span>
</code></pre>
<p>Dla porównania, <code>var</code> ma <strong>zakres funkcyjny</strong> (function scope), co oznacza, że zmienna zadeklarowana w funkcji jest dostępna w całej funkcji, ale poza funkcją jest dostępna globalnie, co jest źródłem wielu problemów. Dlatego w nowoczesnym kodzie <strong>zdecydowanie unikamy <code>var</code></strong>.</p>
<h3 id="różnice-między-let-const-i-var" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#różnice-między-let-const-i-var">>>></a>Różnice między <code>let</code>, <code>const</code> i <code>var</code></h3>
<ul>
<li>
<p><strong><code>let</code></strong>:</p>
<ul>
<li><strong>Deklaruje zmienną</strong>, której wartość może być <strong>zmieniana</strong> w dowolnym momencie.</li>
<li>Ma <strong>zakres blokowy</strong>.</li>
<li>Nie można jej ponownie zadeklarować w tym samym bloku (np. <code>let x = 5; let x = 10;</code> to błąd), ale można zmienić jej wartość (<code>x = 10;</code>).</li>
<li>Używaj <code>let</code>, gdy wiesz, że wartość zmiennej będzie się zmieniać (np. licznik w pętli).</li>
</ul>
</li>
<li>
<p><strong><code>const</code></strong>:</p>
<ul>
<li>Deklaruje <strong>stałą</strong>, której wartość musi być <strong>przypisana od razu</strong> i <strong>nie może być zmieniana</strong> później.</li>
<li>Ma <strong>zakres blokowy</strong>.</li>
<li>Jeśli przypiszesz do <code>const</code> obiekt lub tablicę, nie możesz przypisać do niej <em>nowego</em> obiektu/tablicy, ale możesz <strong>modyfikować zawartość</strong> tego obiektu/tablicy (np. dodawać lub usuwać elementy). <code>const</code> gwarantuje, że referencja (wskaźnik) do obiektu pozostaje taka sama, ale nie "zamraża" samego obiektu.</li>
<li>Używaj <code>const</code>, gdy wartość zmiennej nie powinna się zmieniać. To jest domyślny wybór w nowoczesnym JS, chyba że potrzebujesz <code>let</code>.</li>
</ul>
</li>
<li>
<p><strong><code>var</code></strong>:</p>
<ul>
<li><strong>Ma zakres funkcyjny</strong> (lub globalny, jeśli jest poza funkcją).</li>
<li>Jest podatny na <strong>hoisting</strong> (podnoszenie deklaracji), co oznacza, że deklaracja zmiennej jest "przenoszona" na początek zakresu, co może prowadzić do nieintuicyjnych zachowań.</li>
<li>Można go <strong>wielokrotnie deklarować</strong> w tym samym zakresie, co łatwo prowadzi do przypadkowych nadpisań.</li>
<li><strong>Unikaj używania <code>var</code> w nowym kodzie!</strong></li>
</ul>
</li>
</ul>
<p><strong>Przykład <code>const</code> z obiektem/tablicą:</strong></p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> tablica = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
tablica.<span class="hljs-title function_">push</span>(<span class="hljs-number">4</span>); <span class="hljs-comment">// DOZWOLONE! Zmieniamy zawartość tablicy, nie przypisujemy nowej tablicy.</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(tablica); <span class="hljs-comment">// Wyświetli: [1, 2, 3, 4]</span>

<span class="hljs-comment">// tablica = [5, 6]; // WYWOŁA BŁĄD! TypeError: Assignment to constant variable.</span>
<span class="hljs-comment">// Próbujesz przypisać zupełnie nową tablicę do stałej referencji.</span>

<span class="hljs-keyword">const</span> osoba = { <span class="hljs-attr">imie</span>: <span class="hljs-string">"Anna"</span>, <span class="hljs-attr">wiek</span>: <span class="hljs-number">28</span> };
osoba.<span class="hljs-property">wiek</span> = <span class="hljs-number">29</span>; <span class="hljs-comment">// DOZWOLONE! Zmieniamy właściwość obiektu, nie przypisujemy nowego obiektu.</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(osoba); <span class="hljs-comment">// Wyświetli: { imie: "Anna", wiek: 29 }</span>

<span class="hljs-comment">// osoba = { nazwisko: "Nowak" }; // WYWOŁA BŁĄD!</span>
</code></pre>
<hr>
<h2 id="funkcje-strzałkowe-arrow-functions-i-ich-zastosowania---krócej-i-czytelniej" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#funkcje-strzałkowe-arrow-functions-i-ich-zastosowania---krócej-i-czytelniej">>></a>Funkcje strzałkowe (Arrow Functions) i ich zastosowania - krócej i czytelniej</h2>
<p>Funkcje strzałkowe to zwięzła alternatywa dla tradycyjnych funkcji JavaScript, która została wprowadzona w ES6. Są nie tylko krótsze, ale także rozwiązują pewien problem z kontekstem <code>this</code>, który często mylił początkujących programistów.</p>
<h3 id="składnia-funkcji-strzałkowej" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#składnia-funkcji-strzałkowej">>>></a>Składnia funkcji strzałkowej</h3>
<p>Największą zaletą funkcji strzałkowych jest ich zwięzła składnia, zwłaszcza dla prostych funkcji.</p>
<ul>
<li>
<p><strong>Szybszy zapis (szczególnie dla funkcji jedno-liniowych):</strong>
Jeśli funkcja składa się tylko z jednej instrukcji, która zwraca wartość, możesz pominąć nawiasy klamrowe <code>{}</code> i słowo kluczowe <code>return</code>.</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// Tradycyjna funkcja</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">dodajStara</span>(<span class="hljs-params">a, b</span>) {
  <span class="hljs-keyword">return</span> a + b;
}

<span class="hljs-comment">// Funkcja strzałkowa (krótszy zapis)</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">dodaj</span> = (<span class="hljs-params">a, b</span>) => a + b;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">dodaj</span>(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">// Wyświetli: 8</span>

<span class="hljs-comment">// Funkcja z jednym argumentem (można pominąć nawiasy wokół argumentu)</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">powitanie</span> = (<span class="hljs-params">imie</span>) => <span class="hljs-string">`Cześć, <span class="hljs-subst">${imie}</span>!`</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">powitanie</span>(<span class="hljs-string">"Ola"</span>)); <span class="hljs-comment">// Wyświetli: Cześć, Ola!</span>

<span class="hljs-comment">// Funkcja bez argumentów (konieczne puste nawiasy)</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">powiedzHello</span> = (<span class="hljs-params"></span>) => <span class="hljs-string">"Hello!"</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">powiedzHello</span>()); <span class="hljs-comment">// Wyświetli: Hello!</span>
</code></pre>
</li>
<li>
<p><strong>Brak własnego obiektu <code>arguments</code>:</strong> Funkcje strzałkowe nie mają własnego obiektu <code>arguments</code> (który zawiera wszystkie argumenty przekazane do funkcji). Jeśli go potrzebujesz, użyj <strong>rest operatora</strong> (<code>...</code>), o którym powiemy później.</p>
</li>
<li>
<p><strong>Brak możliwości użycia jako konstruktor:</strong> Nie możesz użyć funkcji strzałkowej do tworzenia nowych obiektów za pomocą słowa kluczowego <code>new</code>.</p>
</li>
</ul>
<h3 id="funkcje-strzałkowe-a-kontekst-this" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#funkcje-strzałkowe-a-kontekst-this">>>></a>Funkcje strzałkowe a kontekst <code>this</code></h3>
<p>To jest jeden z najważniejszych powodów, dla których wprowadzono funkcje strzałkowe. W tradycyjnych funkcjach, wartość <code>this</code> zależy od tego, jak funkcja jest wywoływana. To prowadziło do częstych błędów, zwłaszcza w callbackach (funkcjach wywoływanych przez inne funkcje, np. w <code>setTimeout</code> czy w obsłudze zdarzeń).</p>
<p>Funkcje strzałkowe rozwiązują ten problem: <strong>nie mają własnego <code>this</code></strong>. Zamiast tego, <strong>dziedziczą <code>this</code> z otoczenia, w którym zostały zadeklarowane</strong> (tzw. leksykalny <code>this</code>).</p>
<p><strong>Przykład problemu ze <code>this</code> w tradycyjnych funkcjach:</strong></p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// Tradycyjna funkcja, która "gubi" kontekst this</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">TimerProblem</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">sekundy</span> = <span class="hljs-number">0</span>;
  <span class="hljs-built_in">setInterval</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-comment">// Tutaj 'this' nie odnosi się do obiektu TimerProblem,</span>
    <span class="hljs-comment">// ale do obiektu globalnego (np. window w przeglądarce) lub jest undefined w trybie 'strict mode'</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">sekundy</span>++; <span class="hljs-comment">// To nie zadziała tak, jak byśmy chcieli!</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">sekundy</span>);
  }, <span class="hljs-number">1000</span>);
}
<span class="hljs-comment">// new TimerProblem(); // W konsoli prawdopodobnie zobaczysz NaN lub błąd</span>
</code></pre>
<p><strong>Rozwiązanie z funkcją strzałkową:</strong></p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">TimerPoprawny</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">sekundy</span> = <span class="hljs-number">0</span>;
  <span class="hljs-comment">// Funkcja strzałkowa dziedziczy 'this' z TimerPoprawny (czyli z obiektu TimerPoprawny)</span>
  <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">sekundy</span>++;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Sekundy: <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.sekundy}</span>`</span>);
  }, <span class="hljs-number">1000</span>);
}
<span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerPoprawny</span>(); <span class="hljs-comment">// Będzie poprawnie liczyć sekundy: Sekundy: 1, Sekundy: 2, itd.</span>
</code></pre>
<p>Dzięki temu funkcje strzałkowe są idealne do użycia w callbackach, metodach obiektów (choć nie jako metody obiektów najwyższego poziomu, bo wtedy <code>this</code> wskazałoby na <code>window</code>), czy w sytuacjach, gdzie chcesz, aby <code>this</code> zachowało kontekst nadrzędny.</p>
<hr>
<h2 id="szablony-stringów-template-literals---łatwiejsza-praca-z-tekstem" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#szablony-stringów-template-literals---łatwiejsza-praca-z-tekstem">>></a>Szablony stringów (Template Literals) - łatwiejsza praca z tekstem</h2>
<p>Szablony stringów, wprowadzone w ES6, to potężne narzędzie do tworzenia ciągów znaków (stringów). Zastępują tradycyjne łączenie stringów za pomocą operatora <code>+</code> i oferują znacznie większą elastyczność i czytelność. Używamy ich, otaczając tekst <strong>backtickami</strong> (apostrofami wstecznymi) <code> </code> zamiast pojedynczych lub podwójnych cudzysłowów.</p>
<h3 id="interpolacja-i-wielolinijkowość" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#interpolacja-i-wielolinijkowość">>>></a>Interpolacja i wielolinijkowość</h3>
<ul>
<li>
<p><strong>Interpolacja zmiennych i wyrażeń:</strong>
Możesz łatwo osadzać zmienne lub dowolne wyrażenia JavaScript bezpośrednio w stringu, używając składni <code>${...}</code>. To znacznie ułatwia budowanie dynamicznych komunikatów.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> imie = <span class="hljs-string">"Alicja"</span>;
<span class="hljs-keyword">const</span> wiek = <span class="hljs-number">30</span>;

<span class="hljs-comment">// Stary sposób: męczące łączenie stringów</span>
<span class="hljs-keyword">const</span> infoStare = <span class="hljs-string">"Mam na imię "</span> + imie + <span class="hljs-string">" i mam "</span> + wiek + <span class="hljs-string">" lat."</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(infoStare); <span class="hljs-comment">// Wyświetli: Mam na imię Alicja i mam 30 lat.</span>

<span class="hljs-comment">// Nowy sposób z szablonami stringów: czytelniej i prościej!</span>
<span class="hljs-keyword">const</span> infoNowe = <span class="hljs-string">`Mam na imię <span class="hljs-subst">${imie}</span> i mam <span class="hljs-subst">${wiek}</span> lat.`</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(infoNowe); <span class="hljs-comment">// Wyświetli: Mam na imię Alicja i mam 30 lat.</span>

<span class="hljs-comment">// Możesz umieszczać dowolne wyrażenia JavaScript:</span>
<span class="hljs-keyword">const</span> cena = <span class="hljs-number">10.5</span>;
<span class="hljs-keyword">const</span> ilosc = <span class="hljs-number">2</span>;
<span class="hljs-keyword">const</span> rachunek = <span class="hljs-string">`Koszt zakupu: <span class="hljs-subst">${cena * ilosc}</span> zł.`</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(rachunek); <span class="hljs-comment">// Wyświetli: Koszt zakupu: 21 zł.</span>
</code></pre>
</li>
<li>
<p><strong>Łatwe tworzenie tekstów wielolinijkowych:</strong>
Koniec z dodawaniem <code>n</code> do każdej linii! W szablonach stringów możesz po prostu nacisnąć Enter, a tekst zachowa formatowanie z nowymi liniami. Jest to szczególnie przydatne przy generowaniu fragmentów HTML bezpośrednio w JavaScript.</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// Stary sposób: brzydkie i niewygodne</span>
<span class="hljs-keyword">const</span> htmlStare =
  <span class="hljs-string">"&#x3C;div>\n  &#x3C;h1>Witaj!&#x3C;/h1>\n  &#x3C;p>To jest wielolinijkowy tekst.&#x3C;/p>\n&#x3C;/div>"</span>;

<span class="hljs-comment">// Nowy sposób: super czytelne!</span>
<span class="hljs-keyword">const</span> htmlNowe = <span class="hljs-string">`
  &#x3C;div>
    &#x3C;h1>Witaj!&#x3C;/h1>
    &#x3C;p>To jest wielolinijkowy tekst. I kolejna linia w tym samym akapicie.&#x3C;/p>
  &#x3C;/div>
`</span>;

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(htmlNowe);
</code></pre>
</li>
</ul>
<h3 id="dodatkowe-możliwości" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#dodatkowe-możliwości">>>></a>Dodatkowe możliwości</h3>
<p>Szablony stringów wspierają także tzw. <strong>tagowane szablony</strong> (<code>tagged templates</code>), które pozwalają na zaawansowaną manipulację tekstem przed jego finalnym utworzeniem. Możesz zdefiniować funkcję ("tag"), która będzie przetwarzać części stringu i wartości zmiennych. Jest to bardziej zaawansowana funkcja, używana np. do tłumaczeń, walidacji, bezpiecznego generowania HTML (zapobieganie XSS) czy formatowania danych.</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// Przykład funkcji "tagującej"</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">upper</span>(<span class="hljs-params">strings, ...values</span>) {
  <span class="hljs-comment">// 'strings' to tablica tekstów, 'values' to tablica zmiennych</span>
  <span class="hljs-keyword">let</span> wynik = strings[<span class="hljs-number">0</span>];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &#x3C; values.<span class="hljs-property">length</span>; i++) {
    wynik += values[i].<span class="hljs-title function_">toUpperCase</span>() + strings[i + <span class="hljs-number">1</span>]; <span class="hljs-comment">// Zamienia zmienne na duże litery</span>
  }
  <span class="hljs-keyword">return</span> wynik;
}

<span class="hljs-keyword">const</span> imie = <span class="hljs-string">"Kasia"</span>;
<span class="hljs-keyword">const</span> wiek = <span class="hljs-number">20</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(upper<span class="hljs-string">`Cześć, <span class="hljs-subst">${imie}</span>! Masz <span class="hljs-subst">${wiek}</span> lat?`</span>); <span class="hljs-comment">// Wyświetli: Cześć, KASIA! Masz 20 lat?</span>
</code></pre>
<p>W tym przykładzie funkcja <code>upper</code> została "przypięta" do szablonu stringu i zmodyfikowała zmienną <code>imie</code> na wielkie litery.</p>
<hr>
<h2 id="destrukturyzacja-tablic-i-obiektów---wyciągnij-to-czego-potrzebujesz" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#destrukturyzacja-tablic-i-obiektów---wyciągnij-to-czego-potrzebujesz">>></a>Destrukturyzacja tablic i obiektów - wyciągnij to, czego potrzebujesz</h2>
<p>Destrukturyzacja to potężna i bardzo często używana funkcja w nowoczesnym JavaScript. Pozwala na "rozpakowanie" wartości z tablic lub właściwości z obiektów do oddzielnych zmiennych w bardzo zwięzły i czytelny sposób. Upraszcza kod i czyni go bardziej deklaratywnym.</p>
<h3 id="destrukturyzacja-tablic" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#destrukturyzacja-tablic">>>></a>Destrukturyzacja tablic</h3>
<p>Pozwala na szybkie przypisanie wartości z tablicy do zmiennych, bazując na ich pozycji.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> kolory = [<span class="hljs-string">"czerwony"</span>, <span class="hljs-string">"zielony"</span>, <span class="hljs-string">"niebieski"</span>];

<span class="hljs-comment">// Stary sposób:</span>
<span class="hljs-comment">// const kolor1 = kolory[0];</span>
<span class="hljs-comment">// const kolor2 = kolory[1];</span>

<span class="hljs-comment">// Nowy sposób z destrukturyzacją tablic:</span>
<span class="hljs-keyword">const</span> [pierwszyKolor, drugiKolor, trzeciKolor] = kolory;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pierwszyKolor); <span class="hljs-comment">// Wyświetli: czerwony</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(drugiKolor); <span class="hljs-comment">// Wyświetli: zielony</span>

<span class="hljs-comment">// Można pomijać niektóre elementy (używając przecinków):</span>
<span class="hljs-keyword">const</span> [a, , b] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]; <span class="hljs-comment">// Pomijamy drugi element (2)</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a, b); <span class="hljs-comment">// Wyświetli: 1 3</span>

<span class="hljs-comment">// Można przypisać wartości domyślne, jeśli element nie istnieje:</span>
<span class="hljs-keyword">const</span> [x, y, z = <span class="hljs-string">"domyślny"</span>] = [<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x, y, z); <span class="hljs-comment">// Wyświetli: A B domyślny</span>

<span class="hljs-comment">// Można zbierać pozostałe elementy do nowej tablicy (rest operator - patrz dalej):</span>
<span class="hljs-keyword">const</span> [pierwszy, ...resztaKolorow] = kolory;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pierwszy); <span class="hljs-comment">// Wyświetli: czerwony</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(resztaKolorow); <span class="hljs-comment">// Wyświetli: ["zielony", "niebieski"]</span>
</code></pre>
<h3 id="destrukturyzacja-obiektów" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#destrukturyzacja-obiektów">>>></a>Destrukturyzacja obiektów</h3>
<p>Pozwala na przypisanie wartości z obiektu do zmiennych na podstawie nazw ich <strong>kluczy (właściwości)</strong>. Kolejność nie ma znaczenia, liczy się nazwa klucza.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> samochod = { <span class="hljs-attr">marka</span>: <span class="hljs-string">"Ford"</span>, <span class="hljs-attr">model</span>: <span class="hljs-string">"Focus"</span>, <span class="hljs-attr">rok</span>: <span class="hljs-number">2018</span> };

<span class="hljs-comment">// Stary sposób:</span>
<span class="hljs-comment">// const markaSamochodu = samochod.marka;</span>
<span class="hljs-comment">// const modelSamochodu = samochod.model;</span>

<span class="hljs-comment">// Nowy sposób z destrukturyzacją obiektów:</span>
<span class="hljs-keyword">const</span> { marka, model } = samochod;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(marka); <span class="hljs-comment">// Wyświetli: Ford</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(model); <span class="hljs-comment">// Wyświetli: Focus</span>

<span class="hljs-comment">// Można przypisać wartości domyślne, jeśli właściwość nie istnieje:</span>
<span class="hljs-keyword">const</span> { <span class="hljs-attr">marka</span>: m, kolor = <span class="hljs-string">"czarny"</span> } = samochod; <span class="hljs-comment">// 'kolor' nie istnieje w obiekcie 'samochod'</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(m, kolor); <span class="hljs-comment">// Wyświetli: Ford czarny</span>

<span class="hljs-comment">// Można zmienić nazwę zmiennej, do której przypisujemy wartość:</span>
<span class="hljs-keyword">const</span> { <span class="hljs-attr">marka</span>: nazwaMarki, <span class="hljs-attr">model</span>: typModelu } = samochod;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(nazwaMarki, typModelu); <span class="hljs-comment">// Wyświetli: Ford Focus</span>

<span class="hljs-comment">// Można też zbierać pozostałe właściwości do nowego obiektu (rest operator - patrz dalej):</span>
<span class="hljs-keyword">const</span> { rok, ...resztaSamochodu } = samochod;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(rok); <span class="hljs-comment">// Wyświetli: 2018</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(resztaSamochodu); <span class="hljs-comment">// Wyświetli: { marka: "Ford", model: "Focus" }</span>
</code></pre>
<p>Destrukturyzacja jest szczególnie przydatna w funkcjach, gdy chcesz łatwo wyciągnąć konkretne dane z obiektów konfiguracyjnych lub z wyników API.</p>
<hr>
<h2 id="spread-i-rest-operator----elastyczność-w-manipulacji-danymi" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#spread-i-rest-operator----elastyczność-w-manipulacji-danymi">>></a>Spread i Rest Operator (<code>...</code>) - elastyczność w manipulacji danymi</h2>
<p>Operator <code>...</code> (trzy kropki) jest jednym z najbardziej uniwersalnych i potężnych narzędzi w nowoczesnym JavaScript. Nazywany jest <strong>operatorem spread</strong> lub <strong>operatorem rest</strong>, w zależności od kontekstu, w jakim jest używany.</p>
<h3 id="spread-operator-operator-rozproszenia" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#spread-operator-operator-rozproszenia">>>></a>Spread Operator (operator rozproszenia)</h3>
<p>Gdy używasz <code>...</code> do <strong>rozbicia</strong> elementów tablicy lub właściwości obiektu na pojedyncze elementy, mówimy o <strong>operatorze spread</strong>. Jest to jak "rozłożenie" zawartości kolekcji. 🌐</p>
<p><strong>Zastosowania Spread Operatora:</strong></p>
<ul>
<li>
<p><strong>Kopiowanie i łączenie tablic:</strong> Tworzenie płytkich kopii tablic lub łączenie ich bez modyfikowania oryginalnych.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> cyfry = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-keyword">const</span> noweCyfry = [...cyfry, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]; <span class="hljs-comment">// Rozwija [1, 2, 3] do 1, 2, 3, a potem dodaje 4, 5</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(noweCyfry); <span class="hljs-comment">// Wyświetli: [1, 2, 3, 4, 5]</span>

<span class="hljs-keyword">const</span> tablica1 = [<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>];
<span class="hljs-keyword">const</span> tablica2 = [<span class="hljs-string">"c"</span>, <span class="hljs-string">"d"</span>];
<span class="hljs-keyword">const</span> polaczoneTablice = [...tablica1, ...tablica2];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(polaczoneTablice); <span class="hljs-comment">// Wyświetli: ["a", "b", "c", "d"]</span>
</code></pre>
</li>
<li>
<p><strong>Kopiowanie i łączenie obiektów:</strong> Podobnie jak z tablicami, możesz tworzyć kopie obiektów i łączyć ich właściwości.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> osoba = { <span class="hljs-attr">imie</span>: <span class="hljs-string">"Anna"</span>, <span class="hljs-attr">wiek</span>: <span class="hljs-number">28</span> };
<span class="hljs-keyword">const</span> osobaZZawodem = { ...osoba, <span class="hljs-attr">zawod</span>: <span class="hljs-string">"Programista"</span> };
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(osobaZZawodem); <span class="hljs-comment">// Wyświetli: { imie: "Anna", wiek: 28, zawod: "Programista" }</span>

<span class="hljs-keyword">const</span> daneKontaktowe = { <span class="hljs-attr">email</span>: <span class="hljs-string">"a@example.com"</span>, <span class="hljs-attr">telefon</span>: <span class="hljs-string">"123-456-789"</span> };
<span class="hljs-keyword">const</span> pelneDane = { ...osoba, ...daneKontaktowe };
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pelneDane); <span class="hljs-comment">// Wyświetli: { imie: "Anna", wiek: 28, email: "a@example.com", telefon: "123-456-789" }</span>
</code></pre>
<p>Jeśli klucze się powtarzają, ostatnia wartość nadpisuje poprzednią.</p>
</li>
<li>
<p><strong>Przekazywanie argumentów funkcji:</strong> Możesz rozwijać tablicę jako argumenty funkcji.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sumuj</span>(<span class="hljs-params">a, b, c</span>) {
  <span class="hljs-keyword">return</span> a + b + c;
}
<span class="hljs-keyword">const</span> liczby = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sumuj</span>(...liczby)); <span class="hljs-comment">// Rozwija [10, 20, 30] do sumuj(10, 20, 30), wyświetli: 60</span>
</code></pre>
</li>
</ul>
<h3 id="rest-operator-operator-reszty" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#rest-operator-operator-reszty">>>></a>Rest Operator (operator reszty)</h3>
<p>Gdy używasz <code>...</code> do <strong>zbierania</strong> wielu elementów w jedną tablicę (lub właściwości w obiekt), mówimy o <strong>operatorze rest</strong>. Jest to jak "zbieranie" luźnych elementów w jedną kolekcję. 🧺</p>
<p><strong>Zastosowania Rest Operatora:</strong></p>
<ul>
<li>
<p><strong>Zbieranie argumentów funkcji:</strong> Pozwala funkcji przyjmować nieokreśloną liczbę argumentów i traktować je jako tablicę.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">suma</span>(<span class="hljs-params">...liczby</span>) {
  <span class="hljs-comment">// 'liczby' zbiera wszystkie przekazane argumenty w tablicę</span>
  <span class="hljs-keyword">return</span> liczby.<span class="hljs-title function_">reduce</span>(
    <span class="hljs-function">(<span class="hljs-params">akumulator, aktualnaLiczba</span>) =></span> akumulator + aktualnaLiczba,
    <span class="hljs-number">0</span>
  );
}
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">suma</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">// Wyświetli: 6</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">suma</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>)); <span class="hljs-comment">// Wyświetli: 100</span>
</code></pre>
</li>
<li>
<p><strong>W destrukturyzacji (jak widzieliśmy wcześniej):</strong> Zbieranie pozostałych elementów do nowej tablicy lub obiektu.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> [pierwszy, drugi, ...resztaTablicy] = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pierwszy); <span class="hljs-comment">// Wyświetli: 10</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(drugi); <span class="hljs-comment">// Wyświetli: 20</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(resztaTablicy); <span class="hljs-comment">// Wyświetli: [30, 40, 50]</span>

<span class="hljs-keyword">const</span> { imie, ...resztaOsoby } = {
  <span class="hljs-attr">imie</span>: <span class="hljs-string">"Ola"</span>,
  <span class="hljs-attr">wiek</span>: <span class="hljs-number">25</span>,
  <span class="hljs-attr">miasto</span>: <span class="hljs-string">"Warszawa"</span>,
};
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(imie); <span class="hljs-comment">// Wyświetli: Ola</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(resztaOsoby); <span class="hljs-comment">// Wyświetli: { wiek: 25, miasto: "Warszawa" }</span>
</code></pre>
</li>
</ul>
<p>Zarówno spread, jak i rest operator są niezwykle przydatne i sprawiają, że kod jest znacznie bardziej zwięzły i czytelny, szczególnie podczas pracy z tablicami i obiektami.</p>
<hr>
<h2 id="promise-api-i-obsługa-asynchroniczności---opowiadaj-historie-o-przyszłości" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#promise-api-i-obsługa-asynchroniczności---opowiadaj-historie-o-przyszłości">>></a>Promise API i obsługa asynchroniczności - opowiadaj historie o przyszłości</h2>
<p>JavaScript jest językiem <strong>jednowątkowym</strong>, co oznacza, że może wykonywać tylko jedną operację w danym momencie. Jednak wiele operacji, takich jak pobieranie danych z internetu, odczyt plików, czy operacje na bazie danych, trwa pewien czas. Gdyby JavaScript musiał czekać na ich zakończenie, strona internetowa by się "zawiesiła" (nie reagowałaby na kliknięcia, przewijanie itp.).</p>
<p>Tutaj wkracza <strong>asynchroniczność</strong>. Pozwala ona na rozpoczęcie operacji, a następnie przejście do kolejnych zadań, nie czekając na zakończenie tej pierwszej. Kiedy asynchroniczna operacja się zakończy, JavaScript wróci do niej i wykona dalsze kroki.</p>
<p>Starszym sposobem obsługi asynchroniczności były <strong>callbacki</strong> (funkcje zwrotne), które jednak często prowadziły do tzw. "callback hell" (piekła callbacków) - zagnieżdżonego, trudnego do czytania i utrzymania kodu.</p>
<h3 id="czym-jest-promise" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#czym-jest-promise">>>></a>Czym jest Promise?</h3>
<p><strong>Promise (Obietnica)</strong> to obiekt w JavaScript, który reprezentuje ostateczne zakończenie (lub niepowodzenie) operacji asynchronicznej. Możesz myśleć o Promise jako o "przyszłej wartości". Składasz obietnicę, że w przyszłości otrzymasz wynik - albo sukces, albo błąd. 📦</p>
<p>Promise może znajdować się w jednym z trzech stanów:</p>
<ol>
<li><strong><code>pending</code> (oczekujący)</strong>: Początkowy stan; ani spełniony, ani odrzucony. Operacja asynchroniczna nadal trwa.</li>
<li><strong><code>fulfilled</code> (spełniony)</strong>: Operacja asynchroniczna zakończyła się sukcesem i zwróciła wartość.</li>
<li><strong><code>rejected</code> (odrzucony)</strong>: Operacja asynchroniczna zakończyła się błędem.</li>
</ol>
<p>Możesz "podpiąć" funkcje, które zostaną wywołane, gdy Promise zmieni swój stan:</p>
<ul>
<li><strong><code>.then()</code></strong>: Wywoływany, gdy Promise zostanie <code>fulfilled</code> (operacja zakończy się sukcesem). Otrzymuje wartość zwróconą przez Promise.</li>
<li><strong><code>.catch()</code></strong>: Wywoływany, gdy Promise zostanie <code>rejected</code> (wystąpi błąd). Otrzymuje obiekt błędu.</li>
<li><strong><code>.finally()</code></strong>: Wywoływany zawsze, niezależnie od tego, czy Promise zakończył się sukcesem, czy błędem. Idealny do czyszczenia zasobów.</li>
</ul>
<p><strong>Przykład tworzenia i używania Promise:</strong></p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> obietnica = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> {
  <span class="hljs-comment">// Symulujemy operację asynchroniczną (np. pobieranie danych)</span>
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-keyword">const</span> sukces = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() > <span class="hljs-number">0.5</span>; <span class="hljs-comment">// Losowo decydujemy o sukcesie lub błędzie</span>

    <span class="hljs-keyword">if</span> (sukces) {
      <span class="hljs-title function_">resolve</span>(<span class="hljs-string">"Dane pobrane pomyślnie!"</span>); <span class="hljs-comment">// Jeśli sukces, wywołujemy resolve z wynikiem</span>
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"Nie udało się pobrać danych."</span>)); <span class="hljs-comment">// Jeśli błąd, wywołujemy reject z błędem</span>
    }
  }, <span class="hljs-number">2000</span>); <span class="hljs-comment">// Operacja trwa 2 sekundy</span>
});

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Rozpoczęto operację..."</span>);

obietnica
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">wiadomosc</span>) =></span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"SUKCES:"</span>, wiadomosc); <span class="hljs-comment">// Wykona się, jeśli obietnica się spełni</span>
  })
  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">blad</span>) =></span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"BŁĄD:"</span>, blad.<span class="hljs-property">message</span>); <span class="hljs-comment">// Wykona się, jeśli obietnica zostanie odrzucona</span>
  })
  .<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Operacja zakończona (niezależnie od wyniku)."</span>); <span class="hljs-comment">// Wykona się zawsze</span>
  });

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Kod po obietnicy nadal się wykonuje..."</span>); <span class="hljs-comment">// Pokazuje asynchroniczność</span>
</code></pre>
<h3 id="łańcuchy-promise-promise-chaining" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#łańcuchy-promise-promise-chaining">>>></a>Łańcuchy Promise (<code>Promise Chaining</code>)</h3>
<p>Jedną z największych zalet Promise jest możliwość łączenia wielu operacji asynchronicznych w jeden czytelny "łańcuch". Każdy <code>.then()</code> zwraca nowy Promise, co pozwala na kolejne <code>.then()</code> wywołane po sobie. Jest to idealne, gdy jedna operacja asynchroniczna zależy od wyniku poprzedniej.</p>
<p><strong>Przykład łańcucha Promise (pobieranie danych z API):</strong></p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// fetch() to wbudowana funkcja JS, która zwraca Promise</span>
<span class="hljs-title function_">fetch</span>(<span class="hljs-string">"https://jsonplaceholder.typicode.com/users/1"</span>) <span class="hljs-comment">// Pobierz dane użytkownika o ID 1</span>
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">response</span>) =></span> {
    <span class="hljs-comment">// Pierwsze .then: sprawdź, czy odpowiedź jest OK i sparsuj ją jako JSON</span>
    <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`Błąd HTTP! Status: <span class="hljs-subst">${response.status}</span>`</span>);
    }
    <span class="hljs-keyword">return</span> response.<span class="hljs-title function_">json</span>(); <span class="hljs-comment">// Zwróć kolejny Promise z danymi JSON</span>
  })
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">user</span>) =></span> {
    <span class="hljs-comment">// Drugie .then: otrzymaj sparsowane dane użytkownika</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Pobrany użytkownik:"</span>, user.<span class="hljs-property">name</span>, user.<span class="hljs-property">email</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">fetch</span>(
      <span class="hljs-string">`https://jsonplaceholder.typicode.com/posts?userId=<span class="hljs-subst">${user.id}</span>`</span>
    ); <span class="hljs-comment">// Pobierz posty tego użytkownika</span>
  })
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">response</span>) =></span> {
    <span class="hljs-comment">// Trzecie .then: sprawdź odpowiedź i sparsuj posty</span>
    <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`Błąd HTTP! Status: <span class="hljs-subst">${response.status}</span>`</span>);
    }
    <span class="hljs-keyword">return</span> response.<span class="hljs-title function_">json</span>();
  })
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">posts</span>) =></span> {
    <span class="hljs-comment">// Czwarte .then: otrzymaj posty</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Liczba postów użytkownika:"</span>, posts.<span class="hljs-property">length</span>);
  })
  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =></span> {
    <span class="hljs-comment">// .catch: Obsłuż każdy błąd, który wystąpił na dowolnym etapie łańcucha</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"Wystąpił błąd w łańcuchu Promise:"</span>, error);
  })
  .<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Pobieranie danych zakończone."</span>);
  });
</code></pre>
<p>Promise to podstawa nowoczesnego JS w obsłudze asynchroniczności, a kolejny rozdział pokaże Ci, jak jeszcze bardziej uprościć ich użycie.</p>
<hr>
<h2 id="asyncawait---nowoczesna-obsługa-kodu-asynchronicznego---pisz-asynchronicznie-myśl-synchronicznie" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#asyncawait---nowoczesna-obsługa-kodu-asynchronicznego---pisz-asynchronicznie-myśl-synchronicznie">>></a>Async/await - nowoczesna obsługa kodu asynchronicznego - pisz asynchronicznie, myśl synchronicznie</h2>
<p>Mimo że Promise są ogromnym krokiem naprzód w porównaniu do callbacków, kod z długimi łańcuchami <code>.then().then().catch()</code> może wciąż być trudny do czytania. Standard ES2017 wprowadził słowa kluczowe <strong><code>async</code></strong> i <strong><code>await</code></strong>, które pozwalają pisać kod asynchroniczny w sposób, który wygląda i zachowuje się niemal identycznie jak kod synchroniczny, jednocześnie zachowując asynchroniczną naturę. To game changer! 🎮</p>
<h3 id="uproszczenie-pracy-z-promise" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#uproszczenie-pracy-z-promise">>>></a>Uproszczenie pracy z Promise</h3>
<ul>
<li><strong><code>async</code></strong>: Musisz oznaczyć funkcję słowem kluczowym <code>async</code>, aby móc używać w niej <code>await</code>. Funkcja <code>async</code> <strong>zawsze zwraca Promise</strong>, nawet jeśli zwrócisz w niej zwykłą wartość - JavaScript automatycznie opakuje ją w Promise.</li>
<li><strong><code>await</code></strong>: Słowo kluczowe <code>await</code> może być użyte <strong>tylko wewnątrz funkcji <code>async</code></strong>. Powoduje ono, że wykonanie funkcji <code>async</code> zostaje <strong>wstrzymane</strong>, dopóki Promise, na który czeka <code>await</code>, nie zostanie <strong>spełniony (fulfilled)</strong>. Kiedy Promise się spełni, <code>await</code> "rozpakowuje" jego wartość i przypisuje ją do zmiennej. Jeśli Promise zostanie odrzucony (rejected), <code>await</code> "wyrzuci" błąd, który możesz obsłużyć za pomocą <code>try...catch</code>.</li>
</ul>
<p><strong>Przykład użycia <code>async/await</code> (porównaj z przykładem z Promise Chaining):</strong></p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">pobierzDaneUzytkownikaIPosty</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Rozpoczynam pobieranie danych..."</span>);

    <span class="hljs-comment">// Krok 1: Pobierz dane użytkownika</span>
    <span class="hljs-keyword">const</span> userResponse = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(
      <span class="hljs-string">"https://jsonplaceholder.typicode.com/users/1"</span>
    );
    <span class="hljs-keyword">if</span> (!userResponse.<span class="hljs-property">ok</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(
        <span class="hljs-string">`Błąd HTTP przy pobieraniu użytkownika! Status: <span class="hljs-subst">${userResponse.status}</span>`</span>
      );
    }
    <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> userResponse.<span class="hljs-title function_">json</span>(); <span class="hljs-comment">// Poczekaj na parsowanie JSON</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Pobrany użytkownik:"</span>, user.<span class="hljs-property">name</span>, user.<span class="hljs-property">email</span>);

    <span class="hljs-comment">// Krok 2: Pobierz posty tego użytkownika</span>
    <span class="hljs-keyword">const</span> postsResponse = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(
      <span class="hljs-string">`https://jsonplaceholder.typicode.com/posts?userId=<span class="hljs-subst">${user.id}</span>`</span>
    );
    <span class="hljs-keyword">if</span> (!postsResponse.<span class="hljs-property">ok</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(
        <span class="hljs-string">`Błąd HTTP przy pobieraniu postów! Status: <span class="hljs-subst">${postsResponse.status}</span>`</span>
      );
    }
    <span class="hljs-keyword">const</span> posts = <span class="hljs-keyword">await</span> postsResponse.<span class="hljs-title function_">json</span>(); <span class="hljs-comment">// Poczekaj na parsowanie JSON</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Liczba postów użytkownika:"</span>, posts.<span class="hljs-property">length</span>);

    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Wszystkie dane zostały pobrane pomyślnie."</span>);
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-comment">// Obsługa każdego błędu, który wystąpił na dowolnym etapie</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"Wystąpił błąd w funkcji async:"</span>, error.<span class="hljs-property">message</span>);
  } <span class="hljs-keyword">finally</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Operacja pobierania danych zakończona."</span>);
  }
}

<span class="hljs-comment">// Wywołanie funkcji async</span>
<span class="hljs-title function_">pobierzDaneUzytkownikaIPosty</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Kod poza funkcją async nadal się wykonuje..."</span>); <span class="hljs-comment">// Pokazuje asynchroniczność</span>
</code></pre>
<p>Widzisz, jak kod stał się znacznie bardziej liniowy i czytelny? Wygląda to prawie jak tradycyjny kod synchroniczny, mimo że w tle nadal działają Promise i cała magia asynchroniczności.</p>
<h3 id="zwracanie-wartości-i-obsługa-błędów" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#zwracanie-wartości-i-obsługa-błędów">>>></a>Zwracanie wartości i obsługa błędów</h3>
<ul>
<li>
<p><strong>Zwracanie wartości z funkcji <code>async</code></strong>:
Jeśli funkcja <code>async</code> zwraca jakąś wartość, ta wartość jest automatycznie opakowywana w Promise, który zostanie spełniony z tą wartością.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">zwrocLiczbe</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// Możesz też użyć await, np. await Promise.resolve(42);</span>
  <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;
}
<span class="hljs-title function_">zwrocLiczbe</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">val</span>) =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(val)); <span class="hljs-comment">// Wyświetli: 42</span>
</code></pre>
</li>
<li>
<p><strong>Obsługa błędów z <code>try...catch</code></strong>:
Największą zaletą <code>async/await</code> jest to, że pozwala na używanie standardowych bloków <code>try...catch</code> do obsługi błędów w kodzie asynchronicznym. Jeśli Promise, na który czeka <code>await</code>, zostanie odrzucony (rejected), <code>await</code> "rzuci" błąd, który zostanie przechwycony przez blok <code>catch</code>.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">symulujBlad</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> {
      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"Coś poszło nie tak!"</span>)), <span class="hljs-number">1000</span>);
    });
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result); <span class="hljs-comment">// To się nie wykona</span>
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"Złapano błąd:"</span>, error.<span class="hljs-property">message</span>); <span class="hljs-comment">// Wyświetli: Złapano błąd: Coś poszło nie tak!</span>
  }
}
<span class="hljs-title function_">symulujBlad</span>();
</code></pre>
</li>
</ul>
<p><code>async/await</code> to obecnie <strong>najczęściej rekomendowany</strong> sposób pracy z asynchronicznością w JavaScript, ponieważ znacząco poprawia czytelność i łatwość utrzymania kodu, sprawiając, że złożone operacje asynchroniczne stają się bardziej przejrzyste.</p>
<hr>
<h2 id="zadania-do-wykonania-sprawdź-swoją-wiedzę" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#zadania-do-wykonania-sprawdź-swoją-wiedzę">>></a>Zadania do wykonania: Sprawdź swoją wiedzę!</h2>
<p>Czas na praktykę! Rozwiąż te zadania, aby utrwalić to, czego się nauczyłeś/aś. Po każdym zadaniu możesz rozwinąć sekcję <code>Pokaż rozwiązanie</code>, aby sprawdzić swój kod. Powodzenia! 💪</p>
<h3 id="zadanie-1" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#zadanie-1">>>></a>Zadanie 1</h3>
<p>Napisz <strong>funkcję strzałkową</strong>, która przyjmuje dowolną liczbę argumentów numerycznych i zwraca ich sumę. Użyj <strong>rest operatora</strong> do zebrania argumentów.</p>
<details>
<summary>
<span>Pokaż rozwiązanie</span>
</summary>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">sumaWszystkichLiczb</span> = (<span class="hljs-params">...liczby</span>) => {
  <span class="hljs-keyword">return</span> liczby.<span class="hljs-title function_">reduce</span>(
    <span class="hljs-function">(<span class="hljs-params">akumulator, aktualnaLiczba</span>) =></span> akumulator + aktualnaLiczba,
    <span class="hljs-number">0</span>
  );
};

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sumaWszystkichLiczb</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">// Oczekiwany wynik: 6</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sumaWszystkichLiczb</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>)); <span class="hljs-comment">// Oczekiwany wynik: 100</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sumaWszystkichLiczb</span>()); <span class="hljs-comment">// Oczekiwany wynik: 0</span>
</code></pre>
</details>
<hr>
<h3 id="zadanie-2" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#zadanie-2">>>></a>Zadanie 2</h3>
<p>Utwórz obiekt reprezentujący produkt z kluczami: <code>nazwa</code>, <code>cena</code>, <code>dostepny</code>. Następnie użyj <strong>destrukturyzacji obiektu</strong>, aby wyodrębnić te wartości do osobnych zmiennych i wyświetlić je w konsoli. Dodaj również zmienną <code>producent</code> z wartością domyślną "Nieznany", na wypadek gdyby nie było jej w obiekcie.</p>
<details>
<summary>
<span>Pokaż rozwiązanie</span>
</summary>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> produkt = { <span class="hljs-attr">nazwa</span>: <span class="hljs-string">"Książka JS"</span>, <span class="hljs-attr">cena</span>: <span class="hljs-number">49.99</span>, <span class="hljs-attr">dostepny</span>: <span class="hljs-literal">true</span> };

<span class="hljs-keyword">const</span> { nazwa, cena, dostepny, producent = <span class="hljs-string">"Nieznany"</span> } = produkt;

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Nazwa: <span class="hljs-subst">${nazwa}</span>`</span>); <span class="hljs-comment">// Oczekiwany wynik: Nazwa: Książka JS</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Cena: <span class="hljs-subst">${cena}</span> zł`</span>); <span class="hljs-comment">// Oczekiwany wynik: Cena: 49.99 zł</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Dostępny: <span class="hljs-subst">${dostepny}</span>`</span>); <span class="hljs-comment">// Oczekiwany wynik: Dostępny: true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Producent: <span class="hljs-subst">${producent}</span>`</span>); <span class="hljs-comment">// Oczekiwany wynik: Producent: Nieznany</span>
</code></pre>
</details>
<hr>
<h3 id="zadanie-3" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#zadanie-3">>>></a>Zadanie 3</h3>
<p>Stwórz tablicę ulubionych filmów. Następnie użyj <strong>operatora spread</strong> do utworzenia nowej tablicy, która będzie zawierać wszystkie te filmy plus dwa dodatkowe filmy na końcu. Wyświetl nową tablicę w konsoli.</p>
<details>
<summary>
<span>Pokaż rozwiązanie</span>
</summary>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> ulubioneFilmy = [<span class="hljs-string">"Incepcja"</span>, <span class="hljs-string">"Matrix"</span>, <span class="hljs-string">"Interstellar"</span>];

<span class="hljs-keyword">const</span> nowaListaFilmow = [...ulubioneFilmy, <span class="hljs-string">"Pulp Fiction"</span>, <span class="hljs-string">"Forrest Gump"</span>];

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(nowaListaFilmow);
<span class="hljs-comment">// Oczekiwany wynik: ["Incepcja", "Matrix", "Interstellar", "Pulp Fiction", "Forrest Gump"]</span>
</code></pre>
</details>
<hr>
<h3 id="zadanie-4" class="scroll-mt-20"><a class="mr-2 no-underline hover:underline focus-visible:underline select-none" href="#zadanie-4">>>></a>Zadanie 4</h3>
<p>Napisz <strong>funkcję asynchroniczną</strong> o nazwie <code>pobierzWiadomosc</code>, która symuluje pobieranie wiadomości z serwera. Funkcja powinna używać <code>setTimeout</code>, aby po 3 sekundach zwrócić tekst "Wiadomość pobrana!". Użyj <code>async/await</code> do wywołania tej funkcji i wyświetlenia jej wyniku w konsoli. Dodaj również blok <code>try...catch</code> do obsługi potencjalnych błędów.</p>
<details>
<summary>
<span>Pokaż rozwiązanie</span>
</summary>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// Funkcja symulująca pobieranie danych (zwraca Promise)</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">pobierzWiadomoscAPI</span> = (<span class="hljs-params"></span>) => {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> {
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> {
      <span class="hljs-comment">// Możesz zmienić to na reject, aby przetestować obsługę błędów</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() > <span class="hljs-number">0.1</span>) {
        <span class="hljs-comment">// 90% szans na sukces, 10% na błąd</span>
        <span class="hljs-title function_">resolve</span>(<span class="hljs-string">"Wiadomość pobrana pomyślnie!"</span>);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"Błąd podczas pobierania wiadomości!"</span>));
      }
    }, <span class="hljs-number">3000</span>); <span class="hljs-comment">// Symulujemy 3 sekundy oczekiwania</span>
  });
};

<span class="hljs-comment">// Funkcja asynchroniczna używająca async/await</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">pobierzWiadomosc</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Rozpoczynam pobieranie wiadomości..."</span>);
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> wiadomosc = <span class="hljs-keyword">await</span> <span class="hljs-title function_">pobierzWiadomoscAPI</span>(); <span class="hljs-comment">// Czekaj, aż Promise się spełni</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Sukces:"</span>, wiadomosc);
  } <span class="hljs-keyword">catch</span> (error) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"Wystąpił błąd:"</span>, error.<span class="hljs-property">message</span>); <span class="hljs-comment">// Złap i wyświetl błąd</span>
  } <span class="hljs-keyword">finally</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Zakończono próbę pobierania wiadomości."</span>);
  }
}

<span class="hljs-comment">// Wywołaj funkcję asynchroniczną</span>
<span class="hljs-title function_">pobierzWiadomosc</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(
  <span class="hljs-string">"Ten tekst wyświetli się natychmiast po uruchomieniu programu, zanim wiadomość zostanie pobrana."</span>
);
</code></pre>
</details>
<hr>
<p>Gratulacje! 🎉 Dotarłeś/aś do końca kursu wprowadzającego w nowoczesny JavaScript. Masz teraz solidne podstawy do dalszego rozwoju. Pamiętaj, że kluczem jest praktyka - im więcej będziesz kodować, tym lepiej zrozumiesz te koncepcje.</p>
<p>Co chciałbyś/chciałabyś zgłębić dalej? Może:</p>
<ul>
<li><strong>Moduły ES6</strong> (import/export)?</li>
<li><strong>Klasy</strong> w JavaScript (obiektowość)?</li>
<li><strong>Metody tablicowe</strong> (map, filter, reduce)?</li>
<li>Głębsze nurkowanie w <strong>asynchroniczność</strong> i Web API?</li>
</ul>
<p>Daj znać! 😊</p></article><div class="container prose"><h2>Quiz: Podstawy nowoczesnego JavaScript</h2><div><p class="font-bold mb-0!">Pytanie <!-- -->1<!-- --> z <!-- -->5</p><div class="prose-p:mt-2"><p>Jaką główną różnicę między <code>let</code> a <code>var</code> podkreśla się w nowoczesnym JavaScript?</p></div><div class="grid grid-flow-row gap-3"><button data-slot="button" class="button button--variant-outline button--size-sm w-full text-left inline-flex justify-start transition-none text-wrap! min-h-min! py-1.5 cursor-pointer">Obie są identyczne</button><button data-slot="button" class="button button--variant-outline button--size-sm w-full text-left inline-flex justify-start transition-none text-wrap! min-h-min! py-1.5 cursor-pointer">Zakres blokowy (`block scope`) w `let`</button><button data-slot="button" class="button button--variant-outline button--size-sm w-full text-left inline-flex justify-start transition-none text-wrap! min-h-min! py-1.5 cursor-pointer">`let` nie pozwala na przyjmowanie wartości domyślnej</button><button data-slot="button" class="button button--variant-outline button--size-sm w-full text-left inline-flex justify-start transition-none text-wrap! min-h-min! py-1.5 cursor-pointer">`var` nie istnieje w nowoczesnym JS</button></div></div></div><div class="container"><p class="button button--variant-secondary button--size-lg w-full p-10 text-wrap flex-wrap h-auto text-center gap-y-4 text-wrap!" data-slot="button">Widzisz jakiś błąd, bądź literówkę? Chcesz coś poprawić?<a href="https://github.com/jakubszpil/jakubszpil.github.io/edit/main/app/content/courses/nowoczesny-javascript.md" target="_blank" rel="noreferrer" data-slot="button" class="button button--variant-link button--size-default">✏️ Przejdź do edycji tego pliku</a></p></div></main><footer class="prose max-w-full border-t"><div class="container flex items-center gap-3 justify-start flex-wrap-reverse lg:justify-between"><p class="xl:text-sm">© <!-- -->2025<a data-slot="button" class="button button--variant-link button--size-sm" href="/" data-discover="true">jakubszpil</a></p><nav class="flex items-center flex-wrap -ml-3"><a data-slot="button" class="button button--variant-link button--size-sm" href="/" data-discover="true">🏠 Strona główna</a><a data-slot="button" class="button button--variant-link button--size-sm" href="/blog" data-discover="true">📝 Blog</a><a data-slot="button" class="button button--variant-link button--size-sm" href="/learning" data-discover="true">🏫 Learning</a><a data-slot="button" class="button button--variant-link button--size-sm" href="/portfolio" data-discover="true">🛠️ Portfolio</a><a data-slot="button" class="button button--variant-link button--size-sm" href="/me" data-discover="true">🙋‍♂️ O mnie</a><a data-slot="button" class="button button--variant-link button--size-sm" href="/search" data-discover="true">🔍 Szukaj</a><a data-slot="button" class="button button--variant-link button--size-sm" href="/handbook" data-discover="true">📋 Handbook</a></nav></div></footer><script>((storageKey2, restoreKey) => {
    if (!window.history.state || !window.history.state.key) {
      let key = Math.random().toString(32).slice(2);
      window.history.replaceState({ key }, "");
    }
    try {
      let positions = JSON.parse(sessionStorage.getItem(storageKey2) || "{}");
      let storedY = positions[restoreKey || window.history.state.key];
      if (typeof storedY === "number") {
        window.scrollTo(0, storedY);
      }
    } catch (error) {
      console.error(error);
      sessionStorage.removeItem(storageKey2);
    }
  })("react-router-scroll-positions", "/learning/nowoczesny-javascript/.default")</script><script>window.__reactRouterContext = {"basename":"/","future":{"v8_middleware":false,"unstable_optimizeDeps":true,"unstable_splitRouteModules":true,"unstable_subResourceIntegrity":false,"unstable_viteEnvironmentApi":true},"routeDiscovery":{"mode":"initial"},"ssr":false,"isSpaMode":false};window.__reactRouterContext.stream = new ReadableStream({start(controller){window.__reactRouterContext.streamController = controller;}}).pipeThrough(new TextEncoderStream());</script><script type="module" async="">import "/assets/manifest-1aebbe92.js";
import * as route0 from "/assets/root-Cvi6AeB_.js";
import * as route1 from "/assets/layout-DYpV2se7.js";
import * as route2 from "/assets/course-details-DLJ6fZBl.js";
  
  window.__reactRouterRouteModules = {"root":route0,"routes/layout":route1,"course-details":route2};

import("/assets/entry.client-D07Jc1yP.js");</script><!--$?--><template id="B:0"></template><!--/$--><script id="_R_">requestAnimationFrame(function(){$RT=performance.now()});</script><div hidden id="S:0"><script>window.__reactRouterContext.streamController.enqueue("[{\"_1\":2,\"_7\":-5,\"_8\":-5},\"loaderData\",{\"_3\":4},\"course-details\",{\"_5\":6},\"v\",\"㞂⁆⁜⁊੠㬸ᧀ蘎䀈໩腈ಠദ̘נ➀㘂婠胶\\uda31䨊循ƺꁩ栀瀂衒偁큈톘ŘꙒ뀦―Ö든ִ찠挀倞準ꨒ㭄ٸ᧍牥쎛✧ᒀ଄経ཆ搛์\\u0013䙌儖ş⃔棊Ы娊฀챺娄儸䭇䩬泿ბ匄岂ꊤ兦䨀耺䰀甲婀偀㌀坌パ呑ₜ깞縡ㅌ牴고렖樾魀⅀ቬጛ⣲吕滒٦㡌3㺄ᵒ㕜ፔ氻⎓\\uda0f₸石茿缭鲀撡딺ꉊᆇ䟐ጡ芌̓闢ࡢᶰꡀྠ㟅䏧㧁ꢆ䐄㓢썣ₐ晘鲚梣፬찀ᑀ考恹ㆰ뢖蒄Ԓ老둀⩹㈖鸤鍃憼鶩鴟둃♟ଊ␑탊䤅\\udaa8偃Ӕ₃むº鉋搈刭曢ᭈฃ 　᤽\\u0016-㞵逘̳稀⫞ᨻỴ떣\\ude80ᚯ╅Ԁ䆠E㺭ᲉӀ\\u0015ᡑ་펉쵢柳灊品䋭樌考찠Ǳ존\\udd4cᦃ撈䀎юⱦ卉耲턴פֿݴ詛荶ঢເẙ甕幠剋闷瞀⋜帨躀䜄ͪL䉳鰉㪾쑧匛䨀㼖챢ਠ\\u000f☃ӈë䋮Գ䂰窒㉪荞⠦؃傌ຄ퉠\\u0005\\u0000檆뀺ࡌ묈瀎ဂ匾㡺尊⃡ర䗣部菮錘褥ʣ壨럃芚购퀱࠯礠莄麌缙悔쮁噤蜄成횤聡䀀⌤肀존䌘ꠔ䊐᱈嘏葡\\ud825ɂ帔⨅膘儧̦验䆉昡㞖հ\\udca4㜑샲/鄆\\uda76㶀ఫ኱飱И辉쁡儏ຂט\\udeddꇫ릐ጲಀ¼㥈࿣倸ꘁず紪١쀁ꎢ핑岃ࣨ⥒항厈غᰊ到Ȕ䷗⸘۩뫵澸ࠂ☁噠ʇ撴풤ᥔ㓕畲\\u0018⁽ƆĔ\\udd6e閺褃뗵筁핕ᶣ姑畝‷槪\\udd4f緙舽ﵾ\\ud836봣䧑ȷ娙﷋喠ͱ།의턴␳矗㑸烂ʴ૶☂䆀嚆\\udab4ࡈ﹛됍ㆌ鹶⨞爵ﴋ圀ú덣Ƃ〄脽\\ud8b4⣽㡷茁ꢋ䊈ҥ쵲遒\\udf33콽桙萭愤\\ud806䓓枑ᗿꀛꙠꆯ⵲㹇ń⛯⧪\\udb92ㆹ‎鬘ᤲ\\u0002‡㴏訒Ԫ躢㲳袪ᑴ椭ࡆ㒘ㆿ䊆刃뛐᝭\\ud9c5頩訆త斈펭뵍懅櫢큗뫮酙忩 ࣂ놴ࢩ耇Ｔᜒꂨ晉솬怎Ʋꃂ洂솏茨ᜂ㡽⼩ጏ뽳˺Ȋ㩔꠆췒₠㇅䌖꘬쀀㤥ை䘉⇹쩰䖱藺穮鮽퀁ɡ쀥폄傌午䃘紃ተᢅ鱛ꯇ๶ᅨ慡ୀ∝胮ҋ문尌・끐橽ࡺど鎔华녊脘燉㤟㓤ષᶸ硄薼䔬죨ඃ遑僴ደ١꠼胜儏ᕵ屵\\udbb2ᬦ얮㔉䢴⃠氆ᜐ澥擂ᡎꃨ༉聰颌剀9悃蓣ᢗ퉀⣎Ṱ命ସ䱜㬂㲎㏤퉶ㅅ\\udc65ᕑ呺迢阻嫏夌碎䀴䗹䁐컼䀽躡踰✸燸鞃㈖䯅蒗ⅉ戔丱頀㍄爏ꇜ䔀ᳵ鲂ె蛁鈁ॎ텗눡ǎ蠄႔à背ㄫ炾歁务툹᥿⊮磅ꌷꫬ\\ud9aa땶ꨨ몷픖⃁鮣冮㔦듖䴢逡栌켖ᣋ杣溨ᐕ및쪋忩Ყ괲㙉튖㋜애膕ꢏ僪핤뵧逘瘟耰젛ꤋਬ\\u001e瀰կ䓫鲩ꎍ묍ゖ桚跖尭㫧䨛甀ૄⰑꘃૈ\\ud8e6슉櫳文즹\\udf30ꏣ㮜뒰餑ᘔ괘廳쾥︑Ǽ訥댵칦獯鞌֜Ȗ沱馒當Ṱ蓝啘䊝涸倶ැ஛㠉沐ᆡ\\u0004랐!淪樟舢纘᠀瘫赁ⶵ$儛눖ɖᑝ鮷툠჋䁤鿣ߙ㺚腈੅딧츀達ବꉢѢՆ캓팰į੖舨联̡咍惠謩펊幁煚筆隇᧲\\ude57蟡舎튨糌썶勞샫ᔧ逳ु껚ⴷ怀蒘ဂ\\u0000뷼ݸ\\u0000ሑ耂저ᤸ謐簞耎쨖藳ܯ뤰౐ ፷ܕ΁⠿໨億苇࿀㫦㮃\\udd45ᒁࣺ࢈舰攨뢼㬂䀱⩎ꢌ␇ꈒ๙⚜蘿ꌔࡆ偒⢓䠙ଢꀰ䗑稀수⌌恔ঌꄟ碤韁䐍规帻農頚꣞␆耰㕓梞슦栽΁瘼ꉈ됀掖䍊梢Ã淕Ꮄ뉖䰺쓊틂䲆⢮耈⓻鐏ꗒҢ诐ఠ䡔㥇\\udcb3\\ud937헃Ყ얰⠌專䄷蛂\\udd4f腠욅賄뢚耰\\ud897ᆓ㠎䃠徂猿਷퀰Ц⩻ਵ㏑ഠᅭ閻㣎鄂醕詘㔄溞褜⟋脯ᤌ碨蕃ꉉ쿦ꠎ䊬揆㟸܌ೣ蟃챴跒鍘Ӡ馵˴턱\\udabb猅糤鎃ᆗ䔧뫛䜱缐䫠ᠲ䃔㷧ꀯ껲㱪騡ꄻ쒠鮅↔깅䀼ؒ봢雱Д䵹킞帻킄臔镉䅘禐젏ᴃ⛳ݡ朙㒠랆焸⇉리ფ愶틃送聱䈸䝄봳遴쪞䆧㙘䏍ก되갏〵엫氀府聘㷇㩊卂豆ؼ❠§◼ㅿ⯸筩՞꽔웱轪ꓲ䀳ꀖ퐀〘儀᡽㠩䢊모᠁Ϗ一搵Ȏ脠䰏㜂⢐ᱞ䯷髀曠鼖芳ո梊ኹࠁ셚鴾朁駿膼᜕戺狳ᧈ雪\\udd88ꮭ﴾᱃랴ୱ厊燘֏뮠䕅↛ꍕ潗ꈂ䀁鵰ؼ淏栀抲﹒耆嬦瀃ာ怀ᒆ⠒賱橢鵧䣟ḽꯓ䷕錬瀐놗㗏䔤䀱꼱ﺼ㰄㠊磉ꔱ댈徂ᵉ꼧麽敔Ӯϲ』ᶈ㾛ꭵ䋮᭒煙\\u000e佇據ꦣ鐁隕ꜟ㈿螏⹑ꊃ\\udb0a胓쾡霾虷튠̜碠鐐ꍐ汍햃琛䥪◅愅㚵頦Ϙ뗊髤ใΉ蛚怵᷸㰓똡渨葉㣻ﭏ衻唵렜㸓隭௤ᦁ徍ﭠ⒲ᠰ舑魑퀼ᬦ觐ؒ꫸谳棢ǁʥ苆녺ᐞ訔ƃ甁Ǡ娒䐡њሣ愼堘┄谹솮뒱Ｕ̠ԑ针ነ䌼Ⱬ찜䃏ނ᠊֏괃ﮱ蕏뒸쾎ۮⴉǃ놊Ꙁ㾀拠뺂㠉њꡡ遀揙࢑枟ꄰ䄪牋⌃䞯艒㩺Ҷꇴ㮃逷倯㖆\\ud865Ϙ筳ꂝ|ᓳ롪ॷ龄䙞ꍀ逛ϖក쑘Ǆ䨃逡薠熄侩蕠䖸獿ᑀ롿鍳꿳톧聣ጂ぀ɰ媀䔰䀃닸机\\ud830致Ӂ\\udc1c硙㪒퀀蕿ॳ퀼Ϩ逑ᘐ힅煅袋⡒਌噁Ꭿ䫠ྑм올國䐺ɂ➻㮝䒘恻顶Ҁ►栆⨁삋蛠눂な﫻㧹\\u0004㕂搂쉧뙸枘쒉᩹㰳ǘ⹈ش䠗㺂롇ݭ뤁艧ꀢ乻≚읽㱫\\uda82餖\\u0002䠼ࠥ肤ᐤ쉠쩜擱钚⚼ⷚ庶╍㰢醥ø⶙輭䙮㨄瘦ռ獄ﱋⒼ⨃䬚筶뤣龈┒䐥贩懴%蚴▛鬦섔䔂ꟃ逎꟬뺥谟驳ꔂ豅ꡳ꺦뉥ꝼ㝐⦃Ɬ먣䬗笪䜐㉄Ⓚ嚦蚹ꛂ噂穦鵈뉅ꗂ矀逸鍐ࡁفꝼᢤ䩔꜇貦宁사嶀،䋸痙㿫怔䈰䖨⦱擣蓇⾁⫸吸䱈쒌奺\\uddb2䍄ⱀ낡朤Ⅲ缥芖态稀萎㩃떳䎘絆\\udc9f묣ᦸﮕ㫤ᑂ봘箯㔇턴端걹᾵鄧蝹딚祸ཹ劚䧣㎀몳ꂃ뎧㭳꼸겿㫂邸讓Ƌ躸䮕덋겻쮢뮾䗀ꮉ펫鰡殷꧰ሡ뤰ሂ鮅蓼狤䞔磇讆래欧験꾟䐞䅹馱窞矒㮡螗髱‵碈뫣힃킈鍻檵炷龑랊ኡ䮉钆ᛷ馘漢ヹ箧ꃻ轢琹拂क़吆䫂ࢠ\\uda0e변垊⋲騍臐ⷠꈽ鍯ዃ鰁슇⬀า˙먠쁚쁐ᧃ혻᚞ᔗ霱ꡂ焞쁔궛麘ॸࠡ낡ᏐᕁꌴՁ肋સ࢐ꐘl㳡∨\\ud9a3饨඿梑겣奊䅄⺖爣譤긊肬闊᧺䥡ᑹ畻ꤖ饓륥杨㰗孥䔔湽笍꣩喋膩拁念쌼㜥碥퍹뺁뀠x଀㰊ꂬ␒鐲椰ⷢ饅깒厨怮勦텉큷軥ꄩèㅧᄉ뢀ହ뎛ꭞ伻稟㢳ꏧ\\udb33秀쮜레㚺꿦逪렁暸ሙ훫믦腟荳萔굴ꚇ듔ꅺᄴ㟔ⵒ훿ι렡㖓텏훑ꇄ袾ိ儒］禑ឺ蘏ᗅ걀鞐ඁ墤蓨ᅥ硆껣ꍜ闱᪖桂≩炉Ḯ咈酖镼팷辑碱噶鈗荝鉐Ֆ皢㫄Ɒ㦓量☁Ŀ㐜ᇁƚ镉䜐⤶⎜У倮\\udae0⸈ࠦ荏㹙쪆䬷瘭逌֙獀ㄿ苩涐ꜭꌀ鑼厤ઃ঴᤾ⳣ츈졌Ⴙ㐬㜥ꀋ듗鐫ᱩ⯗꣔ꍉ懆惀㈑肊ℑ溉ᏸ꯸ﰣ銸㨢谻ࣵ䪊⨛䇠㳫퀬ᐞ࢈\\u0007델뺡㜥䑀ꐆ䦔㝂һ㒉袊퀅솑䨓\\udb70䃄ނ栰聱Ჴ⭰瞗孀㼓脅訸肯鑞ꏃꥡ\\ud884ខꨕ䒡㖩됄拄⎧퀦孎པ\\udb15\\ud9f5ᗣ㭪⅄㭛簑苁䞕ݡ䉞뮷낺䊷㧂䉉ᤃ䎤示얖됿⺀輔䉀㺶\\udf7e偌饰뎸〵㨀猂졵㎡⠸⤊꧊沖㈢띑坡쨜䠍⪤篈斃倷効沩㊡㉂鹒怦⥿始胎좫ᵹꃊ텧攳ﲇ⡋␱紷愒鄌銙༊蘳⸁肠띒渦ए䭒鋋䴀⭊슎᥶ᐽ惫湃坑๠鹄뀢븏瘥ᑢ꜂洽຀쐱໩㞣ኤ蹒ꌌ∋ཽᬎ性Ύ᥃⋤ៃ烃⏋䝧瘤⺇࣪ᔎ뢌퐶辐팲騋㎊꿷첷㋳㼲଑࿊谨磨텲蜋W쮪릃ꬖ睫㮌ヨ터ﺏ瘡辴ᯛ㚌닐ឫ愃皈፵’㋄㳚⥧ˠຶ⍫趒괰⪎輤\\ude8dራྰላ䊫ᘓ쓉⮤쀂殴ဒ驠֪ɻӫ쀅섔∃뺓⏿꧔烅躜㊀嬕년Ⴓ銝䶄짐ꓓ䰘쭎ꮴ女愥$켌\\ud8cc䳦Ō쳏䉜ό⳧ƻ錂곑ꮬ\\udc88诫⫢얧뀾ក食碓㆖㍁睡덜✶ⴈ嘐䆊⿱鄹똌ࢴ錰ᦥ硺螺㔯ⅷ㸜屮幷䴗夁漻ஒ⚬낱੃鋀탃勠ၚ뾾荢\\ude77邋㚚셙欲∶ʱ锇혊邅寡䈩悅釋⋬⻮ぐ쐟ጄ㗃䜕舮ࢉྞ埫徴칄퓓봛墦䆵ᶴ⸤禮䈕잎ᖭ旤浗㥭仗鹞횋ꇔ繉퐽䗗⮵퟾䚹ū돗腱륁矆宙ঌත츝꿁䛤롎ᘻ뀶辌Śﯨ츒渟๖჈讑凢六㟐␯᫦㈷⌂쑼巴싡氭㿍⋴颿瑙훵|嚴⼱㜯Ҷᅷ䏫啔\\ude25闄츣Ϣ疌⼮嶃ꐾ뜾ᚬ଺酎흰褂㮼䍇瘊\\udaad덬풚컬恱薍铭戊䆨◩砧⏱ᙤ᝘㬾Сᠻ똲ࢍ愂̈ᭃ㛒칭Ĩ銺\\udc73稂㌷걳省ﻢ쬵腞섭Я䣞삑璤几郦큨⪞ᡀʫ膃欶쵵뤹俨ྃ譪᳦갗나Ǘ掋\\ud994闘⽉经㑧䜳Ĺ퀾ᾊ擥渽漣゜㛻᪮㞙啖찬盘푶ᢝ黷懶틳轖랖㛰軌ݕ묈仐훕鰠ꄥǎ\\udaaf⽩飺翚ꀠ㬮앬싈䭎蓼컢Ḯ⻰脸㽧戔媦熇꽉釬ㅽ邞쒞盍ꂧ虵䞶唷圙洞㙇薖एم三Ĺ㖥鶠⽉肶∃ↀ䩒ᛠ闊廏⛠旰儲\\udfc3㧃奫疃뤥뀰꽈ᰡ齴닭࣬䆸硙崸昊燛䃄֓㻠눁ᄣ鳯挪퍙艴먂ꊚ苑了㳈楡ᜠù儘௵཮ᯜヂ᷈䅘ळ⚦䬄㕐ᰐ멢⨃㎡㧞ꊟ鲉쁸釿噞겜㍞咐┝퇤撺➯㊊뇚퓴铈熉ᯚ뾹乐᠀렳篣မϸ㘼ꐾ⾔穚呼䐥퍑쾺渊鰑쒤뙖⧛똅\\udc2d⼮협䷿ૠ胖Ẍ\\ud82e鹴닇୐띁৿黶ࡲ帞ᩖǯ䦌렩ᄇ௥⸣⺚ᆚ퀌Ἦฮ핞ⶸ뉕ᦥ鉋笉僵纾捺䌳蜑砒\\ud8cfѫ够䍢ﰟ鰷ᮙՈᗬ䍼ᰙ僩껷\\ud84c뮢᭗폮듬焑铂\\ud8afꄩ舩㖿荵\\udb6f疋㯯潴ퟲ\\ud902쐪蕵偿뢼弯禐獩宙㭘⟳㺘䰭ᇆꀶ뀋枳쫽鄪ﮉ쀸䗭줳觏㵉ﷵ焍\\ud8db࠼귲巔连᠐\\udc60띀盓湶ﯶᔧｓ剳ժ甋ꌀ⓼⧠툫죽쫕쩂洶틀僴㍽ෑჃ펿츪翛ꢿ䗿ꉌ呫詏ꅿ\\udbb0냂↢ヲ賿႙抌đ㍅량聿Ȋ蛾怌w탽প倅샏昅٩ꘁ㶄Ѥ쏴쵴䁅ㄓ⃱ꛇ絘䚋긽상⇨뉅쑌텔䔐煒⢰\\udd41௳攙샔咬씿鿵ﱫ谣餄컨ࠉ솸䶥荊ṑ튆♪숡阑鿠錁؂袁ꈁ⁆䲛侠沚ᘀ僺䓀➠䠀鉌Ǻૐ뼲\\ud9a8䵯昛⛬㙿ꔰԀ䨒ʲᄘ頄릀첆戳熘亂ゔĢௌꚈ塗䧂ូ⠧㴌砶℅듟臿ᚂ䠕\\udd4a秅켮ᵧ頟䁈膰縠䎙膙᚜᠉듮숝렱襢兣먞偬ᢀ렘죁ﹲ烅ᡁ엩䰨偨✔⌂ꠤఫ쐬䲩怮ڢጰ㝑ꪀꙸ筕ࡘ翴ᡠ⦺ᤀꄄࣿ骍’谨㓅桐妤᱿冠ꪈꁪ꛺˃ไꍤ董܁㽁ᢖ贺ነ욛ဠ༠攃ꠛ䃌ϣ夠䩑Ḙ诒Ᾱﯕ쐱瓸✂둆圾맠韮䤉顎⠒ᛌ弚䪀⛡Ґ翐北釈㮔킕菕莰퐃ꠢば揂鰙᰽ߑ຀薂蔭+졘ㆄ䰢䀸ݰꅡ㴂ㄟ檸캡㈍\\ud983쎴ᓰﱇ됵Ⴍ와ؑSი݀쳢\\ud877菘滐㺚࿠啬♃㤁ǎ媜讖꨹Ⱇ엾㐪澙胛滸尠縣訂紕肝⢁籁뾕櫧靚蜹\\udd6b祏襺\\ud85cﭗࢯ궎ꗹ烘﹏뷕絩᭗ꭆ핪鼟裔ౙ絆Ꞑ텤ፅ黸῀ဋ䙀孖뼢偾ݨꨁ⁉䡀퐰蟸䃄ሟ蹐耑㑆ŀ⁾࣒娫ㅝ笉梾壼ஊ⣕ⱥ䃨䷾仱ĞⰝ遄㍅䇰唇㈳䀑掐٘㘙䲣뒲⸘䜙ᔞ㈖姰ባ栁\\u0007࿄囩ꍜ炢óⰝ斨葼媘ᖸ\\udd04ܗ衈賚᪂嘺ᇑ༅怚餀㗔瀋脸ŀ䴂奄ၴң➽젊崕댜᝺묀뀆䀼Е⹸훒櫕䄔叵鈌棎ᇇ规ﶉ䋨춫먬슞詼辢̕⸿䚝埖坑몈披옘荰䘲ੑ躂떸韦蒆密⾱倐㒝쨾ȁ넱Ћ諂眒醢赓ᆢ๰稣Ʉ槗8愤☯숕ώ뵣完㣥ሉ⒘걇हƜ贐ၚ頃삻큥ꦭ켖等\\uda4c舖잚倣䦚氠ꉎì纓奫ᢹ덛᧲鋧脒鋈访㕙⸋ꜥ蚒龠轩쀞❂樇含揦菬樒㋏丮Ҳ㘁㠤嵁⅜嘲赴묝ꥇฎ1䩖Δ㧁㶦ᑦᭊ뵣튟䀌꧞᫰ꊍᒾ틧蟴ꙏ났J鿺䬢뾊좉Ꮘ鉅鄑蒰㮐ꏡ쐐Ꝃ㛁怌桥졫ᡲ㮄挙ĵ軹㣝฀䁡艘ጁ卋膰⢬؊澢欂ᐎꂑ苒쁭눤刵Ⳑ蜡䠀ƨ傃䰚饲㶩䦡谿쀒⸥捋ࢰᘼ懰ฉ騪飔㚦\\udb4cԌ폄ᨏ౒鴣ᅯ⒉踣뺊뒕Ɯ㒸絊Ա뵁䮲㉡ᴢ꠫䖺緒麞袒౔㾫傥䄠퐙䠪ᦒ쓄氳ᐒ걘風㪙䭎쑽㎻궧퐥愐థᓃ阐Õ蓃Ȕ蒉葽숆鎠첛醘Ø朣膕천劤⧡詧錙੨纀ꂈ䑘䞃螽犝큼ꖻ岦瀥ᠵ鹴≁᧿䟆仍ㆎ璤䐭ሙ⣉晔䵐ẉ憃♈蚔솁ꢲㆋ듴杽ᚑ拓왊톩鰰ᱷ虫㼲▃㜰xᮨ\\u0001☀ひ咢ᦎ蜈쒥뙝苡ሠ뼛錰⚔쵄猳榒胜䔳◙ᗎ婷兇꽚⽥\\udd17\\ud920짅ѳ뺍吠⁌ቡ䐳∈덛阬힥쨲妔觉릔排䀮౾䃋치ʕ陈镧㕕梚쨤㢅뺘㉟ㅋ贁蔅皝胃䵬켡ꇷ糒殓ೊƹꎔ崾⃐蒌雤⬢堁쿚繕ﺁ䑬旇⌘謈ï雪䘁躇륷䇖ਲங풱׈슙犧⹥郌㜮ײ൦励襛ㆀ౑邼輠셋ꛁ䳲涗冪㛤䫴涚갭䱐懠ᒔ㈀躧띡춒舯엥忉퉦걃襻Ṙ컰蒐✉ⅈꫪ訶ᑰꢐ尭ꚷ펪지亻쀸͊໙舍⋮僮܂霘࠙櫊㧓䗌ꊌ¨镄棫\\udd6e℅\\udbac鴕츟臧燸ꋈ쏃褀토ꊣß┐并㮏셌雟ᑩ歁薈䒽鴀➄鐞ﯷ吺棐\\udcbc刋菂싸廀㸍懯꽈ᒙ鉞谄騯ᡒݼᲀ﷜䋪偲ꔴꪛꕴ櫕㌚慒ư೔ﷸᇑ鹳−ⵢ]䙱ぅᯤ풮蠼ब梒铸䭴盔딯䓺첉䝔ﲥቦ奰⃆\\udd4c㛧傍茒跄쒏꣠䮥≌䱟䭟᷎俆놱謬穉츂逗엨奀ᾎ褹喫歛⤻佘㣺⚊䉘浂뎹遊較吒⁈Ԑ߀︧쩂冯ꮽ戋ꢁវ댌펍ᩜȔ肃氃⥆疹䒈Ⓒ遠㛅\\ud942刔鞗⠞젬Ø⽼ド聧閂뚀뙓Ŀ鎐缪՛\\u0017柉⎓풫聘톺蠬୐ꬶᄑ吥䦡銯衐佋ᵉ쾥袔酥쮎렁꼩Ę婅쀑聽ŭ뉜鿌䠪Ṡᙇ䬛咄Ề斝毁꼗ᄁ쀚ɖ젤쪚궄垒ㄖ歄䒟边䰬\\uda00葙쌟釆曖녨ᤥꊶ䕫⯡鈏䡠嘲ጚ\\uda74兹邟満䩥ꫛࢢբᭀइꉫ끋춅꺫쎀䭙߫嶉喝갰္䪒鑢괄⍍鱴緧ᬘ課⒢纆갿魓턘峳\\ud964㵃⊇饊\\udad5购즜Ω〪刍呾芁ᦜ圭䂫同茻끨뜾彫ꆚ芷杵ᅕ＀ိꤥ槌ꌤᑯ쨺瀀亞ʯᬓ㎵擎䆂銌쎅璒胝䔾㐡ഈ謌厜㵵씷턴歃௔ﺲꊴڠ⢀릏遗ퟑڒ甀ုƨࡺ⺵痞쩾凫從ਫ਼ⷆ堶ꙡ௘愘啔㚌謾ဣ鋆၊ꔾ೮邈᠎ྺဗ㗃䄋礒䃇믅햅拵譆썀VᲑᚠⷩ䴎見⅍켺蚦㔵끟櫠啩鼐舊슝껠쾂웖㝓∅ࢍ뵷텳啌쟖頕启껺ᯫ춉﫿ꃝ⛩ﵾᬩ嘟绳߃쐩ƻ븫ࢊ혲餓쭶琇⅑\\uddfc토饐⵩ꥳ隆袻暻⸙殄晲ଯ呌䂯铨갳俪齜烮쎙ꏵ骠醄儂\\udaa3ṧ翉ス桀ൌ욧蟔늕䪫\\udd76熐䋊溙쨿튁㛡ὤ戉硜ှ\\udc5e俠欄鍌䚗৪\\ude85冭뚡穰떣\\bჴᝅ﷣鞝살ꢤ鷺뽉ꖭ䥜㜢潖푮퓵㞵ύ솃뎾芆ﺺ⵬쾣廪鸇\\ud90eȡꂙᡩ外ᯏ団洵庩ⶺ檁䆚὞難㔜㓍奩鸅骑鵌ꮄƴՀ淛罫ᰖ핂뾱텑ଠ欸Ɇ醮ꑧ椬͕∅葃殧䉅瑭ꭚ㬮\\ude73䴷匤ൠ梃䈀ꃚ‘㟁鸍흫뙚ⶺ苊ඣ뼹棘浣䅛ঝ暈┭尫䭘㮕䗶䆽䈖㖚榆캧똥ꟆⅮ⹲⏂\\ud84c䢵\\ud824ⱁ洺ﲜ‐࿭ᾨ᡿㮋ⶂⓧ紕㥒䛚秗⩬랹ጹ睁칯爥\\uda4a榇㚌⥛쫒賥ퟔ굵﫨覉즾䪎讴밊࿮珳瑮ⲧ葚馎뭰䄲╀Ɒ젽陏攁ଌ惭璋봽☉‴낢൐託\\udcac洽荣ᒒ岦媹뙿錥踠舮ꛢ墁䒱Ҝ깍㔀祘眤哎Ẉꖃ䭰঎饳莘‱⻯捁\\udc81⋱੼늀᫑ㅅ䠑ࠈ뀀癐ꀓ獸໫札唐氭砐騚团쯫铁㊨ꖷ靺\\udc82꬀莾苅뷀㖑孍壺氖◽⹐㩀ꈈ遹슅ĉ᪉鲖ꍩ쐡ϒ焨艈蜠钄꠯͚ਨ侢嗷傻Ҵ⹾午Ჰ샃⻅⣊漮㊏䐾䩥ݐ奅ሃ枮樤蛐ડ衙硢㙞쒴倃Вꠈۈ⟁椊ᐒ̊ហ聡怼噳箂휩䃮ᓸ鋮ᨎ瀘懫첐錇搠茺জ䎃气킚剴ⲁ茁瘶Ⲃጕǩ笟䇭膂룜宋搽๑䴁戓⒦蚇ࣽ鋴놶䑈봁⥺䁴ຼ鄏怐씈䑮별뱋઺핋蕊뱡̽أ䆥刀ปꋻᓎ釠溑品荌\\ud978΁ᚿႇᴤ臀ు闰鈳魢ଐ覴သ䐁隆尰朣밗䉳꫖蝺ꖋ쫙쌋퀒䌅々샮었䊁搅䆯‰ㅚᆀ텏\\ud90f쪦氁㠞딕ں苠⩟Ҧ鞴뭑 茑䂼ñ珱잃㻞䥐ᶐ긪臃ꎠ揖ጮ≷ꉟ⪲襋ⶢ䄆麮늷꣆쌲猘ဂ읭ᖏ룫ᨚ뇋鷅仹谋ᛞ༂磐䃖㯖↩褫뚒眛䰭㸷燯貆蝺㤇ꀽ鄬ఆ㚫㚳둹䙏蹜弾릠ὠ\\ud908掠\\udb57攝⯐≱倩ܒ鳁骥샞ᵐ簰쌁Ꮯ瑃ᑥ০䈈ᬋ厜煌蔞赤猿ჺଁ뼩륁Ѯ╃ⳡ騳逌‘᝖蝵䄾櫛嚶涢ﺀ㌐㗽뫇봹ꐱ䙯ᦑᅀ肿⧽暧騟爅蛪柵圏మ珉\\udf2cꏗ\\ud9bd榦蘐뮨堃ɨ᪤릱ꃼ㘡϶⺳\\udda7켆挨ㅏ遟좺暬\\udfaf흾Ꙁྻ⌁䭎\\uda74愀⇈ꦻꞇ⺃ᚅᡪ픿䕠哏ꙹ釞\\udea6猲ゎ傌ⴆ㓲텍㾮玩ᄲꖁ䗳㝓ᚍ储㈳谆賜Ã퓩쪵鈷䅙㚖扦矜ᳩ쀩郓졡鰡柃Ͻ儂ឿ췇쳐僧ౡ⣚㋵ఠ\\uddd1킆藰❶✎ᘝ녅獫儸띢ꀿ㘓ᕳ㢧㓄㏮䏙췏鰖㏡⚻으馧쎇ポ荍乺牭탹맏븯匿饎瀀ᘐ֖瓖滝⃬瓳튛㑜雌ꈢ⴨⫄囪헝\\ud984˾䧳Ξ穽驇㔬뇤繹఩麜\\udb80妣.暳혋苁㏬횉뢹ꋎ䔏ꫀꗏৌ䂒煱\\udf91穃㾶\\ude65鷯ꃢ௦轒샐혋䮭೐韃ヹ됡訚폎矑耓▁ⱜ谳仏뤧׼൰潻襹㒘䇈ಠ⬢ꁺ짐᎔滮슧㑋⤀\\u0015⹀钺䁈⸓Ṡᬁ栌ᙍ㍹酓㶦巍鬌艪薺暫똭䠯猪ᇴ롥鴂诫鸞䔢䡞斟ř焈㙝摱뇈࿥醵傰꣢疡糼慫밖ો䛸ﺙ⣜፰߱鞍㐀⃈颧㦗븂瀺銭㭖䈡꼥நꘂ䎸戗炗꛲洀❇씚ෲ꧃鞴졁蜌餢얂簏⧌薃剨᪻門腣埲ȁ䃺뎡㯠뭛줙Ŏ衱掎쪺쌹ⶁ吀눼甅⠸䐁ᐁЃϔ୐偎Ⅵ펮蔈幤ꓵ⚂ǙḬ먞厫舿蝫⁒ꦞ푕눽撎賛ꙷ㘀䋁耋街蘈㴁븏摊䃅㉩뙶韤뮥陷䀆ڠὦ㚊໼濆怀撖ꡠ技谨苐ᮀㅠ醽㜙볍＂끵ꘘ◦릴춄捖쾛㥄㙅돘枕꬀鶣Ǌ娌ⷦ湶켨⫝᛫㟙띙쉠팘⬑曧ᆼ耏䲄ᜡ䔂㽒Շꏕ\\ude61䬤\\udb26鼲ꖚ汖爹鋞㛙녎㙴歷鯼\\udfadႶꖺ귿汈쬆᫙雪㷴伭蹩浭ꁴ鋓࿀㢆疢料\\udf56䘄䈠┲ྠ敯ݴ季圎\\ude77㜅궊爅纳딋ꋝ눐뢈袯ⅱ巑媾屗햊䷲泡歔ꍫ⫍੄맋髆掫䴶虉㧍㭰鞞粒⺵〛갰㧫氌鄠圢峋츹畓貐溉搜룤抶叱ǭꅞຣ\\uda67㼆й憮ᢀ㻈醁㔧唏䌕鼐霠糉怏ྞ㙚榫榆ै剨萈䏂䭑媋誊ॐ䐵헁莰⬃擐袧紇ޔ뼰㡛袈Ţ䙠詯ڼ庖᭡ꠞ냆ꂗ醁啗喭ᆋ൧‚첁볻牛下ࣕ䛾⁽嘿⣇Ɦヶ䏿᤼穎ﱥᕉ䆄ﾀ⺿ꉈ㬅襈ᆤ䇩阮飚鈂㉡ˣ蹊聃ꬢ꺀ᙂ墧顚ꖼ탊딉)卬迖㝅葿Ꟶ즒ﱀ\\u0006ꧨ⢁ꪽ객樂众⠘㜦䢩졮붺ᯛ涆샪譔뼪Ƈⵄ땝돮⴬䃀件䍶ၝ\\ud85c藧ᵝ怍뭖娫㲀ሃᱞൽŀ᧫ꦸ㦸渘\\ud94d⤻⍬灜ၲﾖ怌㥀ᅏ禬㜻箥䀠䓫৬赲ꆊ笠ꖓ棃เ᯼洶ꗮ쌃뿨뀌筓云䞵쥰䬭㰂ঔອᯐ͛䴦侐Ү쒞ளⴄ肴ᢈ暌᠅궧뱱멦턪痓\\uda01娕杰ㅗ瑍쀢㬈༸ㅁ爂뮻࣎뮦瓠僴̬콎諝\\ud81f利ு常蝻ഽ咏㪜ፃ裂柅贄訉替㕠욦汫㓜霮麊䭍䜇䀏䢮঵꧟⳪穧盏賩陜蝠ႜ㙿᭶\\ude26괰䮻՜⟐㝵풅峰ᑗ㻹ᝧ鮗Ꭲ荦桀릞﨔獼е❴퍴ெ䕸精㩌Ϯ즮⁜乯뻡ᥞ⹫\\udf41궛藢ᝋ㨹ꊼ쀩隔썉԰亞坵⇴㪮䪽尀墣尐貂묒ﱕ桊髲쪏䓪䀉朂災핪ꔉꃿᠫ〰瓨뗒聭瓘ᠯ힀㠚㦼᱃ᖎ㸅䱷ﶔ畐갪覤峼땶Ҥ⍀㚞粊ႈ꽩ꈡ佳ᐤ䧑硍疫ꎧ뮱\\ud9ef텋\\ud938茖뷥鍻鬪ꃎ༒顂ꑁ뮏㽺都寂詖➯耲Ꮰ拇㮉⊹뵅ᶄ縻坺䬖魦栁䗾㦺ኊ䑀쎦ⶭﱅ鐵✍\\ude8eﭷ↥踡蘐悰콂쪱쎑䝗輅寵荈۱恠组潞帯ꠌ♴꫕ೠ⎢虤ၭ拉⿞䐄纘꒵瞡匷\\udf30蹰䕟禥똝ᱭ摹겹匉툵᱁싄ࠬ퍁ଶ䩭䡀Һ掯䇍﷯읰멬皜䶸≦ڈ雛ᱱ篾닭촓筿䒰⨱㊃ⱊ蒷珇酂㡃ӯᴟᷯ银㯼\\uddc1༯Ḋ岢⨁耙㝙ྈ／뇛坐Ꮕᬏ巪଍Ĺ鲀넙ꁜ♱쐶癬ꦭ딀힩䢼ዮ⹖薦⦢⣋棼먠鹦\\ud800‖pЧ抺㵼時찡匵⾂믾矁Ꞃ⣲䤋ၧ﫟ݩ⌌悍釩⍯课氅๯㑿䦡@웄\\uda28彜(潂⌆\\udb78彊약櫼ퟻ愵慺ほ廥镗솤湳ࣛ餶탰窲㮝㰾ᠠ꯵띠쩞ᲀ像\\ude36릗ટ懻᭯升봺塄職脀匟꿵粠㤮轝嶽㟉爫糯웧⺫鳜춽ꔔ家溯㊽Ⲙ뷅쭺旋\\udb65\\udacb뛏ᶶ륨⺹퍶向ﻟ拐ϯ\\udabf웷\\udf47㘼钼ẖ讣礠娦ᱬ蝼ਇ䠤ั₰蜣䠷Ʉᾒ㫰䲵뽻㢘␃☹\\ude22靷ꗵ龽㣒￑ዼ俥뤾ꡅʈ塽﬐鿑ૂ➡྘྄떛ꖗ뗛旴伡뢴╳墟箰爿ࢱ麓恣ﶍ礿憶㻤㕀皳屚쿭鎌配莍᝹뤇Ṉ阱硩멼技偙턠⇨䮰߆紞ቃ䯌͜ᆗ쫍Ａ䰉罧籦ⵂᏁ鴃衜埘㽽턏䏹릞僧藙㗿㲮밑瑹ᦥ븱\\ud9e4귷㾆ﮕ쩽Ⲇ陬蒱ᕱ碆䄂\\udde2﴾瀑⬡섈셰쌢〇ᡙᭌ퓽熶⿂瑍뷪聩㢮㾑Ⲻ聓뼰ᦟ쵺믡忿⨕깶⟾\\ude16㊾폽쮄꾏ﳦ˼翳뾿ꏨ署﹥뒧︅⫹篂垧ﰰ㧿㡰ｩ帿\\udeae자⠗믨ᔯ핀逍吶廔燨ൔᖂ䏺ꨩ\\udd9b䩽\\uda71鹮༛잲ኂ禌ꌽ蜨\\udeb2➬쪒砬ꑁ轮睓꽭聾롲硐浱閸䩸‐Ň\\uda18䶧锁綺瀥花ଃ軺陻Ѓ޶㪬⦀蠣蜁ꖃ阌\\uda10ꉧ탤֭ᕊ᪫逑⪛쉫ᆮ㊠㬰誼騴蠆㜜᪨솂⁥쨘큡苔芦╁⩥ඟ鹪項鲖셹\\uddcd怎혶쉭ǐ訲猋甃肇焬⨟鹦爣蓮쾏ݽ˗㸠渇陠⮘绕䉸ᰛ⑾퓊診ႁݼ运\\ude82Ⲇ⡛ॢ胪ꕺ䷡빚掠᳦⸅怫2襌㮴┆阂퀳膇狡찙鶚礄湆ꚾ ̔፠䃀ᴹ됚偵䄫荐ݐ䔊쯸봤஦F\\ud995躄鐄ꧦ鄰䛻뤭ꁞ㢸婢캔⠵ғ࿠籤慃鐕큩惗篁檿릺ꃹ䕮\\ud99a᚝馫⫁㧺ဧ龷ﺅ艸ᴴแ怊\\uddeaᚌੇރ軾朆ጃ겯䆗֮旿连揉萗嘾븍ٗ뀢沈䏉㰀繑퍍蚝ጊ䡹ᧀ籪ǌᠰ宾\\ud813耽৸ᩨ⮁䐲穠\\udeeb䋻鮶喛㤆栐縩լᵠ楁Ό緥힙禑겈䲴骩묹丕Әᆦ藾㾩㰓羦ﻬ멲誟꧁鰜䡽庿ث⵰䀡뜆⊉紩ꂥṟ闁悇埦劬䍎ഏ*ḫ啋笻Ƞ誹蹓ਪ\\udd21ꈞꡨ㈖Ԭᯥ阡﫩䐚끒싇펢ྻ஁襊䐓衤˫Ԭ℈む짲⬦솝ߒᎰ惁䊆ᰘ硡泜ꮡꠃ먗ꀽਆᾈᖲ貆㺊蝍ࠁῤ₄ힸↅΘ칀⵾봣ퟦ傂Ⅎܡ↔ႈ〇绺ⅷጔ뷸肃ﯔṠ偞的괅਩耺ɏ௾䔅蘖偈慖ٔᔐ⻁ӊ䘔龫쇷曌껾철踛⡠ҟꪘ줇⡾섊뇁ㅙ䏡롗섓蚴ᔸ䙡毠徃ꠅ؝온鷁㣁攤᡻鍊⍫렶몢ˋ箼œӼ枝㗖昂\\udd6c홸惒쀪렼Ꮹ徧ᜦ♗ꃘ毞Ʋ⵩℈쑪剏ꮀຈ雃센⪃槔聳莆렃剃䤻ḙ릴ꖛꬸᬓ둇ḧ䒮ᇬ䁜ὄﴑ锁࠻ⓝ⃌䪃뷄⛲ў䤽덮㬙恡聎ڤ䬐ᱱ鸁ꯚဗ\\udb89į冐᳄걬괓餁턺肬䟘ꯑὄ줛焚醯ᅤᏱẃ鋄䉆걆뮿ኌ䐼න㊀묑焋訧ᄞٱ↑䌒仃焜쓦䘼䊱௄㞻꜈䓫䂹᳞⪂局쁌暞耔䇧䴔뫬Ἢᰀ있ﲗꋪ찥ᨀ顸吀㈁䱘苯亐⟺뗲࿇혺餮戰涜뷱렂ᰖ둭蓞ۻ⌑쮱䷃呛ᅓ䄈觑⺜렀ᰀ䠖⃈礰謺螀肊ᴭ≄꩘ꈪ묞뀇ℨ쑮鄡䓍ᾱ`᤯銨釛ᨑ⽹㒑珘盫聱Ǹܬꩁ넁屮ꑆ撚䞴䭔峑ⴑ斉⚚碻譤灑ﬓ愋呸ࣞ愭቉镌㖰ꍀ8蓺爹㗍즫誴톀薭◢ꁂ樓묝뺹ዙ뒁䚀膽ᭂ䯠Ҿ୲완蠭⊜˄೔厑⣆鴟⁪琢㢔쨒봘ⷂ\\ud98cؔẌ࡛艒洂\\u0003솸\\u0002㻋劖䭵諡Ꙣꥒ턐됭䙘໕霼觀媚곦姀舩菀纛㜻嚔ꢐᤪ쭣혫ȭ.匍젶蒱ᣚ㊥騑뭇ã類练ꐉ鑗黭꣹睒ﹸ䮭ꇂ嫹气Ạ瓪ꖏ칿㭳봮\\ude05㬟ၴ˿㠮᫯떱不ᔌ們몸ૠ뇄盆렃쾌캽㧠∀ꀺ봻䥠㎦愕ꤶꭰᠢ䀩舦쁓؂ㆂ\\ud9c7頮䴟ӭ鋤蹰ᾠ␂✙垥ﻀﮅ晸牾佻訞롧섯㤇ሜ䇾辇쨓顖탹얘≀㥱릠䀖徰ﺲ㉘᳿⍞⳸ﺯᦿ긞욻氐幦怂쟫\\udefe앒㏼絸众ᦅⅿ쪐Đ偁兹噣谿㻨蒯ᡲ㷆ّ ᠰ\\udccf饭౱ᣱ掇꼗᾵焉杜䫡෇밑⡺냧욻윀ᗱᠣ鱆ꄃꧮ᏿땐ﺹ\\u001e Ʃ髯ᓈ뙮︔\\uda33▭ࢱ㹊녏䀺뇧Ϸ괬䥠㄁耏쐨琊᫔㳖ൢ塨麿ꐾ懡Ḭ䇰晱聄┬ㆲܛ᫣ꦱ領㒰ࣛኴ¢瘇뎥ၼ溄蕇䌢滱ꙧ᱃臞蝵ੰ袉ﳮ낦쉋읍⩼瞲☀萚ꁂ 鱱㸢凅\\udb25ၧ岥苄ᖼ峱喚\\uda83҉ઉ興鸝羔慷ᚸ汖힄볡ꉖ褫耘ම䆶뮄\\udc12牢讌™盀Ⲉ頬븅\\ud82fʖبꖉ₠⤏≃윌랲㡆畣眡혷쐺ᾍ鑁蘀⩀蚼觻왥䀀ɰŧ䕠┄࣡デ뱶↸蓼聈⿤ꢻⴇ斒幢⒀த➠ꆀ؇⠡艌䲾㍤鈤ꐟ才ꄃ蛰鱠΢瀂笈骠ꉺ➄Жᣡᤥ鉋袩ݚᬈꎉ⃻⸝ᡳ튱螧賉猥 幣硥旜䴢璊Ꙫቄथ飨ૈ鑉᷀金ژꊨT镒砆딤∍ɋꇳب띉봧㉰쥿虀ᇝ逑ԩꘆ㐬瀯䳀ےꋓ琎悊䎥⚇ሡ췲騝΢ʹ\\u0012訉苄댚㨃쁕ᑵꚊ뤐㋍ⱹ๵↚ꛜ㙂땳上㺍⦜⾠砶⛆\\udfcb놦ٛ᭭鲖蝫\\udc8d뾌娳獊梌땲ꌦﲦ뀥፤苁⏸ꋭ璦w䤏ݴ꤀颹沝⌚褘ꀧ꫖ࡾ᳻㬟펲퀆◒릩蓂媝肯乶飀⸲盉틩꿪ﱘ嫵쓆ᣜ箉췅ꆠ牷ꥐ琢霑㪰윑᪞猹짽䪧ᔶ虱ᨱ朖ﰉ끭篅쐚䪀塂욒悼槡胁콤ʡ頂눃橃㳐ꐳ섩ྲྀ暱™\\u000bᇧ䞝ዿꦚᏙ幆聫減䞶Ꝯੇ盧둑ċ\\udbf6凑\\udbd9웃ꑥ椼쐭ᵑ♚ᦲᡏ摷ㅎ䔽Ꮜ噰쎦Ꭸ枬堿䙰ߴ䃸Æ뤔㖶ㇳ닗㋬抰ఉౣ쎪ժ냜琹䷈螭憓숫䤈谜劲挔ᴎㄡ䒣Ổ厊싁캄䱪耤쒀๘犊晣㎆뀏鲻폮铕ꇩᯀ팗瀦聭Ȁ߁렀៮嫑댚킓拣ꐽტ鼱䴨ଔኌⳉ腮醢肀ꯈᐎℝ⧋늰ᛄ࣪ॊ੃쐞粮≧켺ἰ΁᪝㠍⧢Ⴙ䂆ᔙ辪쩫আָ螎ᛇ炛㒤㸾鉰嬲銦㢯ᚬꤧꭵਚ尤굡⪘讑憕烈ؚ爺뗺ꢭ똂놁莢볉Ფ뻂穣个ꛈ욪瞲憦訕䨀槟⍒歔돎֭䲽㫟䇺鍶鲩묣䈍⦡ᢇ秩詾꯸ꠁ졁䀐墡쭝⇦税\\uddf9\\udd28萯駩\\u0005鹘綀懙묛펾椒㍫ޔ޺잆몐灞줮╺駼危銅簞⩘駧䁉邕芉묑橂妊Ⓩᄥ莩싉ঁ♉耨捦㬦휑斸镸澩蕦앮♂买㉉捖漾횦趝ᱏ캎ꗝݪ烙㇇芇燙蓫቙荘Ĝ艅噠馪짐Ⓛ멸鯍萱যaរ\\ud803ꎍ蠯應ꭡ鏺氼ㆫఆ䪎䁀撷༂Ⰺචࢗ᧧Ęᇂ䂩尦꒓ꖘﻊ⬛䮷鰾掄丟ﱦ䒔̳縶⍥䢗ၕఌ렣駬唌퍦묖噕౾菦鬶眲኏驓柋噙⡘帘\\udd87襘䏯僁핻鈥\\udc46谏и醖槡鵧䲡쥔͙犇⶜㥽蟣撸寱᳥䖥晓ﺛ蜎骀␹ﷂ펔ਂ莆ߜ籩Ӧ༖ꡀ馀⍲祼윐且В즜Îჶꊙ礤좔Ჟ䋅♏᧒哲ॸ䅲◝໒壙訦圛橃뤄줺ᗑ踊훥颐籟ʚơ㨠閬嚬阮癙ﺦ夯㮧₮東⭥伬칠⢢霞朹鋥옜ﾌ릆䪞䂹␩䊀낫⋮০챾⌀抋ސ┼꒐꘮ꔀ䰩㏰隕✂ၠ뎇䱜ᷨᾧ㥃㩫懓ꞁૢ⬐흣㋆趞ᣧɕ⃕ᯀ梦怏謆傣䗄氐㉑䱻㢑ḧ騞脄向퀹䐌Zረ꾧鷘﷎疏漢視韱ᏰɅ㮢犌鉂䃩ᑤꉊ褃爼酢䂤㼤浂⻥쐰ꑣ\\ud8ad᪀䭮則抉聬醝ꗺ쿨軑詄겭š텛\\ud90e⏰ꟃ\\udf9f븫葏䤙つꤘ羚쑺ⓟ䐠㿹੄喰׼ᨘ䥉⧰頁儗뮶鑾鋠咙㈞鲑羛鈴뢿吝ᗘ䀖詍嬷ᒱ投ᨴ嚀먀ﺉﶷ惱䜰ค뎴멳鯂\\udc25벴瀇앺ຈﵒᒼ凁᧬丆䫬쉄滋㌎癳ꎪ਒颬㠤昏灺äూ垀㡥뢌ҵƎ⽄•ꖂ⁌思\\u0014䖞䖅☘ꄋ朽璎ᙕ軮⺔瞉꼌ꡊ캘Ȯ鱪䢅튙餉䘛珥⣂侼谁땆ꁢ梽詮⭱荀壓᪕ꁋ\\udc00悠͊鉉徳Ќ小싟ꎾ먴퇁Ѝ脽剀覂梀㾰᪢贡᪂\\ud8e0൸⎘᫳疂셓ꑗᏈቆ笁鮈焎޵悍ម埼⚎䞣ꐆ혿Əࣞ鵞䧘쟋瘛呙猄ґ䢊✀焅携䖙ᛨ䭻〹뢀꠆퀩隕≰࠱瑤谠塞ᒚ䔙ᑏ銀㠃\\udfb8蹰頖䄋鴄⣅鶋䀾樮⚔㵑㬉ࢋ뺷ឿ頖─撪䡕쪻稱ꇨయ␪ू颦牨υᨒ봪侸ꕎ┹⡿浔∥ᷫ䮏粳㣔䈸餥좕句\\ude01쀡ᅢꔐؠ웢刄瞛铢⧒ꁘ꩔ꪥ쐪๔笉脴奩俠᠎퐎醷ȁ碑䉻ꀑŌ釳\\uda06쌁糊瀕뚖熬麪䓶銁碥銔ಭ⥊퐙뀈撎⌠秒큗\\u0016傟䗐괦֥\\ud840脏ꂘ쀄裵죘橜噢Ǥꀨ㇀׼ቀ魰詎蹏᜜刯㘈긢轌ꬿꘔ䂄撱⁤窑␙໙䣎Əᰀ）ἇ樝֣ӯ 䕘᧍枋ᢘ\\t☔荘ﵲ⤊䀦肴炉ꅁ䢤䥂廢䈋遤䞢㉨䯩魫瀊L뎶唇ź厢\\u0006玼챝ꔪᐹ蕭ᔙ娅ഖ겶ΐ䢂⧃熳숢ऐ蚀誖Ⴏ聁Ⱄ′檲ᘂ堒\\ud8b1\\ud809艊ⶀ⏑쀏邍좇ꎞ婘≀땈Ẇ퀃턡ꍂ僦㫴즢著ꁉ⥤ꙶ荞㎨꺣몎ᑯ傗锃懀㻥亙섻炯鐜墄ᇅ吀踥ꁌ\\udc9d隟Ѡ㩴ꥉ쁊兔⇝∧승卬∡軂냡䗞堎᳐玤⧉Տ옰囹Ƅ㏅炖㱔쪮ˡ喸㋥㊚馥‛Ⳏ⺢増찋蘆ꨰȼ㖾ჱ\\uda50묐ᩯ⋥ₚ蕝㱢∠ˊ᮪ޖ䜊䪥儈䟟ځ媔䉖뚂∿樁喹䱥ᱟ䕅ࠝ靟ꡠ↊䁂҉࠸ࠥ܁ᴙ襡풁楫ᖓ嵜ୀ놢蠀ယ闲灩冓ᚕ⊨饂梂吉补几葔⬌䕖䁸ැᰈ䍩䐏散镒ꓠ餈蓴簲獲恃鮨鐃Ց켨啂꩕ᣀ觢\\udf01甕調၌⇢ꑾ鑕奔︥ᡈ哘䭥䆀㸗야盵켗⽚멋\\ud8ae࢓ᬖ铏Ⴑ뚖⿂媥ড়寲婇᭤ᚕꆚ\\uda8f⥬◲陬敨鸸Κ㾺觓쁖勿㬺廨갌♷姟搝ෲ֥䍦ʄ컔줤°狠退镪쬳꽨垹䲆埠䀓镫ƚᝢ鐕豦뾐饀様孶偅쯣㨤꤆馚톢ꪪ旓ꍘ茺㽖ᲊ湖骇噘ᲅ痺⻛嵖ⰷ죻덬籹㵧妞耘邸⩠؜ꦩ䥫為䇃֮袆汀᪲倍洡聘쓙剑嬰憕ㅒᘭᚒ唃⨚擔ꀇ뎛㩦壝鯕퐁쮀犝⚜鴃ꨶ㥂徾胀⪌釼鼹㮇펗੨떩㥞詊ꠢ菧뵛葹ᄿꉩ꼋맕牛簡㗱撫彍梙녙絕굾ꦂ孻ꔓ藡ﻫ甊ႉ钒搇驒碢㪰夋攖腶ᙘWぅ떚魜됢\\ud998祿╭潥\\udb01ય浗픺ᄱ偡⮌注⋨姱Ӻۮ붺䭤ຬ梁䒱碤ཬᖺø历ᐊ夎鯇州㧧鎖㕒鉒䡁췃禅ㅬ烦呁酜ࡎ\\uddd5奓ꔒす颴빹ꈣ퉨ꤽ厍嶂䤻牆␘䀆秝M亹陬禃횮῭潙䧥䤄đ쩥豐Ⲃ䀉ᾡ톊ਫ਼卙㨣蔧ࡴ屋홤ࣱ瀕垖榥\\udd4a敃䍎㊧뵋핮杽઄㦐셧齐휼ቜꞩ绖帝䂯ㄇ叼ꝉ︊笉ﵦ疶ꟑ乤⫵܋곣샥䉳ྀ蹵쎘ﱘ͍븋ꂀ\\udda1㷙걒酐勒횒虄㐍ᓤ쓦啵\\u001d혿圃⻵柔抄䵯떋螵麿胵䣘ﾁ秌ꎸᕙ鍵둗셙뢹䕞戽쑖ส垠樅沆畬㝳彎䙌7奙휮ₐ㐯垪枌퇦絆赃헟媯菵먵Ｎ斒鑖庯㽾홖癆琚胇Ꮟ幭羉阃ꊸ圌唊楖イ燭合ᛕⱏ܄馕딈楴碀茼栫굩叚䤒➣楢筀弤窥퉹⤕꥔沃뢱ⶓ痔ā➄卑䴁*乨᡾ꎧ㮍喎䴝㞵坁䘜헁\\uda53ᐉ䵽㐣䳀你꧑ẜ疤鈜憥ก⏜쨁\\uda57鴾씙캬兴￸慽0員䉘\\udbe6Ꙧ퍮䵅霒鷺織ꥐ耥啫⌚Ŋ顀婝謋Ⴄ曔墠咸䜒㳜ᐢ喉崃血ﵳ࣬ꀬ炐䍿ଈ惠Ꮸ൵ᖐ픦䯤㝑壄\\udb0e䑀쁞\\u0012钤ဥ௲㽂尕촽㚌\\ude70㔹ﵲ堈漰䔺ᅑᕶ璘\\udca4룭왻়晰麩鈾嵻䳈ᕿ肌඀╄媳죨䪡Ë譆趡㷕굤覘䍥죴䏀팝泱臧ഃ衰胈ɀۃภ糃䡎兀룔Ν䋐㾡餀긏₌ଈ⛠멃콐\\udd70섥膥藘咸㷲ཥ\\udf10琴鉻ܜ⚚溫ꀠ\\udf8d鈍辨ꃜ訊w녻喆똲\\uded5惚ࡷ蹧ᒣឫ曵薀际ဿ搃嚖ͼ鉭ꍅĊ斃쁋䋂ܑ⪀셟老Ô઻廭悖狔抅萘䂆\\uddbbᆚ\\udd12斣ၽ\\uda3e햖\\ud84d颈犁嵔蚜隡픝ꭽ唵釔Ⳋ䍛쓡ժⷨ䮠䘁᠑怓ꂺ檊ભ凸䫬5뛯肎ة畠쫩ꮍ瀎懕Ꙥ抂뭆u듸픫矐潒ܦƅ烔缶卄쇂䟐ࡀ७∵䃖괴젧锏ꏍ䎴鴏饻䭵ݖἮ憶ﵔ㡞뜌ᷬ᰾웘耡怍陂Ú๭券㡟歈ࢎ뗪쩛旵泤밞⹲뫫핓逓畐㚶勔멶ᵶ䁪Ճ弲恴ࠍצּ娿殤࿰㴝ꚵ㇘썷倅⚁꩖貵왤崪퉡횞\\ud8ddꜭ늴╢\\udb40䴸䊓曑䪭檷萍ﬢ쑰ͪ\\udbab纭᫐怶偃̠׸̝㒒⹍漣깠報틐␐鮶雝筂䴔듥⑤辪阨䡐㋰릈헻䰍粠𧻓⭑矫ꫵ灭ꮴ惘ꍴᵊ搎갴곥섂⇗╈樎䪛昊쾒Ṟ淙⁂އ沵戲囝孿鷇뙱탛俚䶶齚캲땚凛䢝ﶆ፣\\udb58ꧡ훝倻䤍뺴璞扷患띚脻哭㎷ఇ㭫뤄쨹沫釭Ꟁ됎뭲\\u0016矛꼖敵쨵﬘▁孥퀷箝\\udd40廛芃몟땠췻應ﾴ㗜鷸\\ud924漺Έ㎡᭿ᴡ県ᒎ㙨ࡶ㳜蝶唍ꂥ퇝灝⋦꣞ᶹ鯻徍wgᵌ夽킥\\ude21έ㑵䝈ɻ盥퉦모蠁頋䵩皹\\udab7糝룀谁❎质쭭\\ude86ꁭ쐵䴈ᝦ⇷瘋羕裷堈၌ម숵蓺崙┪᱊喢ƥ半軺қ껏䐖盧̒\\ud808ᩝ쓥忩赛難횟蘽퇖閖㵞昙㊥圂┘붗㸊콀쀛噇睵⹷裚❤跹Ʒꌣ掙磗㦐ꍶ㶑떵釣䝙콴\\udf59⭥㥽攋텢䔭걓烙덝ᔗ쐣謓幚\\uddd7ឭO恶锾烀녑ﻮ⊵顗ꔰ嶪詍揂浨鶴簯䞸薼⏀⍘斈钱ৱᆰ\\u0011挞怘⏖Ⳟ뛬徑튜ꐞ鍳蒩➽ꪓ恔줦꓂憚伙剤햻椩綳튩䵩㷠얒♄育闖阁啍誖洜\\uda76퇐᛭ᦩ䛶\\udda7⁒쒶紊鋧푮⤠斠។셑紖捗훾憤埓ﴉ離䜙ͽ旵㟔楦泝芺侲㮤⏵穏齔倰కꆑㅂ検攵謙ؼঐ濓윪ೞ芺ⴢ넃楈罹̟ົ%䈣ꐂꠓ肘똼؋ⶀ́튦\\ude87穥㤯鏕ꌤ쇊怊콝\\ud800뙯勊⑝栍생쭕䲴킨并佀맊鑣囲哒ㅥ黊氋₪扌䗆ĥ㙒贄脵⪕⯥櫠ⲓ꥛슃鰥唞༩㒰鰏疀╷춰㫞⩦㷭㛀鳗䦻Ꙡź啺෨ᙀ텃떶ã텨ᖽߥシ䄊ꔿ秾郛ʋ厤鋲礪㡤턨㐓뗽珴漎㢌‐搹꠸ᖀ\\udf66ȁ树䀓ꇓ᠀ᵾ숒鍄耈齅隙ᑰ䌚ቸꚒᩒ\\udf45䵫䙌꧟岑⶧퓜䆣䷽堿汬\\ude0f嵤帱暈㭀玸眹ⴜ煱鷺ᎊ\\udd69妒괨肋샵瀜ಅ儅䫨畡忘ꅣ頌⛐왈傀捆봍碥༖쾸ㆩ袀鰇⎵쒮⌃숢ἃ檩綾슒衒⠺䳞ᚴ临ꌐ鐛춤뛩캐وᨃ숚逍悩ร飹갠璁桗砢ᚠપ舠⌁౏ࠄợ퇤詋兕㾖㋞샎紂ຎ菙ດ棑㐿咿䌷ౢꊡ殜ຶ뀶ꬤ勅퀈샣ˢⴍ谶僈\\ud8c0福佰ἰ뺫፫᐀迴㐈偡簽☣䚂阦ꮧݚ丂熉䔊⩟䥊咊꼍됽횬啈轵踃栕ᥖ냠咂㕱疰辷䕔蕞䉁쉐쥲錝ᗊඨ೎Ḏᶓ氶횩빸꟦\\udf17㐼᝛䗉╁锸⑿ꙅ窆᷹ꠈ镦啬轜㈿獸핃쉦䕸깂竼\\ud814肁휹㓖ۆꮀᏘ튬햭⯍巖ྎ▫㞦ᆉ䍮逌㸔栬⎀㚉瘢헱ꭎ夳瓍䐑틝혃ⷞ竭寶绕ﱦᵚ僯浖옉横䬺瘋൑䃤˫呇Ţö᷃䤉恆䡽풓芙궴迥倇畅瑍\\udf9cꏝ﷔ᯝ淆\\uda6f忲槆脦⦣샶ᘸ్퐷滑嶱\\uddec뙗裡燂ṓ杣軧Ͻ\\udcc0᝼嗒㾥脌睬䭛䔵嶶०嵆팫䘂⨉䧟壢굲皪\\ud9b8׭骴꧐Ⱊ鷁ࠚ\\udbb8⚝⚵ᐌ耹괡㯅鼯焵ɶ䃁靽졕뛎㬷䧭빵燝崇用탸퓣눳뛜쀧涴ﭶ\\ud975䫣铔䝝痪삶환폵䵴뗞㭲딽沘籠㧙飴ಌݖ㝝蒺⻚鲛飥퐷䣝칷⭟磮㢰哉౴⸺Ӓౢ艄歷꽘띨穱㑜隐軥ච篂Ṙ녯뚘褸쏝竵꣕壏㵊푲爽㛥㗞䝒듏ᅡ㸸䃴춝㜑䂠귔⬝켺죡읋핟轶χ光탷瘿挃꯶㉶➠䎎\\udada搱₽熩㩣᎝ᐨ⩤줁쒭޷峣ꮵㄹ㝡㛋賆㪭嫣岶섰ᚼᏤ蘡㬧犭箌ḼꝪ鴺侩\\ud86b匌\\uda74砋Ꝿ鶆瘪넓ᱷ駔Ⱆ賮\\ud858ᖴ븶㨿鏯軩㐮럣謋㛝ᓹ午ꄁ㐙땝辏紅坂挵瘍ෲఓ鮏㔳ᓠ⢚퍬ਓ䖁ꄾ潐䃘딌҈ݝ硏컔松叀Õ㩄생ᔺ孖೔互莏拣祿d葌鈔괱쓢揜伷╧旉쁺༦蓂䴝樤㝸嘻荼뫸㗧雷䣵콗渲7\\udde4툵曤흼驎묒ཉ鍹瞃햳蛣陌㩥솒䴽힃崵罏ཝꍶ힏廐᪊婤踳ᕃ\\ud96d悩㶼舠䛖\\udbd9\\ud8fdҕ\\ud980狶阵歽㧄錁☠뮃ࣀᔰ颲ན\\udb4f攘Ⴚ輑职致쨳ⓥ珝ⓧ᏿佽࿏䟝诓佘봙喒커뗽郎喟콝厙欰횀⭐籶銂퓥젪呷疓齎ꌹ壺㍄甠≇䦽詌⫝̸Ѓ씭跃崕㔭鵖믁蘝뵮ピ죴鮍籍㰦ᕨ锰辫㴘퇡㖌쓮蓪掉ꮦ㳾㘓\\ud98dః⍃뷘㕟巏䲳壏줳購굱프\\ud83dᤙ忞良搓铼啑ݣ㘴쇝杒䷷ϻ\\udf9f୹薦얇娻蠖⬐钾皜踶핏쐚梨㭹⦄ഞ䠒倈ⴆ䳲ູꢵ녅\\uda0e硦㒺偌⇨㴙⇨뎃堀빩ˋ໾蟥ꇶ碀㠝ꕭ譔圹龰첑켳२ꔝ⭌㬚ᅸ\\udc05ᛢ署磜촢ఐ쒑ꄍ半ꕵ㓷\\udf01绑蠔໠Ɡ汧쵡䥼ퟍㅗ糺䎣횔閞\\ud8a5┎繡絾募ま빃\\udcf2艧棨ⶼ턂킐끺숻샼⌺ꀩ젔밡꺹숿눳碿쿷鷐㯘嵳\\ude85詎桹퇬㣐ǖ䜏顓죹⫏荢㞨－ﱃ鈽祂虛เ돐៙缤掝侰ꐈ\\ud853݌迯ᣯ隉辢婀㟝癧⃝♝\\uda85甓廃憌鱖阙抯䠃ཊꛐÃꭗ⸖ၾ荋尮웏納㝏厈⩢ﶦ楦䜷ⓜ謊⻠ꆜ힭頻潑㷏䤤萝⁍坥ꇧ蛉ㇰ䏵杛捃펠☖ར\\uda4d뚺Ĕ婿\\udca4ꕫ䫌\\udfa4䀮甓骅ꌕ쏓㰈\\uddc3祀䤠嘔鈾˄溳妣\\ud82d룭㑹팔䲼㼴焅ﮘနഉ諕蕀뙃衁䯸ㆊ贚叶և˳䂪쉳䬕䘨⺍裇ၺ軬偈画想ጰ⍜ꍂ㞷䴣ꪏ낡죵ᓴ捪㳎⺣뢌炽р⁾Ꭸ揕ᵈ뙁낧鋷☡軲銣㼩ᆎ઒坸猶Ⰱ㈳ꑎሮ挱嫀헄䝩㨍魶릜ꋤᵊ환먢⮀഻禁ꤳ瓍옆道쯄넰닧쯁䲏첋뵏锇畞闞Ⱬ\\ud80c臉ۜ袇픳ꔪ㷵懝頷⭜赞悤寶芪䪩捛諤㻸푒늊닍ۖ䫇\\udd17垵㫲偏瘀㓗鴦婴霔㯘\\ud922偔ࢍ\\udc26휋⮎䂲暥흘賅疻信팞穳覍原쒢ϝ㉀돊ꨍ瀙썤ൠ귤륛挳羍ꪵⳍ댯瑲릜ﲳ肮ዩ퉲怣섽ཇ떨髌택곌㍠ኀ㺳켹᳠䤮긂亀㮫랢ᘎ⫩遒깋Ꭰᗦ䣕טּち쥡ꉹ韲쓀ᬰ✣獝\\ud833융嗃戭咽닞홝ੀ㼐嫒孍쎅ꕊ梀­ꗻ⚥遐ె䑼︅㴃碁⃉䏨ࡖ⪁恋鯃譟撈₞椻ᘉⰒ什⥣敭遙褆⳹笖퇉䅛╒兲뭫⁒୥ꔓ찧亖઀耖ᐃ䑦紳ᥦ䑙Ṥ킍ꄨ魿摕郴淐㵤ꎒ栏糼ꔍꑷ퓚䑃\\uddf4꩛\\udf4c麱༴\\uddfc왤枭ꄡ竧ൗ갵䒛淫䜀㺿뀓ᒃ䫙∈幐膷怏摠渎䶎ᷫ▛䆶㼋ﵒ焣苤܁烠ꀤ챓歴๣⻲聯ꠓ兀ꕬ䉣詻鸣꠷냗啷莭譸❴棐猽᪼ᬃ¤꣊哚歙뺫ꅍ碉㙢˴禪㍪ꃆ탍䖉뒇촥旨᥀熶꠾䨓ꉎ蠀ᕎ잃斦冶퐅괍뢌ꨁ敍뺼ﳞ뢯쵾뻼읩⪕⁒퍏泩뭴䈐\\ud993鰃＂ଽ聉⸙⒅甌骬㬋땝菄㣴೷톗♣᥸摛⁆䪐ᛈ鹿뀮埈潘꒩㘎ό༌Ⲷ⫕ᄦ牪簇樁蓳②浽洫᜼뮃ఊڲ¡㮝ೠ攀ⴊ⛹豌Ꝟ♦ઢ銤喳씁脷圲\\uda20鼙伬鍘㡻㨩꼕龌혗ⲁ\\uddf4ⲙ腤睓崥睘믥릙覌\\ud99e﨔又찓⏢퀫낪ᙗ餂Ħ辦ᾙ⃍插캞嚞昽ᄖ䇛텥즗᙭Ꮅ擼仓ཉ᳊﹖콽㭿ꆽ줺䝯㴒Ꟶ끌탛⍮㪵橳넓旛⻬䨹烥햛\\udc90此褁ґ磰꩏鄘堋姂㤬ﺽ㚮綰䍭挟痵돤Û⛒η♇\\uddf0㦎嫂㣧坖蹕㬔ඎ絙쳌㴿໯聺ꅣ䚓ꭦ枒㭒䵣뵘\\udf6c㬴绢易뺢聀䃭\\udd3b໡谬ࢎ죮怆뙣뵭롒楛ꛝ鬼뽚砅蝂䁜ꥩ鮑඿ㆩ俫݅缾䁎Ӛ淫눂蹮녌«鯝脑켐஀ڌ㩯ꖖ쪭蕥゘踃㸫ꁬ儞䵴跢 䌵쏩䡺\\udc9b锘녎갠₥뚫ộ䂴\\ud86e鰵៙ݹ䪴䡲ࡒ偧焬鮦㼁\\udf14Ȝ蜊⌢⠉椂뷪庆ଙ貈灯͞⻀쉢襨マ䝙డᯃ唆㘃飱礲⢛끂ᄉ䜱꧝췂媏㣬啱滀ኺ묥涕볃⮦啮ጃ囸鯓栵뤀卛鯯貊훠诡輈뗖阆瞼Ꞡꉞ蘴鄞ﾹ㧏轚斜⁤滝졀㵉躄宗⌴箦╃돳龠⌐됄\\ud918㭶ॄ἞ᷔᄷ悴⺈㌠쏬㏎瘥ꐙ经子ꀦቑ㑻ڇǌ瑚鍷낊숓仌辸帍⇷⃎ᵾ콭媹軏팘캽\\ud99c쿛軎旣萄鉬݀矯鄓쀀☑䓙때✮\\udb3b䣯ꋨ堫ߨ舖˾︃ဍ컔禼㭁霻\\udb37壓ݡ磊ⴞ﬇䌊灺깅奮팮﬌Ȝ⮵輭᷇ꁨ煠逇䶑北⇻赲Ὓァ盎犸쇮㎑좟梱乺쭏⫡Ǉ\u003cᵧ寄쌅᡾컒믮ᰔ줁⠰\\ud874ᚰ䯎❣뗲\\ud9ed姏꺶ꅷ둈⚇⍎災绷签ᵪ폂석ࡺ懚䞶搔ȡﺀꏭ\\uddde뙒৐ܗ擏嫻嫮隚糮뮡菫뛟军䛭⩕둬צ킁喛훯ᴙ魡耹띦\\udebe\\udf61責꒣蠼㗥膥⬨\\ud8c7쪞햊ྦ葭᝛䓋놀豃鹊\\udc5a럫枈굌玘撢鿰휐μီꃸꚰᘀㅓ䕊綺̬纯㾤㤵與ꮉ⃇ꑠ茎୚꾰퇢蓫띐띠㯭햹⛣寥洟끿㛕䲵蘲쭟\\ud96c띹㡴悃爜r⎼牪檇禘솮侮胾≿듾\\ude66㓕ࠅ鴹➍画ㄉ뺄溢鞉\\ud8c1帯氓洸콛鲃輦鉞⟔˱؜䕰ଓ扼港✠菊뼜ꝉ䖀ⱌ†ҙɼ證䩍⒅㐭詟䞝ఠ⋱젞懻\\udb22虪믪圧爓阊⧳)쵗㳎숻℟ࡵ됵僄鳺噉\\udc09চ䀍➎鰲狾ደ퀧針⧬ꝑㅺ粩\\udad0⇁ꩵℂउⱭ靑ꂝ㑾㔎뮣᷺໑意뺻卙믦汛댐햻ϴ\\ud9b0ۮ믱鰻듮０뇆뮾ﵚ퇔㌅供ケ݊嗕썇㝚㦐㿔᧦탸醦뽰㨓걓罝怤⊚\\udc25Ԫ⫈㜯༘퇙৊ꆍ挫ꪨ흃兗耦쏫舮鼪쬍톰犪昍鴟呧ੵའ魝醚箣ഖ낲퀱ᶑપ锾㫼枫뜖⡱拒㋄舍槁䭻墫덍鋨₹ⵚ㿒쐢茮㰀栤璺扤밉冞팇৫聛纄ᢛ킟\\ude61ﮠ弟뢉\\udb5b좜疺쭙脶伌ኬꩫ䊟밎䴫掖ɣꯍ抵赉乢碘ﵧᢑ㙵䑨\\udb01뜂먜곛﮵৙筘⯨궳婻悫誾뛞⮲㘂蟧焫外ݐዥ⬖켽⊍夺ᓪ捕㧰㭠ை훊咯ꢴ澲攋끨嘟ੀ彔떆혺堌ꈝ涐ꐥ펂撽듘⮕䲳Ʂ\\ud8a1ナળ䵂㎎ᴨ秊쳖螪쵵㮐ࠦŖ稌䳍궰ീ፺ƞῶ态쐂딶푨쀕윐붔饵૥餎岠࣭䊳鴥깱䴆첚㥌ꍷ㔻䳡햞혠矸皯粼◷ឨ껈웅듊઼⫠분鵖昴ߧ⎉\\ud9db擝鶏榕뭌턱嵸ꞗ࠺鉖뵵쩟ᙛ㔓厷堰▧柠룔Ꝩ忓銬贕ꎟ慽罾﷼ొ\\ude89죾⼬抺⋴诬岋댖ꔗ趟堆⠞掁됖㵁\\udf3bฟ쑿䇷쬮᱒留ꍣ햃㘲헗Ŕ島爤ճ奜앷뚛洐꺉緵\\ud9d2ᢞᲆ헲隧佂뒊\\udad7㡹鳡흇햊ͅ켓ԝ鈭Ს\\udc2aĦ蹣៽侁炾Ⳋ赯沄믴췗褝\\udd77䧜甄˵劀➫À荺䀍㎦꾾繪싌ꂬͺꟸ\\uddd0瑕ຮ镱꺒圦폳㆕攷␃窿孯ꯝ臫㫃惗턬逪ᫌꝕ憕䦫╵䣒壥ꮩ찑\\udfce첓ﭝ闒Ꞡ툘퓀✐\\uddd1⊓虾쵇嶏浣埗筍閫㗮㵶㜞祺㥧ᮮ噱᳠뭩遲瓙틝ᆆ쑶乀뭟澄몶䪟얃倊꒣磢ṑ窯ꈬ苤흪⊠\\ud8b6項扠∳椘ە톜䜭䭷뎝跥ï歹ೲ䙹껥㢴䓶״繰빆迉耝ㆀɇ놴鬈랁놿᜵붗⣂̷ᴃ兒ﰇ⬋䆅䍈သᚺุⷪ㮓㙘㮽癹㱈ꄹ泴桕煠ᤁ﫦跽䯌ഈ茯ℛ퀐贔㢼ѧᲅ胖ِ称ꘔ态‾扞蹀◢챘傞星〤鿏萉晰埨碉˹䈼➚ข괝᯽࠭⌖ᐳ\\udb0cⲁ萊槀Ҙ싲툪ନ肛艔鬃脩ꂖ吧ꮺ堽\\udbc5\\udb96䈨ষ䡈㽾埏ེᏪ헆瀰밾䌈ɀ⮨絝氭駸㴫열䁔览ꌖ琋腢웊ꌋᵳ琍꠽ִ酥ͨ쨴猤彴혪鮀Ł诈㾀㈁␗鬙탢ƅЀ\\u0000\",\"actionData\",\"errors\"]\n");</script><!--$?--><template id="B:1"></template><!--/$--></div><script>$RB=[];$RV=function(a){$RT=performance.now();for(var b=0;b<a.length;b+=2){var c=a[b],e=a[b+1];null!==e.parentNode&&e.parentNode.removeChild(e);var f=c.parentNode;if(f){var g=c.previousSibling,h=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d||"/&"===d)if(0===h)break;else h--;else"$"!==d&&"$?"!==d&&"$~"!==d&&"$!"!==d&&"&"!==d||h++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;e.firstChild;)f.insertBefore(e.firstChild,c);g.data="$";g._reactRetry&&requestAnimationFrame(g._reactRetry)}}a.length=0};
$RC=function(a,b){if(b=document.getElementById(b))(a=document.getElementById(a))?(a.previousSibling.data="$~",$RB.push(a,b),2===$RB.length&&("number"!==typeof $RT?requestAnimationFrame($RV.bind(null,$RB)):(a=performance.now(),setTimeout($RV.bind(null,$RB),2300>a&&2E3<a?2300-a:$RT+300-a)))):b.parentNode.removeChild(b)};$RC("B:0","S:0")</script><div hidden id="S:1"><script>window.__reactRouterContext.streamController.close();</script></div><script>$RC("B:1","S:1")</script></body></html>